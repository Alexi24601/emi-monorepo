//! This module contains the nested structs for the database tables.
//!
//! This file is automatically generated. Do not write anything here.

use serde::Deserialize;
use serde::Serialize;
use diesel::r2d2::ConnectionManager;
use diesel::r2d2::PooledConnection;
use crate::models::*;
use crate::views::views::*;
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedBioOttRank {
    pub inner: BioOttRank,
}

impl NestedBioOttRank {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: BioOttRank,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
                inner: flat_struct,
        })
    }
}
impl NestedBioOttRank {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        BioOttRank::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttRank {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       BioOttRank::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedBioOttRank {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        BioOttRank::from_name(name, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedBioOttRank {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttRank::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttRank {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttRank::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttRank {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttRank::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedBioOttRank> for NestedBioOttRank {
    fn from(item: web_common::database::nested_models::NestedBioOttRank) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
impl From<NestedBioOttRank> for web_common::database::nested_models::NestedBioOttRank {
    fn from(item: NestedBioOttRank) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedBioOttTaxonItem {
    pub inner: BioOttTaxonItem,
    pub ott_rank: NestedBioOttRank,
    pub domain: Option<BioOttTaxonItem>,
    pub kingdom: Option<BioOttTaxonItem>,
    pub phylum: Option<BioOttTaxonItem>,
    pub class: Option<BioOttTaxonItem>,
    pub order: Option<BioOttTaxonItem>,
    pub family: Option<BioOttTaxonItem>,
    pub genus: Option<BioOttTaxonItem>,
    pub parent: BioOttTaxonItem,
}

impl NestedBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: BioOttTaxonItem,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            ott_rank: NestedBioOttRank::get(flat_struct.ott_rank_id, connection)?,
            domain: flat_struct.domain_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            kingdom: flat_struct.kingdom_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            phylum: flat_struct.phylum_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            class: flat_struct.class_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            order: flat_struct.order_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            family: flat_struct.family_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            genus: flat_struct.genus_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            parent: BioOttTaxonItem::get(flat_struct.parent_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedBioOttTaxonItem {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        BioOttTaxonItem::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttTaxonItem {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       BioOttTaxonItem::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedBioOttTaxonItem {
    /// Get the nested struct from the provided ott_id.
    ///
    /// # Arguments
    /// * `ott_id` - The ott_id of the row.
    /// * `connection` - The database connection.
    pub fn from_ott_id(
        ott_id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        BioOttTaxonItem::from_ott_id(ott_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedBioOttTaxonItem {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttTaxonItem::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttTaxonItem {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttTaxonItem::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttTaxonItem {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttTaxonItem::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedBioOttTaxonItem> for NestedBioOttTaxonItem {
    fn from(item: web_common::database::nested_models::NestedBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            ott_rank: item.ott_rank.into(),
            domain: item.domain.map(|item| item.into()),
            kingdom: item.kingdom.map(|item| item.into()),
            phylum: item.phylum.map(|item| item.into()),
            class: item.class.map(|item| item.into()),
            order: item.order.map(|item| item.into()),
            family: item.family.map(|item| item.into()),
            genus: item.genus.map(|item| item.into()),
            parent: item.parent.into(),
        }
    }
}
impl From<NestedBioOttTaxonItem> for web_common::database::nested_models::NestedBioOttTaxonItem {
    fn from(item: NestedBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            ott_rank: item.ott_rank.into(),
            domain: item.domain.map(|item| item.into()),
            kingdom: item.kingdom.map(|item| item.into()),
            phylum: item.phylum.map(|item| item.into()),
            class: item.class.map(|item| item.into()),
            order: item.order.map(|item| item.into()),
            family: item.family.map(|item| item.into()),
            genus: item.genus.map(|item| item.into()),
            parent: item.parent.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedDerivedSample {
    pub parent_sample: DerivedSample,
    pub child_sample: DerivedSample,
}

impl NestedDerivedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: DerivedSample,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            parent_sample: DerivedSample::get(flat_struct.parent_sample_id, connection)?,
            child_sample: DerivedSample::get(flat_struct.child_sample_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedDerivedSample {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        DerivedSample::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedDerivedSample {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        DerivedSample::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedDerivedSample {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( parent_sample_id, child_sample_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( parent_sample_id, child_sample_id ): ( Uuid, Uuid ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       DerivedSample::get(( parent_sample_id, child_sample_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedDerivedSample> for NestedDerivedSample {
    fn from(item: web_common::database::nested_models::NestedDerivedSample) -> Self {
        Self {
            parent_sample: item.parent_sample.into(),
            child_sample: item.child_sample.into(),
        }
    }
}
impl From<NestedDerivedSample> for web_common::database::nested_models::NestedDerivedSample {
    fn from(item: NestedDerivedSample) -> Self {
        Self {
            parent_sample: item.parent_sample.into(),
            child_sample: item.child_sample.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedLoginProvider {
    pub inner: LoginProvider,
}

impl NestedLoginProvider {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: LoginProvider,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
                inner: flat_struct,
        })
    }
}
impl NestedLoginProvider {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        LoginProvider::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedLoginProvider {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       LoginProvider::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedLoginProvider> for NestedLoginProvider {
    fn from(item: web_common::database::nested_models::NestedLoginProvider) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
impl From<NestedLoginProvider> for web_common::database::nested_models::NestedLoginProvider {
    fn from(item: NestedLoginProvider) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedNotification {
    pub inner: Notification,
}

impl NestedNotification {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: Notification,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
                inner: flat_struct,
        })
    }
}
impl NestedNotification {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Notification::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedNotification {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Notification::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedNotification> for NestedNotification {
    fn from(item: web_common::database::nested_models::NestedNotification) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
impl From<NestedNotification> for web_common::database::nested_models::NestedNotification {
    fn from(item: NestedNotification) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedPrimaryUserEmail {
    pub inner: PrimaryUserEmail,
}

impl NestedPrimaryUserEmail {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: PrimaryUserEmail,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
                inner: flat_struct,
        })
    }
}
impl NestedPrimaryUserEmail {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        PrimaryUserEmail::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedPrimaryUserEmail {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       PrimaryUserEmail::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedPrimaryUserEmail> for NestedPrimaryUserEmail {
    fn from(item: web_common::database::nested_models::NestedPrimaryUserEmail) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
impl From<NestedPrimaryUserEmail> for web_common::database::nested_models::NestedPrimaryUserEmail {
    fn from(item: NestedPrimaryUserEmail) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectState {
    pub inner: ProjectState,
}

impl NestedProjectState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: ProjectState,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
                inner: flat_struct,
        })
    }
}
impl NestedProjectState {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectState::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectState {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectState::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedProjectState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       ProjectState::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       ProjectState::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       ProjectState::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedProjectState> for NestedProjectState {
    fn from(item: web_common::database::nested_models::NestedProjectState) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
impl From<NestedProjectState> for web_common::database::nested_models::NestedProjectState {
    fn from(item: NestedProjectState) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProject {
    pub inner: Project,
    pub state: NestedProjectState,
    pub parent_project: Option<Project>,
}

impl NestedProject {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: Project,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            state: NestedProjectState::get(flat_struct.state_id, connection)?,
            parent_project: flat_struct.parent_project_id.map(|flat_struct| Project::get(flat_struct, connection)).transpose()?,
                inner: flat_struct,
        })
    }
}
impl NestedProject {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Project::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProject {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Project::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProject {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Project::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedProject {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Project::from_name(name, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedProject> for NestedProject {
    fn from(item: web_common::database::nested_models::NestedProject) -> Self {
        Self {
            inner: item.inner.into(),
            state: item.state.into(),
            parent_project: item.parent_project.map(|item| item.into()),
        }
    }
}
impl From<NestedProject> for web_common::database::nested_models::NestedProject {
    fn from(item: NestedProject) -> Self {
        Self {
            inner: item.inner.into(),
            state: item.state.into(),
            parent_project: item.parent_project.map(|item| item.into()),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsUsersRole {
    pub table: ProjectsUsersRole,
    pub user: ProjectsUsersRole,
    pub role: ProjectsUsersRole,
}

impl NestedProjectsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: ProjectsUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: ProjectsUsersRole::get(flat_struct.table_id, connection)?,
            user: ProjectsUsersRole::get(flat_struct.user_id, connection)?,
            role: ProjectsUsersRole::get(flat_struct.role_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedProjectsUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsUsersRole::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectsUsersRole {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsUsersRole::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectsUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id, role_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id, role_id ): ( i32, i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsUsersRole::get(( table_id, user_id, role_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsUsersRole> for NestedProjectsUsersRole {
    fn from(item: web_common::database::nested_models::NestedProjectsUsersRole) -> Self {
        Self {
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
        }
    }
}
impl From<NestedProjectsUsersRole> for web_common::database::nested_models::NestedProjectsUsersRole {
    fn from(item: NestedProjectsUsersRole) -> Self {
        Self {
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedRole {
    pub inner: Role,
}

impl NestedRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: Role,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
                inner: flat_struct,
        })
    }
}
impl NestedRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Role::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Role::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedRole {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Role::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedRole {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Role::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedRole {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Role::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedRole> for NestedRole {
    fn from(item: web_common::database::nested_models::NestedRole) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
impl From<NestedRole> for web_common::database::nested_models::NestedRole {
    fn from(item: NestedRole) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampleState {
    pub inner: SampleState,
}

impl NestedSampleState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SampleState,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
                inner: flat_struct,
        })
    }
}
impl NestedSampleState {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampleState::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampleState {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampleState::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedSampleState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleState::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampleState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleState::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampleState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleState::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedSampleState> for NestedSampleState {
    fn from(item: web_common::database::nested_models::NestedSampleState) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
impl From<NestedSampleState> for web_common::database::nested_models::NestedSampleState {
    fn from(item: NestedSampleState) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSample {
    pub inner: Sample,
    pub procedure: NestedSamplingProcedure,
    pub state: NestedSampleState,
}

impl NestedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: Sample,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            procedure: NestedSamplingProcedure::get(flat_struct.procedure_id, connection)?,
            state: NestedSampleState::get(flat_struct.state, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSample {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Sample::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSample {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Sample::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSample {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Sample::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSample> for NestedSample {
    fn from(item: web_common::database::nested_models::NestedSample) -> Self {
        Self {
            inner: item.inner.into(),
            procedure: item.procedure.into(),
            state: item.state.into(),
        }
    }
}
impl From<NestedSample> for web_common::database::nested_models::NestedSample {
    fn from(item: NestedSample) -> Self {
        Self {
            inner: item.inner.into(),
            procedure: item.procedure.into(),
            state: item.state.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplingProcedure {
    pub inner: SamplingProcedure,
}

impl NestedSamplingProcedure {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SamplingProcedure,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
                inner: flat_struct,
        })
    }
}
impl NestedSamplingProcedure {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplingProcedure::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSamplingProcedure {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplingProcedure::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSamplingProcedure {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplingProcedure::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedSamplingProcedure {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SamplingProcedure::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSamplingProcedure {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SamplingProcedure::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSamplingProcedure {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SamplingProcedure::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedSamplingProcedure> for NestedSamplingProcedure {
    fn from(item: web_common::database::nested_models::NestedSamplingProcedure) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
impl From<NestedSamplingProcedure> for web_common::database::nested_models::NestedSamplingProcedure {
    fn from(item: NestedSamplingProcedure) -> Self {
        Self {
            inner: item.inner.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUserEmail {
    pub inner: UserEmail,
    pub login_provider: NestedLoginProvider,
}

impl NestedUserEmail {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: UserEmail,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            login_provider: NestedLoginProvider::get(flat_struct.login_provider_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedUserEmail {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        UserEmail::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedUserEmail {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       UserEmail::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedUserEmail> for NestedUserEmail {
    fn from(item: web_common::database::nested_models::NestedUserEmail) -> Self {
        Self {
            inner: item.inner.into(),
            login_provider: item.login_provider.into(),
        }
    }
}
impl From<NestedUserEmail> for web_common::database::nested_models::NestedUserEmail {
    fn from(item: NestedUserEmail) -> Self {
        Self {
            inner: item.inner.into(),
            login_provider: item.login_provider.into(),
        }
    }
}
