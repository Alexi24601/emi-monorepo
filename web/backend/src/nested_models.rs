//! This module contains the nested structs for the database tables.
//!
//! This file is automatically generated. Do not write anything here.

use serde::Deserialize;
use serde::Serialize;
use diesel::r2d2::ConnectionManager;
use diesel::r2d2::PooledConnection;
use uuid::Uuid;
use crate::models::*;
use crate::views::views::*;
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedBioOttRank {
    pub inner: BioOttRank,
    pub font_awesome_icon: FontAwesomeIcon,
}

impl NestedBioOttRank {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: BioOttRank,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedBioOttRank {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        BioOttRank::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttRank {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       BioOttRank::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedBioOttRank {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        BioOttRank::from_name(name, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedBioOttRank {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttRank::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttRank {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttRank::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttRank {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttRank::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedBioOttRank> for NestedBioOttRank {
    fn from(item: web_common::database::nested_models::NestedBioOttRank) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
        }
    }
}
impl From<NestedBioOttRank> for web_common::database::nested_models::NestedBioOttRank {
    fn from(item: NestedBioOttRank) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedBioOttTaxonItem {
    pub inner: BioOttTaxonItem,
    pub ott_rank: NestedBioOttRank,
    pub domain: Option<BioOttTaxonItem>,
    pub kingdom: Option<BioOttTaxonItem>,
    pub phylum: Option<BioOttTaxonItem>,
    pub class: Option<BioOttTaxonItem>,
    pub order: Option<BioOttTaxonItem>,
    pub family: Option<BioOttTaxonItem>,
    pub genus: Option<BioOttTaxonItem>,
    pub parent: BioOttTaxonItem,
    pub font_awesome_icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: BioOttTaxonItem,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            ott_rank: NestedBioOttRank::get(flat_struct.ott_rank_id, connection)?,
            domain: flat_struct.domain_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            kingdom: flat_struct.kingdom_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            phylum: flat_struct.phylum_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            class: flat_struct.class_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            order: flat_struct.order_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            family: flat_struct.family_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            genus: flat_struct.genus_id.map(|flat_struct| BioOttTaxonItem::get(flat_struct, connection)).transpose()?,
            parent: BioOttTaxonItem::get(flat_struct.parent_id, connection)?,
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection)?,
            color: Color::get(flat_struct.color_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedBioOttTaxonItem {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        BioOttTaxonItem::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttTaxonItem {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       BioOttTaxonItem::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedBioOttTaxonItem {
    /// Get the nested struct from the provided ott_id.
    ///
    /// # Arguments
    /// * `ott_id` - The ott_id of the row.
    /// * `connection` - The database connection.
    pub fn from_ott_id(
        ott_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        BioOttTaxonItem::from_ott_id(ott_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedBioOttTaxonItem {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttTaxonItem::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttTaxonItem {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttTaxonItem::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedBioOttTaxonItem {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttTaxonItem::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedBioOttTaxonItem> for NestedBioOttTaxonItem {
    fn from(item: web_common::database::nested_models::NestedBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            ott_rank: item.ott_rank.into(),
            domain: item.domain.map(|item| item.into()),
            kingdom: item.kingdom.map(|item| item.into()),
            phylum: item.phylum.map(|item| item.into()),
            class: item.class.map(|item| item.into()),
            order: item.order.map(|item| item.into()),
            family: item.family.map(|item| item.into()),
            genus: item.genus.map(|item| item.into()),
            parent: item.parent.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedBioOttTaxonItem> for web_common::database::nested_models::NestedBioOttTaxonItem {
    fn from(item: NestedBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            ott_rank: item.ott_rank.into(),
            domain: item.domain.map(|item| item.into()),
            kingdom: item.kingdom.map(|item| item.into()),
            phylum: item.phylum.map(|item| item.into()),
            class: item.class.map(|item| item.into()),
            order: item.order.map(|item| item.into()),
            family: item.family.map(|item| item.into()),
            genus: item.genus.map(|item| item.into()),
            parent: item.parent.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedDerivedSample {
    pub inner: DerivedSample,
    pub created_by: User,
    pub updated_by: User,
    pub parent_sample: NestedSample,
    pub child_sample: NestedSample,
}

impl NestedDerivedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: DerivedSample,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection)?,
            updated_by: User::get(flat_struct.updated_by, connection)?,
            parent_sample: NestedSample::get(flat_struct.parent_sample_id, connection)?,
            child_sample: NestedSample::get(flat_struct.child_sample_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedDerivedSample {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        DerivedSample::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedDerivedSample {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        DerivedSample::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedDerivedSample {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( parent_sample_id, child_sample_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( parent_sample_id, child_sample_id ): ( Uuid, Uuid ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       DerivedSample::get(( parent_sample_id, child_sample_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedDerivedSample> for NestedDerivedSample {
    fn from(item: web_common::database::nested_models::NestedDerivedSample) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
            parent_sample: item.parent_sample.into(),
            child_sample: item.child_sample.into(),
        }
    }
}
impl From<NestedDerivedSample> for web_common::database::nested_models::NestedDerivedSample {
    fn from(item: NestedDerivedSample) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
            parent_sample: item.parent_sample.into(),
            child_sample: item.child_sample.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedLoginProvider {
    pub inner: LoginProvider,
    pub font_awesome_icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedLoginProvider {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: LoginProvider,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection)?,
            color: Color::get(flat_struct.color_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedLoginProvider {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        LoginProvider::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedLoginProvider {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       LoginProvider::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedLoginProvider {
    /// Get the nested struct from the provided color_id.
    ///
    /// # Arguments
    /// * `color_id` - The color_id of the row.
    /// * `connection` - The database connection.
    pub fn from_color_id(
        color_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        LoginProvider::from_color_id(color_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedLoginProvider {
    /// Get the nested struct from the provided font_awesome_icon_id.
    ///
    /// # Arguments
    /// * `font_awesome_icon_id` - The font_awesome_icon_id of the row.
    /// * `connection` - The database connection.
    pub fn from_font_awesome_icon_id(
        font_awesome_icon_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        LoginProvider::from_font_awesome_icon_id(font_awesome_icon_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedLoginProvider {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        LoginProvider::from_name(name, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedLoginProvider> for NestedLoginProvider {
    fn from(item: web_common::database::nested_models::NestedLoginProvider) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedLoginProvider> for web_common::database::nested_models::NestedLoginProvider {
    fn from(item: NestedLoginProvider) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedNotification {
    pub inner: Notification,
    pub user: User,
}

impl NestedNotification {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: Notification,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            user: User::get(flat_struct.user_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedNotification {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Notification::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedNotification {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Notification::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedNotification> for NestedNotification {
    fn from(item: web_common::database::nested_models::NestedNotification) -> Self {
        Self {
            inner: item.inner.into(),
            user: item.user.into(),
        }
    }
}
impl From<NestedNotification> for web_common::database::nested_models::NestedNotification {
    fn from(item: NestedNotification) -> Self {
        Self {
            inner: item.inner.into(),
            user: item.user.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedOrganization {
    pub inner: Organization,
    pub country: Country,
}

impl NestedOrganization {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: Organization,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            country: Country::get(flat_struct.country_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedOrganization {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Organization::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedOrganization {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Organization::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedOrganization {
    /// Get the nested struct from the provided domain.
    ///
    /// # Arguments
    /// * `domain` - The domain of the row.
    /// * `connection` - The database connection.
    pub fn from_domain(
        domain: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Organization::from_domain(domain, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedOrganization {
    /// Get the nested struct from the provided name, country_id and state_province.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `country_id` - The country_id of the row.
    /// * `state_province` - The state_province of the row.
    /// * `connection` - The database connection.
    pub fn from_name_and_country_id_and_state_province(
        name: &str,
        country_id: &i32,
        state_province: Option<&str>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Organization::from_name_and_country_id_and_state_province(name, country_id, state_province, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedOrganization {
    /// Get the nested struct from the provided url.
    ///
    /// # Arguments
    /// * `url` - The url of the row.
    /// * `connection` - The database connection.
    pub fn from_url(
        url: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Organization::from_url(url, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedOrganization {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Organization::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedOrganization {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Organization::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedOrganization {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Organization::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedOrganization> for NestedOrganization {
    fn from(item: web_common::database::nested_models::NestedOrganization) -> Self {
        Self {
            inner: item.inner.into(),
            country: item.country.into(),
        }
    }
}
impl From<NestedOrganization> for web_common::database::nested_models::NestedOrganization {
    fn from(item: NestedOrganization) -> Self {
        Self {
            inner: item.inner.into(),
            country: item.country.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectState {
    pub inner: ProjectState,
    pub font_awesome_icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedProjectState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: ProjectState,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection)?,
            color: Color::get(flat_struct.color_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedProjectState {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectState::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectState {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectState::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedProjectState {
    /// Get the nested struct from the provided color_id.
    ///
    /// # Arguments
    /// * `color_id` - The color_id of the row.
    /// * `connection` - The database connection.
    pub fn from_color_id(
        color_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        ProjectState::from_color_id(color_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedProjectState {
    /// Get the nested struct from the provided font_awesome_icon_id.
    ///
    /// # Arguments
    /// * `font_awesome_icon_id` - The font_awesome_icon_id of the row.
    /// * `connection` - The database connection.
    pub fn from_font_awesome_icon_id(
        font_awesome_icon_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        ProjectState::from_font_awesome_icon_id(font_awesome_icon_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedProjectState {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        ProjectState::from_name(name, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedProjectState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       ProjectState::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       ProjectState::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       ProjectState::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedProjectState> for NestedProjectState {
    fn from(item: web_common::database::nested_models::NestedProjectState) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedProjectState> for web_common::database::nested_models::NestedProjectState {
    fn from(item: NestedProjectState) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProject {
    pub inner: Project,
    pub state: NestedProjectState,
    pub parent_project: Option<Project>,
    pub created_by: User,
    pub updated_by: User,
}

impl NestedProject {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: Project,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            state: NestedProjectState::get(flat_struct.state_id, connection)?,
            parent_project: flat_struct.parent_project_id.map(|flat_struct| Project::get(flat_struct, connection)).transpose()?,
            created_by: User::get(flat_struct.created_by, connection)?,
            updated_by: User::get(flat_struct.updated_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedProject {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Project::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProject {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Project::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProject {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Project::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedProject {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Project::from_name(name, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedProject> for NestedProject {
    fn from(item: web_common::database::nested_models::NestedProject) -> Self {
        Self {
            inner: item.inner.into(),
            state: item.state.into(),
            parent_project: item.parent_project.map(|item| item.into()),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
impl From<NestedProject> for web_common::database::nested_models::NestedProject {
    fn from(item: NestedProject) -> Self {
        Self {
            inner: item.inner.into(),
            state: item.state.into(),
            parent_project: item.parent_project.map(|item| item.into()),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsTeamsRoleInvitation {
    pub inner: ProjectsTeamsRoleInvitation,
    pub table: NestedProject,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: ProjectsTeamsRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedProjectsTeamsRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsTeamsRoleInvitation::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectsTeamsRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsTeamsRoleInvitation::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsTeamsRoleInvitation> for NestedProjectsTeamsRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedProjectsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsTeamsRoleInvitation> for web_common::database::nested_models::NestedProjectsTeamsRoleInvitation {
    fn from(item: NestedProjectsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsTeamsRoleRequest {
    pub inner: ProjectsTeamsRoleRequest,
    pub table: NestedProject,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: ProjectsTeamsRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedProjectsTeamsRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsTeamsRoleRequest::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectsTeamsRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsTeamsRoleRequest::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsTeamsRoleRequest> for NestedProjectsTeamsRoleRequest {
    fn from(item: web_common::database::nested_models::NestedProjectsTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsTeamsRoleRequest> for web_common::database::nested_models::NestedProjectsTeamsRoleRequest {
    fn from(item: NestedProjectsTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsTeamsRole {
    pub inner: ProjectsTeamsRole,
    pub table: NestedProject,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: ProjectsTeamsRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedProjectsTeamsRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsTeamsRole::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectsTeamsRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsTeamsRole::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsTeamsRole> for NestedProjectsTeamsRole {
    fn from(item: web_common::database::nested_models::NestedProjectsTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsTeamsRole> for web_common::database::nested_models::NestedProjectsTeamsRole {
    fn from(item: NestedProjectsTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsUsersRoleInvitation {
    pub inner: ProjectsUsersRoleInvitation,
    pub table: NestedProject,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: ProjectsUsersRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedProjectsUsersRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsUsersRoleInvitation::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectsUsersRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsUsersRoleInvitation::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsUsersRoleInvitation> for NestedProjectsUsersRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedProjectsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsUsersRoleInvitation> for web_common::database::nested_models::NestedProjectsUsersRoleInvitation {
    fn from(item: NestedProjectsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsUsersRoleRequest {
    pub inner: ProjectsUsersRoleRequest,
    pub table: NestedProject,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: ProjectsUsersRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedProjectsUsersRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsUsersRoleRequest::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectsUsersRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsUsersRoleRequest::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsUsersRoleRequest> for NestedProjectsUsersRoleRequest {
    fn from(item: web_common::database::nested_models::NestedProjectsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsUsersRoleRequest> for web_common::database::nested_models::NestedProjectsUsersRoleRequest {
    fn from(item: NestedProjectsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsUsersRole {
    pub inner: ProjectsUsersRole,
    pub table: NestedProject,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: ProjectsUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedProjectsUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsUsersRole::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedProjectsUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsUsersRole::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsUsersRole> for NestedProjectsUsersRole {
    fn from(item: web_common::database::nested_models::NestedProjectsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsUsersRole> for web_common::database::nested_models::NestedProjectsUsersRole {
    fn from(item: NestedProjectsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedRole {
    pub inner: Role,
    pub font_awesome_icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: Role,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection)?,
            color: Color::get(flat_struct.color_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Role::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Role::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedRole {
    /// Get the nested struct from the provided color_id.
    ///
    /// # Arguments
    /// * `color_id` - The color_id of the row.
    /// * `connection` - The database connection.
    pub fn from_color_id(
        color_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Role::from_color_id(color_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedRole {
    /// Get the nested struct from the provided description.
    ///
    /// # Arguments
    /// * `description` - The description of the row.
    /// * `connection` - The database connection.
    pub fn from_description(
        description: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Role::from_description(description, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedRole {
    /// Get the nested struct from the provided font_awesome_icon_id.
    ///
    /// # Arguments
    /// * `font_awesome_icon_id` - The font_awesome_icon_id of the row.
    /// * `connection` - The database connection.
    pub fn from_font_awesome_icon_id(
        font_awesome_icon_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Role::from_font_awesome_icon_id(font_awesome_icon_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedRole {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Role::from_name(name, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedRole {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Role::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedRole {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Role::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedRole {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Role::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedRole> for NestedRole {
    fn from(item: web_common::database::nested_models::NestedRole) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedRole> for web_common::database::nested_models::NestedRole {
    fn from(item: NestedRole) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampleBioOttTaxonItem {
    pub inner: SampleBioOttTaxonItem,
    pub created_by: User,
    pub updated_by: User,
    pub sample: NestedSample,
    pub taxon: NestedBioOttTaxonItem,
}

impl NestedSampleBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SampleBioOttTaxonItem,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection)?,
            updated_by: User::get(flat_struct.updated_by, connection)?,
            sample: NestedSample::get(flat_struct.sample_id, connection)?,
            taxon: NestedBioOttTaxonItem::get(flat_struct.taxon_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSampleBioOttTaxonItem {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampleBioOttTaxonItem::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampleBioOttTaxonItem {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampleBioOttTaxonItem::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampleBioOttTaxonItem {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( sample_id, taxon_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( sample_id, taxon_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampleBioOttTaxonItem::get(( sample_id, taxon_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSampleBioOttTaxonItem> for NestedSampleBioOttTaxonItem {
    fn from(item: web_common::database::nested_models::NestedSampleBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
            sample: item.sample.into(),
            taxon: item.taxon.into(),
        }
    }
}
impl From<NestedSampleBioOttTaxonItem> for web_common::database::nested_models::NestedSampleBioOttTaxonItem {
    fn from(item: NestedSampleBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
            sample: item.sample.into(),
            taxon: item.taxon.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampleState {
    pub inner: SampleState,
    pub font_awesome_icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedSampleState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SampleState,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection)?,
            color: Color::get(flat_struct.color_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSampleState {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampleState::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampleState {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampleState::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedSampleState {
    /// Get the nested struct from the provided color_id.
    ///
    /// # Arguments
    /// * `color_id` - The color_id of the row.
    /// * `connection` - The database connection.
    pub fn from_color_id(
        color_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        SampleState::from_color_id(color_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedSampleState {
    /// Get the nested struct from the provided font_awesome_icon_id.
    ///
    /// # Arguments
    /// * `font_awesome_icon_id` - The font_awesome_icon_id of the row.
    /// * `connection` - The database connection.
    pub fn from_font_awesome_icon_id(
        font_awesome_icon_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        SampleState::from_font_awesome_icon_id(font_awesome_icon_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedSampleState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleState::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampleState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleState::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampleState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleState::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedSampleState> for NestedSampleState {
    fn from(item: web_common::database::nested_models::NestedSampleState) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedSampleState> for web_common::database::nested_models::NestedSampleState {
    fn from(item: NestedSampleState) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualBioOttTaxonItem {
    pub inner: SampledIndividualBioOttTaxonItem,
    pub created_by: User,
    pub updated_by: User,
    pub sampled_individual: NestedSampledIndividual,
    pub taxon: NestedBioOttTaxonItem,
}

impl NestedSampledIndividualBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SampledIndividualBioOttTaxonItem,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection)?,
            updated_by: User::get(flat_struct.updated_by, connection)?,
            sampled_individual: NestedSampledIndividual::get(flat_struct.sampled_individual_id, connection)?,
            taxon: NestedBioOttTaxonItem::get(flat_struct.taxon_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSampledIndividualBioOttTaxonItem {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividualBioOttTaxonItem::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampledIndividualBioOttTaxonItem {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividualBioOttTaxonItem::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampledIndividualBioOttTaxonItem {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( sampled_individual_id, taxon_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( sampled_individual_id, taxon_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampledIndividualBioOttTaxonItem::get(( sampled_individual_id, taxon_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSampledIndividualBioOttTaxonItem> for NestedSampledIndividualBioOttTaxonItem {
    fn from(item: web_common::database::nested_models::NestedSampledIndividualBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
            sampled_individual: item.sampled_individual.into(),
            taxon: item.taxon.into(),
        }
    }
}
impl From<NestedSampledIndividualBioOttTaxonItem> for web_common::database::nested_models::NestedSampledIndividualBioOttTaxonItem {
    fn from(item: NestedSampledIndividualBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
            sampled_individual: item.sampled_individual.into(),
            taxon: item.taxon.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividual {
    pub inner: SampledIndividual,
    pub created_by: User,
    pub updated_by: User,
}

impl NestedSampledIndividual {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SampledIndividual,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection)?,
            updated_by: User::get(flat_struct.updated_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSampledIndividual {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividual::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampledIndividual {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividual::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampledIndividual {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampledIndividual::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSampledIndividual> for NestedSampledIndividual {
    fn from(item: web_common::database::nested_models::NestedSampledIndividual) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
impl From<NestedSampledIndividual> for web_common::database::nested_models::NestedSampledIndividual {
    fn from(item: NestedSampledIndividual) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsTeamsRoleInvitation {
    pub inner: SampledIndividualsTeamsRoleInvitation,
    pub table: NestedSampledIndividual,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSampledIndividualsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SampledIndividualsTeamsRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSampledIndividualsTeamsRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividualsTeamsRoleInvitation::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampledIndividualsTeamsRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampledIndividualsTeamsRoleInvitation::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSampledIndividualsTeamsRoleInvitation> for NestedSampledIndividualsTeamsRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedSampledIndividualsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSampledIndividualsTeamsRoleInvitation> for web_common::database::nested_models::NestedSampledIndividualsTeamsRoleInvitation {
    fn from(item: NestedSampledIndividualsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsTeamsRoleRequest {
    pub inner: SampledIndividualsTeamsRoleRequest,
    pub table: NestedSampledIndividual,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSampledIndividualsTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SampledIndividualsTeamsRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSampledIndividualsTeamsRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividualsTeamsRoleRequest::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampledIndividualsTeamsRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampledIndividualsTeamsRoleRequest::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSampledIndividualsTeamsRoleRequest> for NestedSampledIndividualsTeamsRoleRequest {
    fn from(item: web_common::database::nested_models::NestedSampledIndividualsTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSampledIndividualsTeamsRoleRequest> for web_common::database::nested_models::NestedSampledIndividualsTeamsRoleRequest {
    fn from(item: NestedSampledIndividualsTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsTeamsRole {
    pub inner: SampledIndividualsTeamsRole,
    pub table: NestedSampledIndividual,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSampledIndividualsTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SampledIndividualsTeamsRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSampledIndividualsTeamsRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividualsTeamsRole::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampledIndividualsTeamsRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampledIndividualsTeamsRole::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSampledIndividualsTeamsRole> for NestedSampledIndividualsTeamsRole {
    fn from(item: web_common::database::nested_models::NestedSampledIndividualsTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSampledIndividualsTeamsRole> for web_common::database::nested_models::NestedSampledIndividualsTeamsRole {
    fn from(item: NestedSampledIndividualsTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsUsersRoleInvitation {
    pub inner: SampledIndividualsUsersRoleInvitation,
    pub table: NestedSampledIndividual,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSampledIndividualsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SampledIndividualsUsersRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSampledIndividualsUsersRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividualsUsersRoleInvitation::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampledIndividualsUsersRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampledIndividualsUsersRoleInvitation::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSampledIndividualsUsersRoleInvitation> for NestedSampledIndividualsUsersRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedSampledIndividualsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSampledIndividualsUsersRoleInvitation> for web_common::database::nested_models::NestedSampledIndividualsUsersRoleInvitation {
    fn from(item: NestedSampledIndividualsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsUsersRoleRequest {
    pub inner: SampledIndividualsUsersRoleRequest,
    pub table: NestedSampledIndividual,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSampledIndividualsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SampledIndividualsUsersRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSampledIndividualsUsersRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividualsUsersRoleRequest::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampledIndividualsUsersRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampledIndividualsUsersRoleRequest::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSampledIndividualsUsersRoleRequest> for NestedSampledIndividualsUsersRoleRequest {
    fn from(item: web_common::database::nested_models::NestedSampledIndividualsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSampledIndividualsUsersRoleRequest> for web_common::database::nested_models::NestedSampledIndividualsUsersRoleRequest {
    fn from(item: NestedSampledIndividualsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsUsersRole {
    pub inner: SampledIndividualsUsersRole,
    pub table: NestedSampledIndividual,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSampledIndividualsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SampledIndividualsUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSampledIndividualsUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividualsUsersRole::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSampledIndividualsUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampledIndividualsUsersRole::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSampledIndividualsUsersRole> for NestedSampledIndividualsUsersRole {
    fn from(item: web_common::database::nested_models::NestedSampledIndividualsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSampledIndividualsUsersRole> for web_common::database::nested_models::NestedSampledIndividualsUsersRole {
    fn from(item: NestedSampledIndividualsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSample {
    pub inner: Sample,
    pub created_by: User,
    pub sampled_by: User,
    pub updated_by: User,
    pub state: NestedSampleState,
}

impl NestedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: Sample,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection)?,
            sampled_by: User::get(flat_struct.sampled_by, connection)?,
            updated_by: User::get(flat_struct.updated_by, connection)?,
            state: NestedSampleState::get(flat_struct.state, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSample {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Sample::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSample {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Sample::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSample {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Sample::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSample> for NestedSample {
    fn from(item: web_common::database::nested_models::NestedSample) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            sampled_by: item.sampled_by.into(),
            updated_by: item.updated_by.into(),
            state: item.state.into(),
        }
    }
}
impl From<NestedSample> for web_common::database::nested_models::NestedSample {
    fn from(item: NestedSample) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            sampled_by: item.sampled_by.into(),
            updated_by: item.updated_by.into(),
            state: item.state.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesTeamsRoleInvitation {
    pub inner: SamplesTeamsRoleInvitation,
    pub table: NestedSample,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SamplesTeamsRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSamplesTeamsRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesTeamsRoleInvitation::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSamplesTeamsRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesTeamsRoleInvitation::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesTeamsRoleInvitation> for NestedSamplesTeamsRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedSamplesTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesTeamsRoleInvitation> for web_common::database::nested_models::NestedSamplesTeamsRoleInvitation {
    fn from(item: NestedSamplesTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesTeamsRoleRequest {
    pub inner: SamplesTeamsRoleRequest,
    pub table: NestedSample,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SamplesTeamsRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSamplesTeamsRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesTeamsRoleRequest::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSamplesTeamsRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesTeamsRoleRequest::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesTeamsRoleRequest> for NestedSamplesTeamsRoleRequest {
    fn from(item: web_common::database::nested_models::NestedSamplesTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesTeamsRoleRequest> for web_common::database::nested_models::NestedSamplesTeamsRoleRequest {
    fn from(item: NestedSamplesTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesTeamsRole {
    pub inner: SamplesTeamsRole,
    pub table: NestedSample,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SamplesTeamsRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSamplesTeamsRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesTeamsRole::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSamplesTeamsRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesTeamsRole::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesTeamsRole> for NestedSamplesTeamsRole {
    fn from(item: web_common::database::nested_models::NestedSamplesTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesTeamsRole> for web_common::database::nested_models::NestedSamplesTeamsRole {
    fn from(item: NestedSamplesTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesUsersRoleInvitation {
    pub inner: SamplesUsersRoleInvitation,
    pub table: NestedSample,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SamplesUsersRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSamplesUsersRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesUsersRoleInvitation::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSamplesUsersRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesUsersRoleInvitation::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesUsersRoleInvitation> for NestedSamplesUsersRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedSamplesUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesUsersRoleInvitation> for web_common::database::nested_models::NestedSamplesUsersRoleInvitation {
    fn from(item: NestedSamplesUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesUsersRoleRequest {
    pub inner: SamplesUsersRoleRequest,
    pub table: NestedSample,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SamplesUsersRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSamplesUsersRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesUsersRoleRequest::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSamplesUsersRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesUsersRoleRequest::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesUsersRoleRequest> for NestedSamplesUsersRoleRequest {
    fn from(item: web_common::database::nested_models::NestedSamplesUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesUsersRoleRequest> for web_common::database::nested_models::NestedSamplesUsersRoleRequest {
    fn from(item: NestedSamplesUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesUsersRole {
    pub inner: SamplesUsersRole,
    pub table: NestedSample,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SamplesUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSamplesUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesUsersRole::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSamplesUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesUsersRole::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesUsersRole> for NestedSamplesUsersRole {
    fn from(item: web_common::database::nested_models::NestedSamplesUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesUsersRole> for web_common::database::nested_models::NestedSamplesUsersRole {
    fn from(item: NestedSamplesUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectra {
    pub inner: Spectra,
    pub spectra_collection: NestedSpectraCollection,
}

impl NestedSpectra {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: Spectra,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            spectra_collection: NestedSpectraCollection::get(flat_struct.spectra_collection_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSpectra {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Spectra::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSpectra {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Spectra::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectra> for NestedSpectra {
    fn from(item: web_common::database::nested_models::NestedSpectra) -> Self {
        Self {
            inner: item.inner.into(),
            spectra_collection: item.spectra_collection.into(),
        }
    }
}
impl From<NestedSpectra> for web_common::database::nested_models::NestedSpectra {
    fn from(item: NestedSpectra) -> Self {
        Self {
            inner: item.inner.into(),
            spectra_collection: item.spectra_collection.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollection {
    pub inner: SpectraCollection,
    pub sample: NestedSample,
    pub created_by: User,
    pub updated_by: User,
}

impl NestedSpectraCollection {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SpectraCollection,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            sample: NestedSample::get(flat_struct.sample_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
            updated_by: User::get(flat_struct.updated_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSpectraCollection {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollection::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSpectraCollection {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollection::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSpectraCollection {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollection::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollection> for NestedSpectraCollection {
    fn from(item: web_common::database::nested_models::NestedSpectraCollection) -> Self {
        Self {
            inner: item.inner.into(),
            sample: item.sample.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
impl From<NestedSpectraCollection> for web_common::database::nested_models::NestedSpectraCollection {
    fn from(item: NestedSpectraCollection) -> Self {
        Self {
            inner: item.inner.into(),
            sample: item.sample.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsTeamsRoleInvitation {
    pub inner: SpectraCollectionsTeamsRoleInvitation,
    pub table: NestedSpectraCollection,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SpectraCollectionsTeamsRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSpectraCollectionsTeamsRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsTeamsRoleInvitation::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSpectraCollectionsTeamsRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsTeamsRoleInvitation::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleInvitation> for NestedSpectraCollectionsTeamsRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsTeamsRoleInvitation> for web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleInvitation {
    fn from(item: NestedSpectraCollectionsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsTeamsRoleRequest {
    pub inner: SpectraCollectionsTeamsRoleRequest,
    pub table: NestedSpectraCollection,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SpectraCollectionsTeamsRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSpectraCollectionsTeamsRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsTeamsRoleRequest::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSpectraCollectionsTeamsRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsTeamsRoleRequest::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleRequest> for NestedSpectraCollectionsTeamsRoleRequest {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsTeamsRoleRequest> for web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleRequest {
    fn from(item: NestedSpectraCollectionsTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsTeamsRole {
    pub inner: SpectraCollectionsTeamsRole,
    pub table: NestedSpectraCollection,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SpectraCollectionsTeamsRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSpectraCollectionsTeamsRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsTeamsRole::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSpectraCollectionsTeamsRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsTeamsRole::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsTeamsRole> for NestedSpectraCollectionsTeamsRole {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsTeamsRole> for web_common::database::nested_models::NestedSpectraCollectionsTeamsRole {
    fn from(item: NestedSpectraCollectionsTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsUsersRoleInvitation {
    pub inner: SpectraCollectionsUsersRoleInvitation,
    pub table: NestedSpectraCollection,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SpectraCollectionsUsersRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSpectraCollectionsUsersRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsUsersRoleInvitation::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSpectraCollectionsUsersRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsUsersRoleInvitation::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsUsersRoleInvitation> for NestedSpectraCollectionsUsersRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsUsersRoleInvitation> for web_common::database::nested_models::NestedSpectraCollectionsUsersRoleInvitation {
    fn from(item: NestedSpectraCollectionsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsUsersRoleRequest {
    pub inner: SpectraCollectionsUsersRoleRequest,
    pub table: NestedSpectraCollection,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SpectraCollectionsUsersRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSpectraCollectionsUsersRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsUsersRoleRequest::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSpectraCollectionsUsersRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsUsersRoleRequest::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsUsersRoleRequest> for NestedSpectraCollectionsUsersRoleRequest {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsUsersRoleRequest> for web_common::database::nested_models::NestedSpectraCollectionsUsersRoleRequest {
    fn from(item: NestedSpectraCollectionsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsUsersRole {
    pub inner: SpectraCollectionsUsersRole,
    pub table: NestedSpectraCollection,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: SpectraCollectionsUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedSpectraCollectionsUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsUsersRole::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedSpectraCollectionsUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsUsersRole::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsUsersRole> for NestedSpectraCollectionsUsersRole {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsUsersRole> for web_common::database::nested_models::NestedSpectraCollectionsUsersRole {
    fn from(item: NestedSpectraCollectionsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamState {
    pub inner: TeamState,
    pub font_awesome_icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedTeamState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: TeamState,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection)?,
            color: Color::get(flat_struct.color_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedTeamState {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        TeamState::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedTeamState {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       TeamState::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedTeamState {
    /// Get the nested struct from the provided color_id.
    ///
    /// # Arguments
    /// * `color_id` - The color_id of the row.
    /// * `connection` - The database connection.
    pub fn from_color_id(
        color_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        TeamState::from_color_id(color_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedTeamState {
    /// Get the nested struct from the provided font_awesome_icon_id.
    ///
    /// # Arguments
    /// * `font_awesome_icon_id` - The font_awesome_icon_id of the row.
    /// * `connection` - The database connection.
    pub fn from_font_awesome_icon_id(
        font_awesome_icon_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        TeamState::from_font_awesome_icon_id(font_awesome_icon_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedTeamState {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        TeamState::from_name(name, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedTeamState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       TeamState::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedTeamState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       TeamState::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedTeamState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       TeamState::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedTeamState> for NestedTeamState {
    fn from(item: web_common::database::nested_models::NestedTeamState) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedTeamState> for web_common::database::nested_models::NestedTeamState {
    fn from(item: NestedTeamState) -> Self {
        Self {
            inner: item.inner.into(),
            font_awesome_icon: item.font_awesome_icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeam {
    pub inner: Team,
    pub parent_team: Option<Team>,
    pub created_by: User,
    pub updated_by: User,
}

impl NestedTeam {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: Team,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            parent_team: flat_struct.parent_team_id.map(|flat_struct| Team::get(flat_struct, connection)).transpose()?,
            created_by: User::get(flat_struct.created_by, connection)?,
            updated_by: User::get(flat_struct.updated_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedTeam {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Team::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedTeam {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Team::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedTeam {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Team::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedTeam {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Team::from_name(name, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedTeam {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Team::similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedTeam {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Team::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedTeam {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Team::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedTeam> for NestedTeam {
    fn from(item: web_common::database::nested_models::NestedTeam) -> Self {
        Self {
            inner: item.inner.into(),
            parent_team: item.parent_team.map(|item| item.into()),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
impl From<NestedTeam> for web_common::database::nested_models::NestedTeam {
    fn from(item: NestedTeam) -> Self {
        Self {
            inner: item.inner.into(),
            parent_team: item.parent_team.map(|item| item.into()),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsTeamsRoleInvitation {
    pub inner: TeamsTeamsRoleInvitation,
    pub table: NestedTeam,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedTeamsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: TeamsTeamsRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_struct.table_id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedTeamsTeamsRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        TeamsTeamsRoleInvitation::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedTeamsTeamsRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       TeamsTeamsRoleInvitation::get(( table_id, team_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedTeamsTeamsRoleInvitation> for NestedTeamsTeamsRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedTeamsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedTeamsTeamsRoleInvitation> for web_common::database::nested_models::NestedTeamsTeamsRoleInvitation {
    fn from(item: NestedTeamsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsUsersRoleInvitation {
    pub inner: TeamsUsersRoleInvitation,
    pub table: NestedTeam,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedTeamsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: TeamsUsersRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedTeamsUsersRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        TeamsUsersRoleInvitation::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedTeamsUsersRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       TeamsUsersRoleInvitation::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedTeamsUsersRoleInvitation> for NestedTeamsUsersRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedTeamsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedTeamsUsersRoleInvitation> for web_common::database::nested_models::NestedTeamsUsersRoleInvitation {
    fn from(item: NestedTeamsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsUsersRoleRequest {
    pub inner: TeamsUsersRoleRequest,
    pub table: NestedTeam,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedTeamsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: TeamsUsersRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedTeamsUsersRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        TeamsUsersRoleRequest::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedTeamsUsersRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       TeamsUsersRoleRequest::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedTeamsUsersRoleRequest> for NestedTeamsUsersRoleRequest {
    fn from(item: web_common::database::nested_models::NestedTeamsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedTeamsUsersRoleRequest> for web_common::database::nested_models::NestedTeamsUsersRoleRequest {
    fn from(item: NestedTeamsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsUsersRole {
    pub inner: TeamsUsersRole,
    pub table: NestedTeam,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedTeamsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: TeamsUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedTeamsUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        TeamsUsersRole::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedTeamsUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       TeamsUsersRole::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedTeamsUsersRole> for NestedTeamsUsersRole {
    fn from(item: web_common::database::nested_models::NestedTeamsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedTeamsUsersRole> for web_common::database::nested_models::NestedTeamsUsersRole {
    fn from(item: NestedTeamsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUserEmail {
    pub inner: UserEmail,
    pub created_by: User,
    pub login_provider: NestedLoginProvider,
}

impl NestedUserEmail {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: UserEmail,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection)?,
            login_provider: NestedLoginProvider::get(flat_struct.login_provider_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedUserEmail {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        UserEmail::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedUserEmail {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       UserEmail::get(id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl NestedUserEmail {
    /// Get the nested struct from the provided email and login_provider_id.
    ///
    /// # Arguments
    /// * `email` - The email of the row.
    /// * `login_provider_id` - The login_provider_id of the row.
    /// * `connection` - The database connection.
    pub fn from_email_and_login_provider_id(
        email: &str,
        login_provider_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        UserEmail::from_email_and_login_provider_id(email, login_provider_id, connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedUserEmail> for NestedUserEmail {
    fn from(item: web_common::database::nested_models::NestedUserEmail) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            login_provider: item.login_provider.into(),
        }
    }
}
impl From<NestedUserEmail> for web_common::database::nested_models::NestedUserEmail {
    fn from(item: NestedUserEmail) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            login_provider: item.login_provider.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUsersUsersRoleInvitation {
    pub inner: UsersUsersRoleInvitation,
    pub table: User,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedUsersUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: UsersUsersRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: User::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedUsersUsersRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        UsersUsersRoleInvitation::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedUsersUsersRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       UsersUsersRoleInvitation::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedUsersUsersRoleInvitation> for NestedUsersUsersRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedUsersUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedUsersUsersRoleInvitation> for web_common::database::nested_models::NestedUsersUsersRoleInvitation {
    fn from(item: NestedUsersUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUsersUsersRoleRequest {
    pub inner: UsersUsersRoleRequest,
    pub created_by: User,
    pub table: User,
    pub user: User,
    pub role: NestedRole,
}

impl NestedUsersUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: UsersUsersRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection)?,
            table: User::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedUsersUsersRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        UsersUsersRoleRequest::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedUsersUsersRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       UsersUsersRoleRequest::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedUsersUsersRoleRequest> for NestedUsersUsersRoleRequest {
    fn from(item: web_common::database::nested_models::NestedUsersUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
        }
    }
}
impl From<NestedUsersUsersRoleRequest> for web_common::database::nested_models::NestedUsersUsersRoleRequest {
    fn from(item: NestedUsersUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUsersUsersRole {
    pub inner: UsersUsersRole,
    pub table: User,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedUsersUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_struct: UsersUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: User::get(flat_struct.table_id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            role: NestedRole::get(flat_struct.role_id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
                inner: flat_struct,
        })
    }
}
impl NestedUsersUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        UsersUsersRole::all(limit, offset, connection)?.into_iter().map(|flat_struct| Self::from_flat(flat_struct, connection)).collect()
    }
}
impl NestedUsersUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       UsersUsersRole::get(( table_id, user_id ), connection).and_then(|flat_struct| Self::from_flat(flat_struct, connection))
    }
}
impl From<web_common::database::nested_models::NestedUsersUsersRole> for NestedUsersUsersRole {
    fn from(item: web_common::database::nested_models::NestedUsersUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedUsersUsersRole> for web_common::database::nested_models::NestedUsersUsersRole {
    fn from(item: NestedUsersUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
