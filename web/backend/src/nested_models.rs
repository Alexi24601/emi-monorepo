//! This module contains the nested structs for the database tables.
//!
//! This file is automatically generated. Do not write anything here.

use serde::Deserialize;
use serde::Serialize;
use diesel::r2d2::ConnectionManager;
use diesel::r2d2::PooledConnection;
use uuid::Uuid;
use crate::models::*;

#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedBioOttRank {
    pub inner: BioOttRank,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedBioOttRank {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: BioOttRank,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection)?,
            color: Color::get(flat_variant.color_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedBioOttRank {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::BioOttRankFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        BioOttRank::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedBioOttRank {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       BioOttRank::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedBioOttRank {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        BioOttRank::from_name(name, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedBioOttRank {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttRank::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedBioOttRank {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttRank::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedBioOttRank {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttRank::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedBioOttRank> for NestedBioOttRank {
    fn from(item: web_common::database::nested_models::NestedBioOttRank) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedBioOttRank> for web_common::database::nested_models::NestedBioOttRank {
    fn from(item: NestedBioOttRank) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedBioOttTaxonItem {
    pub inner: BioOttTaxonItem,
    pub ott_rank: NestedBioOttRank,
    pub domain: Option<BioOttTaxonItem>,
    pub kingdom: Option<BioOttTaxonItem>,
    pub phylum: Option<BioOttTaxonItem>,
    pub class: Option<BioOttTaxonItem>,
    pub order: Option<BioOttTaxonItem>,
    pub family: Option<BioOttTaxonItem>,
    pub genus: Option<BioOttTaxonItem>,
    pub parent: BioOttTaxonItem,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: BioOttTaxonItem,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            ott_rank: NestedBioOttRank::get(flat_variant.ott_rank_id, connection)?,
            domain: flat_variant.domain_id.map(|flat_variant| BioOttTaxonItem::get(flat_variant, connection)).transpose()?,
            kingdom: flat_variant.kingdom_id.map(|flat_variant| BioOttTaxonItem::get(flat_variant, connection)).transpose()?,
            phylum: flat_variant.phylum_id.map(|flat_variant| BioOttTaxonItem::get(flat_variant, connection)).transpose()?,
            class: flat_variant.class_id.map(|flat_variant| BioOttTaxonItem::get(flat_variant, connection)).transpose()?,
            order: flat_variant.order_id.map(|flat_variant| BioOttTaxonItem::get(flat_variant, connection)).transpose()?,
            family: flat_variant.family_id.map(|flat_variant| BioOttTaxonItem::get(flat_variant, connection)).transpose()?,
            genus: flat_variant.genus_id.map(|flat_variant| BioOttTaxonItem::get(flat_variant, connection)).transpose()?,
            parent: BioOttTaxonItem::get(flat_variant.parent_id, connection)?,
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection)?,
            color: Color::get(flat_variant.color_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedBioOttTaxonItem {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::BioOttTaxonItemFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        BioOttTaxonItem::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedBioOttTaxonItem {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       BioOttTaxonItem::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedBioOttTaxonItem {
    /// Get the nested struct from the provided ott_id.
    ///
    /// # Arguments
    /// * `ott_id` - The ott_id of the row.
    /// * `connection` - The database connection.
    pub fn from_ott_id(
        ott_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        BioOttTaxonItem::from_ott_id(ott_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedBioOttTaxonItem {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttTaxonItem::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedBioOttTaxonItem {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttTaxonItem::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedBioOttTaxonItem {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       BioOttTaxonItem::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedBioOttTaxonItem> for NestedBioOttTaxonItem {
    fn from(item: web_common::database::nested_models::NestedBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            ott_rank: item.ott_rank.into(),
            domain: item.domain.map(|item| item.into()),
            kingdom: item.kingdom.map(|item| item.into()),
            phylum: item.phylum.map(|item| item.into()),
            class: item.class.map(|item| item.into()),
            order: item.order.map(|item| item.into()),
            family: item.family.map(|item| item.into()),
            genus: item.genus.map(|item| item.into()),
            parent: item.parent.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedBioOttTaxonItem> for web_common::database::nested_models::NestedBioOttTaxonItem {
    fn from(item: NestedBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            ott_rank: item.ott_rank.into(),
            domain: item.domain.map(|item| item.into()),
            kingdom: item.kingdom.map(|item| item.into()),
            phylum: item.phylum.map(|item| item.into()),
            class: item.class.map(|item| item.into()),
            order: item.order.map(|item| item.into()),
            family: item.family.map(|item| item.into()),
            genus: item.genus.map(|item| item.into()),
            parent: item.parent.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedDerivedSample {
    pub inner: DerivedSample,
    pub created_by: User,
    pub parent_sample: NestedSample,
    pub child_sample: NestedSample,
}

impl NestedDerivedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: DerivedSample,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_variant.created_by, connection)?,
            parent_sample: NestedSample::get(flat_variant.parent_sample_id, connection)?,
            child_sample: NestedSample::get(flat_variant.child_sample_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedDerivedSample {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::DerivedSampleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        DerivedSample::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedDerivedSample {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( parent_sample_id, child_sample_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( parent_sample_id, child_sample_id ): ( Uuid, Uuid ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       DerivedSample::get(( parent_sample_id, child_sample_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedDerivedSample> for NestedDerivedSample {
    fn from(item: web_common::database::nested_models::NestedDerivedSample) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            parent_sample: item.parent_sample.into(),
            child_sample: item.child_sample.into(),
        }
    }
}
impl From<NestedDerivedSample> for web_common::database::nested_models::NestedDerivedSample {
    fn from(item: NestedDerivedSample) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            parent_sample: item.parent_sample.into(),
            child_sample: item.child_sample.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedDocumentFormat {
    pub inner: DocumentFormat,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedDocumentFormat {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: DocumentFormat,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection)?,
            color: Color::get(flat_variant.color_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedDocumentFormat {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::DocumentFormatFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        DocumentFormat::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedDocumentFormat {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       DocumentFormat::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedDocumentFormat {
    /// Get the nested struct from the provided extension.
    ///
    /// # Arguments
    /// * `extension` - The extension of the row.
    /// * `connection` - The database connection.
    pub fn from_extension(
        extension: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        DocumentFormat::from_extension(extension, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedDocumentFormat {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       DocumentFormat::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedDocumentFormat {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       DocumentFormat::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedDocumentFormat {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       DocumentFormat::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedDocumentFormat> for NestedDocumentFormat {
    fn from(item: web_common::database::nested_models::NestedDocumentFormat) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedDocumentFormat> for web_common::database::nested_models::NestedDocumentFormat {
    fn from(item: NestedDocumentFormat) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedLoginProvider {
    pub inner: LoginProvider,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedLoginProvider {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: LoginProvider,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection)?,
            color: Color::get(flat_variant.color_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedLoginProvider {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::LoginProviderFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        LoginProvider::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedLoginProvider {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       LoginProvider::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedLoginProvider {
    /// Get the nested struct from the provided color_id.
    ///
    /// # Arguments
    /// * `color_id` - The color_id of the row.
    /// * `connection` - The database connection.
    pub fn from_color_id(
        color_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        LoginProvider::from_color_id(color_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedLoginProvider {
    /// Get the nested struct from the provided icon_id.
    ///
    /// # Arguments
    /// * `icon_id` - The icon_id of the row.
    /// * `connection` - The database connection.
    pub fn from_icon_id(
        icon_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        LoginProvider::from_icon_id(icon_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedLoginProvider {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        LoginProvider::from_name(name, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedLoginProvider> for NestedLoginProvider {
    fn from(item: web_common::database::nested_models::NestedLoginProvider) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedLoginProvider> for web_common::database::nested_models::NestedLoginProvider {
    fn from(item: NestedLoginProvider) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedNotification {
    pub inner: Notification,
    pub user: User,
}

impl NestedNotification {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: Notification,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            user: User::get(flat_variant.user_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedNotification {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::NotificationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Notification::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedNotification {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Notification::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedNotification> for NestedNotification {
    fn from(item: web_common::database::nested_models::NestedNotification) -> Self {
        Self {
            inner: item.inner.into(),
            user: item.user.into(),
        }
    }
}
impl From<NestedNotification> for web_common::database::nested_models::NestedNotification {
    fn from(item: NestedNotification) -> Self {
        Self {
            inner: item.inner.into(),
            user: item.user.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedObservation {
    pub inner: Observation,
    pub created_by: User,
    pub updated_by: User,
    pub project: NestedProject,
    pub individual: Option<NestedSampledIndividual>,
}

impl NestedObservation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: Observation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_variant.created_by, connection)?,
            updated_by: User::get(flat_variant.updated_by, connection)?,
            project: NestedProject::get(flat_variant.project_id, connection)?,
            individual: flat_variant.individual_id.map(|flat_variant| NestedSampledIndividual::get(flat_variant, connection)).transpose()?,
                inner: flat_variant,
        })
    }
}
impl NestedObservation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::ObservationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Observation::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedObservation {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        filter: Option<&web_common::database::ObservationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Observation::all_by_updated_at(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedObservation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Observation::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedObservation {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Observation::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedObservation {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Observation::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedObservation {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Observation::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedObservation> for NestedObservation {
    fn from(item: web_common::database::nested_models::NestedObservation) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
            project: item.project.into(),
            individual: item.individual.map(|item| item.into()),
        }
    }
}
impl From<NestedObservation> for web_common::database::nested_models::NestedObservation {
    fn from(item: NestedObservation) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
            project: item.project.into(),
            individual: item.individual.map(|item| item.into()),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedOrganization {
    pub inner: Organization,
    pub country: Country,
}

impl NestedOrganization {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: Organization,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            country: Country::get(flat_variant.country_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedOrganization {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::OrganizationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Organization::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedOrganization {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Organization::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedOrganization {
    /// Get the nested struct from the provided domain.
    ///
    /// # Arguments
    /// * `domain` - The domain of the row.
    /// * `connection` - The database connection.
    pub fn from_domain(
        domain: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Organization::from_domain(domain, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedOrganization {
    /// Get the nested struct from the provided name, country_id and state_province.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `country_id` - The country_id of the row.
    /// * `state_province` - The state_province of the row.
    /// * `connection` - The database connection.
    pub fn from_name_and_country_id_and_state_province(
        name: &str,
        country_id: &i32,
        state_province: Option<&str>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Organization::from_name_and_country_id_and_state_province(name, country_id, state_province, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedOrganization {
    /// Get the nested struct from the provided url.
    ///
    /// # Arguments
    /// * `url` - The url of the row.
    /// * `connection` - The database connection.
    pub fn from_url(
        url: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Organization::from_url(url, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedOrganization {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Organization::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedOrganization {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Organization::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedOrganization {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Organization::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedOrganization> for NestedOrganization {
    fn from(item: web_common::database::nested_models::NestedOrganization) -> Self {
        Self {
            inner: item.inner.into(),
            country: item.country.into(),
        }
    }
}
impl From<NestedOrganization> for web_common::database::nested_models::NestedOrganization {
    fn from(item: NestedOrganization) -> Self {
        Self {
            inner: item.inner.into(),
            country: item.country.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectState {
    pub inner: ProjectState,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedProjectState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: ProjectState,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection)?,
            color: Color::get(flat_variant.color_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedProjectState {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::ProjectStateFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectState::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProjectState {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectState::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedProjectState {
    /// Get the nested struct from the provided color_id.
    ///
    /// # Arguments
    /// * `color_id` - The color_id of the row.
    /// * `connection` - The database connection.
    pub fn from_color_id(
        color_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        ProjectState::from_color_id(color_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedProjectState {
    /// Get the nested struct from the provided icon_id.
    ///
    /// # Arguments
    /// * `icon_id` - The icon_id of the row.
    /// * `connection` - The database connection.
    pub fn from_icon_id(
        icon_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        ProjectState::from_icon_id(icon_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedProjectState {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        ProjectState::from_name(name, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedProjectState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       ProjectState::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProjectState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       ProjectState::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProjectState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       ProjectState::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedProjectState> for NestedProjectState {
    fn from(item: web_common::database::nested_models::NestedProjectState) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedProjectState> for web_common::database::nested_models::NestedProjectState {
    fn from(item: NestedProjectState) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProject {
    pub inner: Project,
    pub state: NestedProjectState,
    pub icon: FontAwesomeIcon,
    pub color: Color,
    pub parent_project: Option<Project>,
    pub created_by: User,
    pub updated_by: User,
}

impl NestedProject {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: Project,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            state: NestedProjectState::get(flat_variant.state_id, connection)?,
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection)?,
            color: Color::get(flat_variant.color_id, connection)?,
            parent_project: flat_variant.parent_project_id.map(|flat_variant| Project::get(flat_variant, connection)).transpose()?,
            created_by: User::get(flat_variant.created_by, connection)?,
            updated_by: User::get(flat_variant.updated_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedProject {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::ProjectFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Project::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProject {
    /// Get all the editables nested structs from the database.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_editables(
        author_user_id: i32,
        filter: Option<&web_common::database::ProjectFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Project::all_editables(author_user_id, filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProject {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        filter: Option<&web_common::database::ProjectFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Project::all_by_updated_at(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProject {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Project::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedProject {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Project::from_name(name, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search_editables(
        author_user_id: i32,
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::similarity_search_editables(author_user_id, query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search_editables(
        author_user_id: i32,
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::word_similarity_search_editables(author_user_id, query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search_editables(
        author_user_id: i32,
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Project::strict_word_similarity_search_editables(author_user_id, query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedProject> for NestedProject {
    fn from(item: web_common::database::nested_models::NestedProject) -> Self {
        Self {
            inner: item.inner.into(),
            state: item.state.into(),
            icon: item.icon.into(),
            color: item.color.into(),
            parent_project: item.parent_project.map(|item| item.into()),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
impl From<NestedProject> for web_common::database::nested_models::NestedProject {
    fn from(item: NestedProject) -> Self {
        Self {
            inner: item.inner.into(),
            state: item.state.into(),
            icon: item.icon.into(),
            color: item.color.into(),
            parent_project: item.parent_project.map(|item| item.into()),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsTeamsRoleInvitation {
    pub inner: ProjectsTeamsRoleInvitation,
    pub table: NestedProject,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: ProjectsTeamsRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection)?,
            team: NestedTeam::get(flat_variant.team_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedProjectsTeamsRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::ProjectsTeamsRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsTeamsRoleInvitation::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProjectsTeamsRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsTeamsRoleInvitation::get(( table_id, team_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsTeamsRoleInvitation> for NestedProjectsTeamsRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedProjectsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsTeamsRoleInvitation> for web_common::database::nested_models::NestedProjectsTeamsRoleInvitation {
    fn from(item: NestedProjectsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsTeamsRoleRequest {
    pub inner: ProjectsTeamsRoleRequest,
    pub table: NestedProject,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: ProjectsTeamsRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection)?,
            team: NestedTeam::get(flat_variant.team_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedProjectsTeamsRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::ProjectsTeamsRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsTeamsRoleRequest::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProjectsTeamsRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsTeamsRoleRequest::get(( table_id, team_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsTeamsRoleRequest> for NestedProjectsTeamsRoleRequest {
    fn from(item: web_common::database::nested_models::NestedProjectsTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsTeamsRoleRequest> for web_common::database::nested_models::NestedProjectsTeamsRoleRequest {
    fn from(item: NestedProjectsTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsTeamsRole {
    pub inner: ProjectsTeamsRole,
    pub table: NestedProject,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: ProjectsTeamsRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection)?,
            team: NestedTeam::get(flat_variant.team_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedProjectsTeamsRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::ProjectsTeamsRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsTeamsRole::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProjectsTeamsRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsTeamsRole::get(( table_id, team_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsTeamsRole> for NestedProjectsTeamsRole {
    fn from(item: web_common::database::nested_models::NestedProjectsTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsTeamsRole> for web_common::database::nested_models::NestedProjectsTeamsRole {
    fn from(item: NestedProjectsTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsUsersRoleInvitation {
    pub inner: ProjectsUsersRoleInvitation,
    pub table: NestedProject,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: ProjectsUsersRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedProjectsUsersRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::ProjectsUsersRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsUsersRoleInvitation::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProjectsUsersRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsUsersRoleInvitation::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsUsersRoleInvitation> for NestedProjectsUsersRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedProjectsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsUsersRoleInvitation> for web_common::database::nested_models::NestedProjectsUsersRoleInvitation {
    fn from(item: NestedProjectsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsUsersRoleRequest {
    pub inner: ProjectsUsersRoleRequest,
    pub table: NestedProject,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: ProjectsUsersRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedProjectsUsersRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::ProjectsUsersRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsUsersRoleRequest::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProjectsUsersRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsUsersRoleRequest::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsUsersRoleRequest> for NestedProjectsUsersRoleRequest {
    fn from(item: web_common::database::nested_models::NestedProjectsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsUsersRoleRequest> for web_common::database::nested_models::NestedProjectsUsersRoleRequest {
    fn from(item: NestedProjectsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsUsersRole {
    pub inner: ProjectsUsersRole,
    pub table: NestedProject,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedProjectsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: ProjectsUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedProjectsUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::ProjectsUsersRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        ProjectsUsersRole::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedProjectsUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       ProjectsUsersRole::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedProjectsUsersRole> for NestedProjectsUsersRole {
    fn from(item: web_common::database::nested_models::NestedProjectsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedProjectsUsersRole> for web_common::database::nested_models::NestedProjectsUsersRole {
    fn from(item: NestedProjectsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedRole {
    pub inner: Role,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: Role,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection)?,
            color: Color::get(flat_variant.color_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::RoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Role::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Role::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedRole {
    /// Get the nested struct from the provided color_id.
    ///
    /// # Arguments
    /// * `color_id` - The color_id of the row.
    /// * `connection` - The database connection.
    pub fn from_color_id(
        color_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Role::from_color_id(color_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedRole {
    /// Get the nested struct from the provided description.
    ///
    /// # Arguments
    /// * `description` - The description of the row.
    /// * `connection` - The database connection.
    pub fn from_description(
        description: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Role::from_description(description, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedRole {
    /// Get the nested struct from the provided icon_id.
    ///
    /// # Arguments
    /// * `icon_id` - The icon_id of the row.
    /// * `connection` - The database connection.
    pub fn from_icon_id(
        icon_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Role::from_icon_id(icon_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedRole {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Role::from_name(name, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedRole {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Role::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedRole {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Role::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedRole {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Role::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedRole> for NestedRole {
    fn from(item: web_common::database::nested_models::NestedRole) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedRole> for web_common::database::nested_models::NestedRole {
    fn from(item: NestedRole) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampleBioOttTaxonItem {
    pub inner: SampleBioOttTaxonItem,
    pub created_by: User,
    pub sample: NestedSample,
    pub taxon: NestedBioOttTaxonItem,
}

impl NestedSampleBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SampleBioOttTaxonItem,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_variant.created_by, connection)?,
            sample: NestedSample::get(flat_variant.sample_id, connection)?,
            taxon: NestedBioOttTaxonItem::get(flat_variant.taxon_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSampleBioOttTaxonItem {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SampleBioOttTaxonItemFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampleBioOttTaxonItem::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampleBioOttTaxonItem {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( sample_id, taxon_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( sample_id, taxon_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampleBioOttTaxonItem::get(( sample_id, taxon_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSampleBioOttTaxonItem> for NestedSampleBioOttTaxonItem {
    fn from(item: web_common::database::nested_models::NestedSampleBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            sample: item.sample.into(),
            taxon: item.taxon.into(),
        }
    }
}
impl From<NestedSampleBioOttTaxonItem> for web_common::database::nested_models::NestedSampleBioOttTaxonItem {
    fn from(item: NestedSampleBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            sample: item.sample.into(),
            taxon: item.taxon.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampleContainerCategory {
    pub inner: SampleContainerCategory,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedSampleContainerCategory {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SampleContainerCategory,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection)?,
            color: Color::get(flat_variant.color_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSampleContainerCategory {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SampleContainerCategoryFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampleContainerCategory::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampleContainerCategory {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampleContainerCategory::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedSampleContainerCategory {
    /// Get the nested struct from the provided color_id.
    ///
    /// # Arguments
    /// * `color_id` - The color_id of the row.
    /// * `connection` - The database connection.
    pub fn from_color_id(
        color_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        SampleContainerCategory::from_color_id(color_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedSampleContainerCategory {
    /// Get the nested struct from the provided description.
    ///
    /// # Arguments
    /// * `description` - The description of the row.
    /// * `connection` - The database connection.
    pub fn from_description(
        description: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        SampleContainerCategory::from_description(description, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedSampleContainerCategory {
    /// Get the nested struct from the provided icon_id.
    ///
    /// # Arguments
    /// * `icon_id` - The icon_id of the row.
    /// * `connection` - The database connection.
    pub fn from_icon_id(
        icon_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        SampleContainerCategory::from_icon_id(icon_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedSampleContainerCategory {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleContainerCategory::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampleContainerCategory {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleContainerCategory::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampleContainerCategory {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleContainerCategory::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedSampleContainerCategory> for NestedSampleContainerCategory {
    fn from(item: web_common::database::nested_models::NestedSampleContainerCategory) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedSampleContainerCategory> for web_common::database::nested_models::NestedSampleContainerCategory {
    fn from(item: NestedSampleContainerCategory) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampleContainer {
    pub inner: SampleContainer,
    pub category: NestedSampleContainerCategory,
    pub created_by: User,
}

impl NestedSampleContainer {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SampleContainer,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            category: NestedSampleContainerCategory::get(flat_variant.category_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSampleContainer {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SampleContainerFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampleContainer::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampleContainer {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampleContainer::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedSampleContainer {
    /// Get the nested struct from the provided barcode.
    ///
    /// # Arguments
    /// * `barcode` - The barcode of the row.
    /// * `connection` - The database connection.
    pub fn from_barcode(
        barcode: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        SampleContainer::from_barcode(barcode, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedSampleContainer {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleContainer::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampleContainer {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleContainer::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampleContainer {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleContainer::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedSampleContainer> for NestedSampleContainer {
    fn from(item: web_common::database::nested_models::NestedSampleContainer) -> Self {
        Self {
            inner: item.inner.into(),
            category: item.category.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSampleContainer> for web_common::database::nested_models::NestedSampleContainer {
    fn from(item: NestedSampleContainer) -> Self {
        Self {
            inner: item.inner.into(),
            category: item.category.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampleState {
    pub inner: SampleState,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedSampleState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SampleState,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection)?,
            color: Color::get(flat_variant.color_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSampleState {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SampleStateFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampleState::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampleState {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampleState::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedSampleState {
    /// Get the nested struct from the provided color_id.
    ///
    /// # Arguments
    /// * `color_id` - The color_id of the row.
    /// * `connection` - The database connection.
    pub fn from_color_id(
        color_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        SampleState::from_color_id(color_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedSampleState {
    /// Get the nested struct from the provided icon_id.
    ///
    /// # Arguments
    /// * `icon_id` - The icon_id of the row.
    /// * `connection` - The database connection.
    pub fn from_icon_id(
        icon_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        SampleState::from_icon_id(icon_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedSampleState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleState::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampleState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleState::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampleState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampleState::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedSampleState> for NestedSampleState {
    fn from(item: web_common::database::nested_models::NestedSampleState) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedSampleState> for web_common::database::nested_models::NestedSampleState {
    fn from(item: NestedSampleState) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualBioOttTaxonItem {
    pub inner: SampledIndividualBioOttTaxonItem,
    pub created_by: User,
    pub sampled_individual: NestedSampledIndividual,
    pub taxon: NestedBioOttTaxonItem,
}

impl NestedSampledIndividualBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SampledIndividualBioOttTaxonItem,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_variant.created_by, connection)?,
            sampled_individual: NestedSampledIndividual::get(flat_variant.sampled_individual_id, connection)?,
            taxon: NestedBioOttTaxonItem::get(flat_variant.taxon_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSampledIndividualBioOttTaxonItem {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SampledIndividualBioOttTaxonItemFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividualBioOttTaxonItem::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampledIndividualBioOttTaxonItem {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( sampled_individual_id, taxon_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( sampled_individual_id, taxon_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampledIndividualBioOttTaxonItem::get(( sampled_individual_id, taxon_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSampledIndividualBioOttTaxonItem> for NestedSampledIndividualBioOttTaxonItem {
    fn from(item: web_common::database::nested_models::NestedSampledIndividualBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            sampled_individual: item.sampled_individual.into(),
            taxon: item.taxon.into(),
        }
    }
}
impl From<NestedSampledIndividualBioOttTaxonItem> for web_common::database::nested_models::NestedSampledIndividualBioOttTaxonItem {
    fn from(item: NestedSampledIndividualBioOttTaxonItem) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            sampled_individual: item.sampled_individual.into(),
            taxon: item.taxon.into(),
        }
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividual {
    pub inner: SampledIndividual,
    pub project: NestedProject,
    pub created_by: User,
    pub updated_by: User,
}

impl NestedSampledIndividual {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SampledIndividual,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            project: NestedProject::get(flat_variant.project_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
            updated_by: User::get(flat_variant.updated_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSampledIndividual {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SampledIndividualFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividual::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampledIndividual {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        filter: Option<&web_common::database::SampledIndividualFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SampledIndividual::all_by_updated_at(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampledIndividual {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SampledIndividual::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedSampledIndividual {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampledIndividual::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampledIndividual {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampledIndividual::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSampledIndividual {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       SampledIndividual::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedSampledIndividual> for NestedSampledIndividual {
    fn from(item: web_common::database::nested_models::NestedSampledIndividual) -> Self {
        Self {
            inner: item.inner.into(),
            project: item.project.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
impl From<NestedSampledIndividual> for web_common::database::nested_models::NestedSampledIndividual {
    fn from(item: NestedSampledIndividual) -> Self {
        Self {
            inner: item.inner.into(),
            project: item.project.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSample {
    pub inner: Sample,
    pub container: NestedSampleContainer,
    pub created_by: User,
    pub sampled_by: User,
    pub updated_by: User,
    pub state: NestedSampleState,
}

impl NestedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: Sample,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            container: NestedSampleContainer::get(flat_variant.container_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
            sampled_by: User::get(flat_variant.sampled_by, connection)?,
            updated_by: User::get(flat_variant.updated_by, connection)?,
            state: NestedSampleState::get(flat_variant.state, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSample {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SampleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Sample::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSample {
    /// Get all the editables nested structs from the database.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_editables(
        author_user_id: i32,
        filter: Option<&web_common::database::SampleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Sample::all_editables(author_user_id, filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSample {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        filter: Option<&web_common::database::SampleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Sample::all_by_updated_at(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSample {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Sample::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedSample {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Sample::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSample {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search_editables(
        author_user_id: i32,
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Sample::similarity_search_editables(author_user_id, query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSample {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Sample::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSample {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search_editables(
        author_user_id: i32,
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Sample::word_similarity_search_editables(author_user_id, query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSample {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Sample::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSample {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search_editables(
        author_user_id: i32,
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Sample::strict_word_similarity_search_editables(author_user_id, query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedSample> for NestedSample {
    fn from(item: web_common::database::nested_models::NestedSample) -> Self {
        Self {
            inner: item.inner.into(),
            container: item.container.into(),
            created_by: item.created_by.into(),
            sampled_by: item.sampled_by.into(),
            updated_by: item.updated_by.into(),
            state: item.state.into(),
        }
    }
}
impl From<NestedSample> for web_common::database::nested_models::NestedSample {
    fn from(item: NestedSample) -> Self {
        Self {
            inner: item.inner.into(),
            container: item.container.into(),
            created_by: item.created_by.into(),
            sampled_by: item.sampled_by.into(),
            updated_by: item.updated_by.into(),
            state: item.state.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesTeamsRoleInvitation {
    pub inner: SamplesTeamsRoleInvitation,
    pub table: NestedSample,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SamplesTeamsRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection)?,
            team: NestedTeam::get(flat_variant.team_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSamplesTeamsRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SamplesTeamsRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesTeamsRoleInvitation::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSamplesTeamsRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesTeamsRoleInvitation::get(( table_id, team_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesTeamsRoleInvitation> for NestedSamplesTeamsRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedSamplesTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesTeamsRoleInvitation> for web_common::database::nested_models::NestedSamplesTeamsRoleInvitation {
    fn from(item: NestedSamplesTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesTeamsRoleRequest {
    pub inner: SamplesTeamsRoleRequest,
    pub table: NestedSample,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SamplesTeamsRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection)?,
            team: NestedTeam::get(flat_variant.team_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSamplesTeamsRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SamplesTeamsRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesTeamsRoleRequest::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSamplesTeamsRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesTeamsRoleRequest::get(( table_id, team_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesTeamsRoleRequest> for NestedSamplesTeamsRoleRequest {
    fn from(item: web_common::database::nested_models::NestedSamplesTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesTeamsRoleRequest> for web_common::database::nested_models::NestedSamplesTeamsRoleRequest {
    fn from(item: NestedSamplesTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesTeamsRole {
    pub inner: SamplesTeamsRole,
    pub table: NestedSample,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SamplesTeamsRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection)?,
            team: NestedTeam::get(flat_variant.team_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSamplesTeamsRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SamplesTeamsRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesTeamsRole::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSamplesTeamsRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesTeamsRole::get(( table_id, team_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesTeamsRole> for NestedSamplesTeamsRole {
    fn from(item: web_common::database::nested_models::NestedSamplesTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesTeamsRole> for web_common::database::nested_models::NestedSamplesTeamsRole {
    fn from(item: NestedSamplesTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesUsersRoleInvitation {
    pub inner: SamplesUsersRoleInvitation,
    pub table: NestedSample,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SamplesUsersRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSamplesUsersRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SamplesUsersRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesUsersRoleInvitation::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSamplesUsersRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesUsersRoleInvitation::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesUsersRoleInvitation> for NestedSamplesUsersRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedSamplesUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesUsersRoleInvitation> for web_common::database::nested_models::NestedSamplesUsersRoleInvitation {
    fn from(item: NestedSamplesUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesUsersRoleRequest {
    pub inner: SamplesUsersRoleRequest,
    pub table: NestedSample,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SamplesUsersRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSamplesUsersRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SamplesUsersRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesUsersRoleRequest::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSamplesUsersRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesUsersRoleRequest::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesUsersRoleRequest> for NestedSamplesUsersRoleRequest {
    fn from(item: web_common::database::nested_models::NestedSamplesUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesUsersRoleRequest> for web_common::database::nested_models::NestedSamplesUsersRoleRequest {
    fn from(item: NestedSamplesUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesUsersRole {
    pub inner: SamplesUsersRole,
    pub table: NestedSample,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSamplesUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SamplesUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSamplesUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SamplesUsersRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SamplesUsersRole::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSamplesUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SamplesUsersRole::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSamplesUsersRole> for NestedSamplesUsersRole {
    fn from(item: web_common::database::nested_models::NestedSamplesUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSamplesUsersRole> for web_common::database::nested_models::NestedSamplesUsersRole {
    fn from(item: NestedSamplesUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectra {
    pub inner: Spectra,
    pub spectra_collection: NestedSpectraCollection,
}

impl NestedSpectra {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: Spectra,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            spectra_collection: NestedSpectraCollection::get(flat_variant.spectra_collection_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSpectra {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SpectraFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Spectra::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSpectra {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Spectra::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectra> for NestedSpectra {
    fn from(item: web_common::database::nested_models::NestedSpectra) -> Self {
        Self {
            inner: item.inner.into(),
            spectra_collection: item.spectra_collection.into(),
        }
    }
}
impl From<NestedSpectra> for web_common::database::nested_models::NestedSpectra {
    fn from(item: NestedSpectra) -> Self {
        Self {
            inner: item.inner.into(),
            spectra_collection: item.spectra_collection.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollection {
    pub inner: SpectraCollection,
    pub sample: NestedSample,
    pub created_by: User,
    pub updated_by: User,
}

impl NestedSpectraCollection {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SpectraCollection,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            sample: NestedSample::get(flat_variant.sample_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
            updated_by: User::get(flat_variant.updated_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSpectraCollection {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SpectraCollectionFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollection::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSpectraCollection {
    /// Get all the editables nested structs from the database.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_editables(
        author_user_id: i32,
        filter: Option<&web_common::database::SpectraCollectionFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollection::all_editables(author_user_id, filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSpectraCollection {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        filter: Option<&web_common::database::SpectraCollectionFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollection::all_by_updated_at(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSpectraCollection {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollection::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollection> for NestedSpectraCollection {
    fn from(item: web_common::database::nested_models::NestedSpectraCollection) -> Self {
        Self {
            inner: item.inner.into(),
            sample: item.sample.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
impl From<NestedSpectraCollection> for web_common::database::nested_models::NestedSpectraCollection {
    fn from(item: NestedSpectraCollection) -> Self {
        Self {
            inner: item.inner.into(),
            sample: item.sample.into(),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsTeamsRoleInvitation {
    pub inner: SpectraCollectionsTeamsRoleInvitation,
    pub table: NestedSpectraCollection,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SpectraCollectionsTeamsRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection)?,
            team: NestedTeam::get(flat_variant.team_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSpectraCollectionsTeamsRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SpectraCollectionsTeamsRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsTeamsRoleInvitation::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSpectraCollectionsTeamsRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsTeamsRoleInvitation::get(( table_id, team_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleInvitation> for NestedSpectraCollectionsTeamsRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsTeamsRoleInvitation> for web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleInvitation {
    fn from(item: NestedSpectraCollectionsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsTeamsRoleRequest {
    pub inner: SpectraCollectionsTeamsRoleRequest,
    pub table: NestedSpectraCollection,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SpectraCollectionsTeamsRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection)?,
            team: NestedTeam::get(flat_variant.team_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSpectraCollectionsTeamsRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SpectraCollectionsTeamsRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsTeamsRoleRequest::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSpectraCollectionsTeamsRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsTeamsRoleRequest::get(( table_id, team_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleRequest> for NestedSpectraCollectionsTeamsRoleRequest {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsTeamsRoleRequest> for web_common::database::nested_models::NestedSpectraCollectionsTeamsRoleRequest {
    fn from(item: NestedSpectraCollectionsTeamsRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsTeamsRole {
    pub inner: SpectraCollectionsTeamsRole,
    pub table: NestedSpectraCollection,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SpectraCollectionsTeamsRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection)?,
            team: NestedTeam::get(flat_variant.team_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSpectraCollectionsTeamsRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SpectraCollectionsTeamsRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsTeamsRole::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSpectraCollectionsTeamsRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsTeamsRole::get(( table_id, team_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsTeamsRole> for NestedSpectraCollectionsTeamsRole {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsTeamsRole> for web_common::database::nested_models::NestedSpectraCollectionsTeamsRole {
    fn from(item: NestedSpectraCollectionsTeamsRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsUsersRoleInvitation {
    pub inner: SpectraCollectionsUsersRoleInvitation,
    pub table: NestedSpectraCollection,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SpectraCollectionsUsersRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSpectraCollectionsUsersRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SpectraCollectionsUsersRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsUsersRoleInvitation::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSpectraCollectionsUsersRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsUsersRoleInvitation::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsUsersRoleInvitation> for NestedSpectraCollectionsUsersRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsUsersRoleInvitation> for web_common::database::nested_models::NestedSpectraCollectionsUsersRoleInvitation {
    fn from(item: NestedSpectraCollectionsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsUsersRoleRequest {
    pub inner: SpectraCollectionsUsersRoleRequest,
    pub table: NestedSpectraCollection,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SpectraCollectionsUsersRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSpectraCollectionsUsersRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SpectraCollectionsUsersRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsUsersRoleRequest::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSpectraCollectionsUsersRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsUsersRoleRequest::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsUsersRoleRequest> for NestedSpectraCollectionsUsersRoleRequest {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsUsersRoleRequest> for web_common::database::nested_models::NestedSpectraCollectionsUsersRoleRequest {
    fn from(item: NestedSpectraCollectionsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsUsersRole {
    pub inner: SpectraCollectionsUsersRole,
    pub table: NestedSpectraCollection,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedSpectraCollectionsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: SpectraCollectionsUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedSpectraCollectionsUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::SpectraCollectionsUsersRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        SpectraCollectionsUsersRole::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedSpectraCollectionsUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       SpectraCollectionsUsersRole::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollectionsUsersRole> for NestedSpectraCollectionsUsersRole {
    fn from(item: web_common::database::nested_models::NestedSpectraCollectionsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedSpectraCollectionsUsersRole> for web_common::database::nested_models::NestedSpectraCollectionsUsersRole {
    fn from(item: NestedSpectraCollectionsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamState {
    pub inner: TeamState,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

impl NestedTeamState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: TeamState,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection)?,
            color: Color::get(flat_variant.color_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedTeamState {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::TeamStateFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        TeamState::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeamState {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       TeamState::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedTeamState {
    /// Get the nested struct from the provided color_id.
    ///
    /// # Arguments
    /// * `color_id` - The color_id of the row.
    /// * `connection` - The database connection.
    pub fn from_color_id(
        color_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        TeamState::from_color_id(color_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedTeamState {
    /// Get the nested struct from the provided icon_id.
    ///
    /// # Arguments
    /// * `icon_id` - The icon_id of the row.
    /// * `connection` - The database connection.
    pub fn from_icon_id(
        icon_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        TeamState::from_icon_id(icon_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedTeamState {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        TeamState::from_name(name, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedTeamState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       TeamState::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeamState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       TeamState::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeamState {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       TeamState::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedTeamState> for NestedTeamState {
    fn from(item: web_common::database::nested_models::NestedTeamState) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
impl From<NestedTeamState> for web_common::database::nested_models::NestedTeamState {
    fn from(item: NestedTeamState) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeam {
    pub inner: Team,
    pub icon: FontAwesomeIcon,
    pub color: Color,
    pub parent_team: Option<Team>,
    pub created_by: User,
    pub updated_by: User,
}

impl NestedTeam {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: Team,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection)?,
            color: Color::get(flat_variant.color_id, connection)?,
            parent_team: flat_variant.parent_team_id.map(|flat_variant| Team::get(flat_variant, connection)).transpose()?,
            created_by: User::get(flat_variant.created_by, connection)?,
            updated_by: User::get(flat_variant.updated_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedTeam {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::TeamFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Team::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeam {
    /// Get all the editables nested structs from the database.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_editables(
        author_user_id: i32,
        filter: Option<&web_common::database::TeamFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Team::all_editables(author_user_id, filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeam {
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all_by_updated_at(
        filter: Option<&web_common::database::TeamFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        Team::all_by_updated_at(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeam {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       Team::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedTeam {
    /// Get the nested struct from the provided name.
    ///
    /// # Arguments
    /// * `name` - The name of the row.
    /// * `connection` - The database connection.
    pub fn from_name(
        name: &str,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        Team::from_name(name, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedTeam {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Team::similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeam {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn similarity_search_editables(
        author_user_id: i32,
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Team::similarity_search_editables(author_user_id, query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeam {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Team::word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeam {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn word_similarity_search_editables(
        author_user_id: i32,
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Team::word_similarity_search_editables(author_user_id, query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeam {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search(
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Team::strict_word_similarity_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeam {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `author_user_id` - The user id.
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    pub fn strict_word_similarity_search_editables(
        author_user_id: i32,
        query: &str,
        limit: Option<i32>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
       Team::strict_word_similarity_search_editables(author_user_id, query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl From<web_common::database::nested_models::NestedTeam> for NestedTeam {
    fn from(item: web_common::database::nested_models::NestedTeam) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
            parent_team: item.parent_team.map(|item| item.into()),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
impl From<NestedTeam> for web_common::database::nested_models::NestedTeam {
    fn from(item: NestedTeam) -> Self {
        Self {
            inner: item.inner.into(),
            icon: item.icon.into(),
            color: item.color.into(),
            parent_team: item.parent_team.map(|item| item.into()),
            created_by: item.created_by.into(),
            updated_by: item.updated_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsTeamsRoleInvitation {
    pub inner: TeamsTeamsRoleInvitation,
    pub table: NestedTeam,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedTeamsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: TeamsTeamsRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_variant.table_id, connection)?,
            team: NestedTeam::get(flat_variant.team_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedTeamsTeamsRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::TeamsTeamsRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        TeamsTeamsRoleInvitation::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeamsTeamsRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       TeamsTeamsRoleInvitation::get(( table_id, team_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedTeamsTeamsRoleInvitation> for NestedTeamsTeamsRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedTeamsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedTeamsTeamsRoleInvitation> for web_common::database::nested_models::NestedTeamsTeamsRoleInvitation {
    fn from(item: NestedTeamsTeamsRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            team: item.team.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsUsersRoleInvitation {
    pub inner: TeamsUsersRoleInvitation,
    pub table: NestedTeam,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedTeamsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: TeamsUsersRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedTeamsUsersRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::TeamsUsersRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        TeamsUsersRoleInvitation::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeamsUsersRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       TeamsUsersRoleInvitation::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedTeamsUsersRoleInvitation> for NestedTeamsUsersRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedTeamsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedTeamsUsersRoleInvitation> for web_common::database::nested_models::NestedTeamsUsersRoleInvitation {
    fn from(item: NestedTeamsUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsUsersRoleRequest {
    pub inner: TeamsUsersRoleRequest,
    pub table: NestedTeam,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedTeamsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: TeamsUsersRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedTeamsUsersRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::TeamsUsersRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        TeamsUsersRoleRequest::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeamsUsersRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       TeamsUsersRoleRequest::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedTeamsUsersRoleRequest> for NestedTeamsUsersRoleRequest {
    fn from(item: web_common::database::nested_models::NestedTeamsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedTeamsUsersRoleRequest> for web_common::database::nested_models::NestedTeamsUsersRoleRequest {
    fn from(item: NestedTeamsUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsUsersRole {
    pub inner: TeamsUsersRole,
    pub table: NestedTeam,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedTeamsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: TeamsUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedTeamsUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::TeamsUsersRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        TeamsUsersRole::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedTeamsUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       TeamsUsersRole::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedTeamsUsersRole> for NestedTeamsUsersRole {
    fn from(item: web_common::database::nested_models::NestedTeamsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedTeamsUsersRole> for web_common::database::nested_models::NestedTeamsUsersRole {
    fn from(item: NestedTeamsUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUserEmail {
    pub inner: UserEmail,
    pub created_by: User,
    pub login_provider: NestedLoginProvider,
}

impl NestedUserEmail {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: UserEmail,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            created_by: User::get(flat_variant.created_by, connection)?,
            login_provider: NestedLoginProvider::get(flat_variant.login_provider_id, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedUserEmail {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::UserEmailFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        UserEmail::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedUserEmail {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       UserEmail::get(id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl NestedUserEmail {
    /// Get the nested struct from the provided email and login_provider_id.
    ///
    /// # Arguments
    /// * `email` - The email of the row.
    /// * `login_provider_id` - The login_provider_id of the row.
    /// * `connection` - The database connection.
    pub fn from_email_and_login_provider_id(
        email: &str,
        login_provider_id: &i32,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        UserEmail::from_email_and_login_provider_id(email, login_provider_id, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedUserEmail> for NestedUserEmail {
    fn from(item: web_common::database::nested_models::NestedUserEmail) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            login_provider: item.login_provider.into(),
        }
    }
}
impl From<NestedUserEmail> for web_common::database::nested_models::NestedUserEmail {
    fn from(item: NestedUserEmail) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
            login_provider: item.login_provider.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUsersUsersRoleInvitation {
    pub inner: UsersUsersRoleInvitation,
    pub table: User,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedUsersUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: UsersUsersRoleInvitation,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: User::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedUsersUsersRoleInvitation {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::UsersUsersRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        UsersUsersRoleInvitation::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedUsersUsersRoleInvitation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       UsersUsersRoleInvitation::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedUsersUsersRoleInvitation> for NestedUsersUsersRoleInvitation {
    fn from(item: web_common::database::nested_models::NestedUsersUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedUsersUsersRoleInvitation> for web_common::database::nested_models::NestedUsersUsersRoleInvitation {
    fn from(item: NestedUsersUsersRoleInvitation) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUsersUsersRoleRequest {
    pub inner: UsersUsersRoleRequest,
    pub table: User,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedUsersUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: UsersUsersRoleRequest,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: User::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedUsersUsersRoleRequest {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::UsersUsersRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        UsersUsersRoleRequest::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedUsersUsersRoleRequest {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       UsersUsersRoleRequest::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedUsersUsersRoleRequest> for NestedUsersUsersRoleRequest {
    fn from(item: web_common::database::nested_models::NestedUsersUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedUsersUsersRoleRequest> for web_common::database::nested_models::NestedUsersUsersRoleRequest {
    fn from(item: NestedUsersUsersRoleRequest) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUsersUsersRole {
    pub inner: UsersUsersRole,
    pub table: User,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

impl NestedUsersUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub fn from_flat(
        flat_variant: UsersUsersRole,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        Ok(Self {
            table: User::get(flat_variant.table_id, connection)?,
            user: User::get(flat_variant.user_id, connection)?,
            role: NestedRole::get(flat_variant.role_id, connection)?,
            created_by: User::get(flat_variant.created_by, connection)?,
                inner: flat_variant,
        })
    }
}
impl NestedUsersUsersRole {
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return. By default `10`.
    /// * `offset` - The offset of the rows to return. By default `0`.
    /// * `connection` - The database connection.
    pub fn all(
        filter: Option<&web_common::database::UsersUsersRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        UsersUsersRole::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()
    }
}
impl NestedUsersUsersRole {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub fn get(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
       UsersUsersRole::get(( table_id, user_id ), connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))
    }
}
impl From<web_common::database::nested_models::NestedUsersUsersRole> for NestedUsersUsersRole {
    fn from(item: web_common::database::nested_models::NestedUsersUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedUsersUsersRole> for web_common::database::nested_models::NestedUsersUsersRole {
    fn from(item: NestedUsersUsersRole) -> Self {
        Self {
            inner: item.inner.into(),
            table: item.table.into(),
            user: item.user.into(),
            role: item.role.into(),
            created_by: item.created_by.into(),
        }
    }
}
