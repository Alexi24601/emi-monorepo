//! This module contains the nested structs for the database tables.
//!
//! This file is automatically generated. Do not write anything here.

use uuid::Uuid;
use serde::Deserialize;
use serde::Serialize;
use chrono::NaiveDateTime;
use diesel::r2d2::ConnectionManager;
use diesel::r2d2::PooledConnection;
use diesel::prelude::*;
use crate::models::*;
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedArchivable {
    pub id: Uuid,
    pub archived_at: NaiveDateTime,
    pub archived_by: User,
}

impl NestedArchivable {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::archivables;
        let flat_struct = Archivable::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            archived_at: flat_struct.archived_at,
            archived_by: User::get(flat_struct.archived_by, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedContainerHorizontalRule {
    pub id: Uuid,
    pub item_type: ItemCategory,
    pub other_item_type: ItemCategory,
    pub minimum_temperature: Option<f64>,
    pub maximum_temperature: Option<f64>,
    pub minimum_humidity: Option<f64>,
    pub maximum_humidity: Option<f64>,
    pub minimum_pressure: Option<f64>,
    pub maximum_pressure: Option<f64>,
}

impl NestedContainerHorizontalRule {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::container_horizontal_rules;
        let flat_struct = ContainerHorizontalRule::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            item_type: ItemCategory::get(flat_struct.item_type_id, connection)?,
            other_item_type: ItemCategory::get(flat_struct.other_item_type_id, connection)?,
            minimum_temperature: flat_struct.minimum_temperature,
            maximum_temperature: flat_struct.maximum_temperature,
            minimum_humidity: flat_struct.minimum_humidity,
            maximum_humidity: flat_struct.maximum_humidity,
            minimum_pressure: flat_struct.minimum_pressure,
            maximum_pressure: flat_struct.maximum_pressure,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedContainerVerticalRule {
    pub id: Uuid,
    pub container_item_type: ItemCategory,
    pub contained_item_type: ItemCategory,
    pub minimum_temperature: Option<f64>,
    pub maximum_temperature: Option<f64>,
    pub minimum_humidity: Option<f64>,
    pub maximum_humidity: Option<f64>,
    pub minimum_pressure: Option<f64>,
    pub maximum_pressure: Option<f64>,
}

impl NestedContainerVerticalRule {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::container_vertical_rules;
        let flat_struct = ContainerVerticalRule::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            container_item_type: ItemCategory::get(flat_struct.container_item_type_id, connection)?,
            contained_item_type: ItemCategory::get(flat_struct.contained_item_type_id, connection)?,
            minimum_temperature: flat_struct.minimum_temperature,
            maximum_temperature: flat_struct.maximum_temperature,
            minimum_humidity: flat_struct.minimum_humidity,
            maximum_humidity: flat_struct.maximum_humidity,
            minimum_pressure: flat_struct.minimum_pressure,
            maximum_pressure: flat_struct.maximum_pressure,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedDocument {
    pub id: Uuid,
    pub path: String,
    pub format: DocumentFormat,
    pub bytes: i32,
}

impl NestedDocument {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::documents;
        let flat_struct = Document::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            path: flat_struct.path,
            format: DocumentFormat::get(flat_struct.format_id, connection)?,
            bytes: flat_struct.bytes,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedEditable {
    pub id: Uuid,
    pub created_at: NaiveDateTime,
    pub created_by: User,
}

impl NestedEditable {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::editables;
        let flat_struct = Editable::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            created_at: flat_struct.created_at,
            created_by: User::get(flat_struct.created_by, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedEdit {
    pub id: Uuid,
    pub editable: NestedEditable,
}

impl NestedEdit {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::edits;
        let flat_struct = Edit::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            editable: NestedEditable::get(flat_struct.editable_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedItemCategoryRelationship {
    pub id: Uuid,
    pub parent: ItemCategory,
    pub child: ItemCategory,
}

impl NestedItemCategoryRelationship {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::item_category_relationships;
        let flat_struct = ItemCategoryRelationship::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            parent: ItemCategory::get(flat_struct.parent_id, connection)?,
            child: ItemCategory::get(flat_struct.child_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedItemCategoryUnit {
    pub id: Uuid,
    pub item_category: ItemCategory,
    pub unit: Unit,
}

impl NestedItemCategoryUnit {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::item_category_units;
        let flat_struct = ItemCategoryUnit::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            item_category: ItemCategory::get(flat_struct.item_category_id, connection)?,
            unit: Unit::get(flat_struct.unit_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedItemContinuousQuantity {
    pub id: Uuid,
    pub item: NestedItem,
    pub weight: f64,
    pub unit: Unit,
    pub sensor: Option<NestedItem>,
    pub measured_at: NaiveDateTime,
    pub measured_by: Option<User>,
}

impl NestedItemContinuousQuantity {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::item_continuous_quantities;
        let flat_struct = ItemContinuousQuantity::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            item: NestedItem::get(flat_struct.item_id, connection)?,
            weight: flat_struct.weight,
            unit: Unit::get(flat_struct.unit_id, connection)?,
            sensor: flat_struct.sensor_id.map(|flat_struct| NestedItem::get(flat_struct, connection)).transpose()?,
            measured_at: flat_struct.measured_at,
            measured_by: flat_struct.measured_by.map(|flat_struct| User::get(flat_struct, connection)).transpose()?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedItemDiscreteQuantity {
    pub id: Uuid,
    pub item: NestedItem,
    pub quantity: i32,
    pub unit: Unit,
    pub measured_at: NaiveDateTime,
    pub measured_by: Option<User>,
}

impl NestedItemDiscreteQuantity {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::item_discrete_quantities;
        let flat_struct = ItemDiscreteQuantity::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            item: NestedItem::get(flat_struct.item_id, connection)?,
            quantity: flat_struct.quantity,
            unit: Unit::get(flat_struct.unit_id, connection)?,
            measured_at: flat_struct.measured_at,
            measured_by: flat_struct.measured_by.map(|flat_struct| User::get(flat_struct, connection)).transpose()?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedItemLocation {
    pub id: Uuid,
    pub item: Option<NestedItem>,
    pub location: Option<NestedLocation>,
    pub previous_location: Option<NestedLocation>,
}

impl NestedItemLocation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::item_locations;
        let flat_struct = ItemLocation::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            item: flat_struct.item_id.map(|flat_struct| NestedItem::get(flat_struct, connection)).transpose()?,
            location: flat_struct.location_id.map(|flat_struct| NestedLocation::get(flat_struct, connection)).transpose()?,
            previous_location: flat_struct.previous_location_id.map(|flat_struct| NestedLocation::get(flat_struct, connection)).transpose()?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedItemUnit {
    pub id: Uuid,
    pub item: NestedItem,
    pub unit: Unit,
}

impl NestedItemUnit {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::item_units;
        let flat_struct = ItemUnit::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            item: NestedItem::get(flat_struct.item_id, connection)?,
            unit: Unit::get(flat_struct.unit_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedItem {
    pub id: Uuid,
    pub parent: Option<Box<NestedItem>>,
}

impl NestedItem {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::items;
        let flat_struct = Item::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            parent: flat_struct.parent_id.map(|flat_struct| NestedItem::get(flat_struct, connection)).transpose()?.map(Box::new),
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedLocation {
    pub id: Uuid,
    pub latitude: Option<f64>,
    pub longitude: Option<f64>,
    pub altitude: Option<f64>,
    pub address: Option<String>,
    pub geolocalization_device: Option<NestedItem>,
    pub altitude_device: Option<NestedItem>,
    pub parent_location: Option<Box<NestedLocation>>,
    pub state: LocationState,
}

impl NestedLocation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::locations;
        let flat_struct = Location::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            latitude: flat_struct.latitude,
            longitude: flat_struct.longitude,
            altitude: flat_struct.altitude,
            address: flat_struct.address,
            geolocalization_device: flat_struct.geolocalization_device_id.map(|flat_struct| NestedItem::get(flat_struct, connection)).transpose()?,
            altitude_device: flat_struct.altitude_device_id.map(|flat_struct| NestedItem::get(flat_struct, connection)).transpose()?,
            parent_location: flat_struct.parent_location_id.map(|flat_struct| NestedLocation::get(flat_struct, connection)).transpose()?.map(Box::new),
            state: LocationState::get(flat_struct.state_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedManufacturedItemCategory {
    pub id: Uuid,
    pub cost: f64,
    pub cost_per_day: f64,
    pub currency: String,
    pub manifacturer: NestedOrganization,
}

impl NestedManufacturedItemCategory {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::manufactured_item_categories;
        let flat_struct = ManufacturedItemCategory::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            cost: flat_struct.cost,
            cost_per_day: flat_struct.cost_per_day,
            currency: flat_struct.currency,
            manifacturer: NestedOrganization::get(flat_struct.manifacturer_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedNotification {
    pub id: Uuid,
    pub user: User,
    pub operation: String,
    pub table_name: String,
    pub row: Option<NestedEditable>,
    pub read: bool,
}

impl NestedNotification {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::notifications;
        let flat_struct = Notification::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            user: User::get(flat_struct.user_id, connection)?,
            operation: flat_struct.operation,
            table_name: flat_struct.table_name,
            row: flat_struct.row_id.map(|flat_struct| NestedEditable::get(flat_struct, connection)).transpose()?,
            read: flat_struct.read,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedOrganizationAuthorization {
    pub id: Uuid,
    pub organization: NestedOrganization,
    pub editable: NestedEditable,
    pub role: Role,
}

impl NestedOrganizationAuthorization {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::organization_authorizations;
        let flat_struct = OrganizationAuthorization::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            organization: NestedOrganization::get(flat_struct.organization_id, connection)?,
            editable: NestedEditable::get(flat_struct.editable_id, connection)?,
            role: Role::get(flat_struct.role_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedOrganizationLocation {
    pub id: Uuid,
    pub organization: Option<NestedOrganization>,
    pub location: Option<NestedLocation>,
    pub previous_location: Option<Box<NestedOrganizationLocation>>,
}

impl NestedOrganizationLocation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::organization_locations;
        let flat_struct = OrganizationLocation::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            organization: flat_struct.organization_id.map(|flat_struct| NestedOrganization::get(flat_struct, connection)).transpose()?,
            location: flat_struct.location_id.map(|flat_struct| NestedLocation::get(flat_struct, connection)).transpose()?,
            previous_location: flat_struct.previous_location_id.map(|flat_struct| NestedOrganizationLocation::get(flat_struct, connection)).transpose()?.map(Box::new),
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedOrganization {
    pub id: Uuid,
    pub state: Option<OrganizationState>,
    pub parent_organization: Option<Box<NestedOrganization>>,
    pub logo: Option<NestedDocument>,
    pub website_url: Option<String>,
}

impl NestedOrganization {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::organizations;
        let flat_struct = Organization::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            state: flat_struct.state_id.map(|flat_struct| OrganizationState::get(flat_struct, connection)).transpose()?,
            parent_organization: flat_struct.parent_organization_id.map(|flat_struct| NestedOrganization::get(flat_struct, connection)).transpose()?.map(Box::new),
            logo: flat_struct.logo_id.map(|flat_struct| NestedDocument::get(flat_struct, connection)).transpose()?,
            website_url: flat_struct.website_url,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedProcedureContinuousRequirement {
    pub id: Uuid,
    pub procedure: Procedure,
    pub item_category: ItemCategory,
    pub quantity: f64,
    pub unit: Option<Unit>,
}

impl NestedProcedureContinuousRequirement {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::procedure_continuous_requirements;
        let flat_struct = ProcedureContinuousRequirement::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            procedure: Procedure::get(flat_struct.procedure_id, connection)?,
            item_category: ItemCategory::get(flat_struct.item_category_id, connection)?,
            quantity: flat_struct.quantity,
            unit: flat_struct.unit_id.map(|flat_struct| Unit::get(flat_struct, connection)).transpose()?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedProcedureDiscreteRequirement {
    pub id: Uuid,
    pub procedure: Procedure,
    pub item_category: ItemCategory,
    pub quantity: i32,
    pub unit: Option<Unit>,
}

impl NestedProcedureDiscreteRequirement {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::procedure_discrete_requirements;
        let flat_struct = ProcedureDiscreteRequirement::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            procedure: Procedure::get(flat_struct.procedure_id, connection)?,
            item_category: ItemCategory::get(flat_struct.item_category_id, connection)?,
            quantity: flat_struct.quantity,
            unit: flat_struct.unit_id.map(|flat_struct| Unit::get(flat_struct, connection)).transpose()?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedProjectContinuousRequirement {
    pub id: Uuid,
    pub project: NestedProject,
    pub item: ItemCategory,
    pub quantity: f64,
    pub unit: Option<Unit>,
}

impl NestedProjectContinuousRequirement {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::project_continuous_requirements;
        let flat_struct = ProjectContinuousRequirement::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            project: NestedProject::get(flat_struct.project_id, connection)?,
            item: ItemCategory::get(flat_struct.item_id, connection)?,
            quantity: flat_struct.quantity,
            unit: flat_struct.unit_id.map(|flat_struct| Unit::get(flat_struct, connection)).transpose()?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedProjectDiscreteRequirement {
    pub id: Uuid,
    pub project: NestedProject,
    pub item: ItemCategory,
    pub quantity: f64,
    pub unit: Option<Unit>,
}

impl NestedProjectDiscreteRequirement {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::project_discrete_requirements;
        let flat_struct = ProjectDiscreteRequirement::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            project: NestedProject::get(flat_struct.project_id, connection)?,
            item: ItemCategory::get(flat_struct.item_id, connection)?,
            quantity: flat_struct.quantity,
            unit: flat_struct.unit_id.map(|flat_struct| Unit::get(flat_struct, connection)).transpose()?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedProjectMilestone {
    pub id: Uuid,
    pub project: NestedProject,
    pub due_date: NaiveDateTime,
    pub completed_at: Option<NaiveDateTime>,
}

impl NestedProjectMilestone {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::project_milestones;
        let flat_struct = ProjectMilestone::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            project: NestedProject::get(flat_struct.project_id, connection)?,
            due_date: flat_struct.due_date,
            completed_at: flat_struct.completed_at,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedProject {
    pub id: Uuid,
    pub name: String,
    pub description: String,
    pub public: bool,
    pub state: ProjectState,
    pub parent_project: Option<Box<NestedProject>>,
    pub budget: Option<f64>,
    pub expenses: Option<f64>,
    pub created_by: User,
    pub created_at: NaiveDateTime,
    pub expected_end_date: Option<NaiveDateTime>,
    pub end_date: Option<NaiveDateTime>,
}

impl NestedProject {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::projects;
        let flat_struct = Project::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            name: flat_struct.name,
            description: flat_struct.description,
            public: flat_struct.public,
            state: ProjectState::get(flat_struct.state_id, connection)?,
            parent_project: flat_struct.parent_project_id.map(|flat_struct| NestedProject::get(flat_struct, connection)).transpose()?.map(Box::new),
            budget: flat_struct.budget,
            expenses: flat_struct.expenses,
            created_by: User::get(flat_struct.created_by, connection)?,
            created_at: flat_struct.created_at,
            expected_end_date: flat_struct.expected_end_date,
            end_date: flat_struct.end_date,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedSampleTaxa {
    pub id: Uuid,
    pub sample: NestedSample,
    pub taxon: Taxa,
}

impl NestedSampleTaxa {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::sample_taxa;
        let flat_struct = SampleTaxa::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            sample: NestedSample::get(flat_struct.sample_id, connection)?,
            taxon: Taxa::get(flat_struct.taxon_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedSampledIndividualTaxa {
    pub id: Uuid,
    pub sampled_individual: SampledIndividual,
    pub taxon: Taxa,
}

impl NestedSampledIndividualTaxa {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::sampled_individual_taxa;
        let flat_struct = SampledIndividualTaxa::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            sampled_individual: SampledIndividual::get(flat_struct.sampled_individual_id, connection)?,
            taxon: Taxa::get(flat_struct.taxon_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedSample {
    pub id: Uuid,
    pub derived_from: Option<Box<NestedSample>>,
}

impl NestedSample {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::samples;
        let flat_struct = Sample::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            derived_from: flat_struct.derived_from.map(|flat_struct| NestedSample::get(flat_struct, connection)).transpose()?.map(Box::new),
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedSpectra {
    pub id: Uuid,
    pub spectra_collection: NestedSpectraCollection,
}

impl NestedSpectra {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::spectra;
        let flat_struct = Spectra::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            spectra_collection: NestedSpectraCollection::get(flat_struct.spectra_collection_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedSpectraCollection {
    pub id: Uuid,
    pub sample: NestedSample,
}

impl NestedSpectraCollection {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::spectra_collection;
        let flat_struct = SpectraCollection::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            sample: NestedSample::get(flat_struct.sample_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedTeamAuthorization {
    pub id: Uuid,
    pub team: NestedTeam,
    pub editable: NestedEditable,
    pub role: Role,
}

impl NestedTeamAuthorization {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::team_authorizations;
        let flat_struct = TeamAuthorization::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            editable: NestedEditable::get(flat_struct.editable_id, connection)?,
            role: Role::get(flat_struct.role_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedTeam {
    pub id: Uuid,
    pub parent_team: Option<Box<NestedTeam>>,
    pub team_state: TeamState,
}

impl NestedTeam {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::teams;
        let flat_struct = Team::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            parent_team: flat_struct.parent_team_id.map(|flat_struct| NestedTeam::get(flat_struct, connection)).transpose()?.map(Box::new),
            team_state: TeamState::get(flat_struct.team_state_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedUserAuthorization {
    pub id: Uuid,
    pub user: User,
    pub editable: NestedEditable,
    pub role: Role,
}

impl NestedUserAuthorization {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::user_authorizations;
        let flat_struct = UserAuthorization::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            user: User::get(flat_struct.user_id, connection)?,
            editable: NestedEditable::get(flat_struct.editable_id, connection)?,
            role: Role::get(flat_struct.role_id, connection)?,
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedUserEmail {
    pub id: Uuid,
    pub email: String,
    pub user: User,
    pub login_provider: LoginProvider,
}

impl NestedUserEmail {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error>
    {
        use crate::schema::user_emails;
        let flat_struct = UserEmail::get(id, connection)?;
        Ok(Self {
            id: flat_struct.id,
            email: flat_struct.email,
            user: User::get(flat_struct.user_id, connection)?,
            login_provider: LoginProvider::get(flat_struct.login_provider_id, connection)?,
        })
    }
}
