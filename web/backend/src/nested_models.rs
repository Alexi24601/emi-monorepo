//! This module contains the nested structs for the database tables.
//!
//! This file is automatically generated. Do not write anything here.

use crate::models::*;
use diesel::r2d2::ConnectionManager;
use diesel::r2d2::PooledConnection;
use serde::Deserialize;
use serde::Serialize;
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedArchivable {
    pub inner: Archivable,
    pub archived_by: User,
}

impl NestedArchivable {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Archivable::get(id, connection)?;
        Ok(Self {
            inner: Archivable::get(flat_struct.id, connection)?,
            archived_by: User::get(flat_struct.archived_by, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedArchivable> for NestedArchivable {
    fn from(item: web_common::database::nested_models::NestedArchivable) -> Self {
        Self {
            inner: item.inner.into(),
            archived_by: item.archived_by.into(),
        }
    }
}
impl From<NestedArchivable> for web_common::database::nested_models::NestedArchivable {
    fn from(item: NestedArchivable) -> Self {
        Self {
            inner: item.inner.into(),
            archived_by: item.archived_by.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedContainerHorizontalRule {
    pub inner: ContainerHorizontalRule,
    pub item_type: ItemCategory,
    pub other_item_type: ItemCategory,
}

impl NestedContainerHorizontalRule {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ContainerHorizontalRule::get(id, connection)?;
        Ok(Self {
            inner: ContainerHorizontalRule::get(flat_struct.id, connection)?,
            item_type: ItemCategory::get(flat_struct.item_type_id, connection)?,
            other_item_type: ItemCategory::get(flat_struct.other_item_type_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedContainerHorizontalRule>
    for NestedContainerHorizontalRule
{
    fn from(item: web_common::database::nested_models::NestedContainerHorizontalRule) -> Self {
        Self {
            inner: item.inner.into(),
            item_type: item.item_type.into(),
            other_item_type: item.other_item_type.into(),
        }
    }
}
impl From<NestedContainerHorizontalRule>
    for web_common::database::nested_models::NestedContainerHorizontalRule
{
    fn from(item: NestedContainerHorizontalRule) -> Self {
        Self {
            inner: item.inner.into(),
            item_type: item.item_type.into(),
            other_item_type: item.other_item_type.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedContainerVerticalRule {
    pub inner: ContainerVerticalRule,
    pub container_item_type: ItemCategory,
    pub contained_item_type: ItemCategory,
}

impl NestedContainerVerticalRule {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ContainerVerticalRule::get(id, connection)?;
        Ok(Self {
            inner: ContainerVerticalRule::get(flat_struct.id, connection)?,
            container_item_type: ItemCategory::get(flat_struct.container_item_type_id, connection)?,
            contained_item_type: ItemCategory::get(flat_struct.contained_item_type_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedContainerVerticalRule>
    for NestedContainerVerticalRule
{
    fn from(item: web_common::database::nested_models::NestedContainerVerticalRule) -> Self {
        Self {
            inner: item.inner.into(),
            container_item_type: item.container_item_type.into(),
            contained_item_type: item.contained_item_type.into(),
        }
    }
}
impl From<NestedContainerVerticalRule>
    for web_common::database::nested_models::NestedContainerVerticalRule
{
    fn from(item: NestedContainerVerticalRule) -> Self {
        Self {
            inner: item.inner.into(),
            container_item_type: item.container_item_type.into(),
            contained_item_type: item.contained_item_type.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedDocument {
    pub inner: Document,
    pub format: DocumentFormat,
}

impl NestedDocument {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Document::get(id, connection)?;
        Ok(Self {
            inner: Document::get(flat_struct.id, connection)?,
            format: DocumentFormat::get(flat_struct.format_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedDocument> for NestedDocument {
    fn from(item: web_common::database::nested_models::NestedDocument) -> Self {
        Self {
            inner: item.inner.into(),
            format: item.format.into(),
        }
    }
}
impl From<NestedDocument> for web_common::database::nested_models::NestedDocument {
    fn from(item: NestedDocument) -> Self {
        Self {
            inner: item.inner.into(),
            format: item.format.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedEditable {
    pub inner: Editable,
    pub created_by: User,
}

impl NestedEditable {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Editable::get(id, connection)?;
        Ok(Self {
            inner: Editable::get(flat_struct.id, connection)?,
            created_by: User::get(flat_struct.created_by, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedEditable> for NestedEditable {
    fn from(item: web_common::database::nested_models::NestedEditable) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
        }
    }
}
impl From<NestedEditable> for web_common::database::nested_models::NestedEditable {
    fn from(item: NestedEditable) -> Self {
        Self {
            inner: item.inner.into(),
            created_by: item.created_by.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedEdit {
    pub inner: Edit,
    pub editable: NestedEditable,
}

impl NestedEdit {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Edit::get(id, connection)?;
        Ok(Self {
            inner: Edit::get(flat_struct.id, connection)?,
            editable: NestedEditable::get(flat_struct.editable_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedEdit> for NestedEdit {
    fn from(item: web_common::database::nested_models::NestedEdit) -> Self {
        Self {
            inner: item.inner.into(),
            editable: item.editable.into(),
        }
    }
}
impl From<NestedEdit> for web_common::database::nested_models::NestedEdit {
    fn from(item: NestedEdit) -> Self {
        Self {
            inner: item.inner.into(),
            editable: item.editable.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedItemCategoryRelationship {
    pub inner: ItemCategoryRelationship,
    pub parent: ItemCategory,
    pub child: ItemCategory,
}

impl NestedItemCategoryRelationship {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ItemCategoryRelationship::get(id, connection)?;
        Ok(Self {
            inner: ItemCategoryRelationship::get(flat_struct.id, connection)?,
            parent: ItemCategory::get(flat_struct.parent_id, connection)?,
            child: ItemCategory::get(flat_struct.child_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedItemCategoryRelationship>
    for NestedItemCategoryRelationship
{
    fn from(item: web_common::database::nested_models::NestedItemCategoryRelationship) -> Self {
        Self {
            inner: item.inner.into(),
            parent: item.parent.into(),
            child: item.child.into(),
        }
    }
}
impl From<NestedItemCategoryRelationship>
    for web_common::database::nested_models::NestedItemCategoryRelationship
{
    fn from(item: NestedItemCategoryRelationship) -> Self {
        Self {
            inner: item.inner.into(),
            parent: item.parent.into(),
            child: item.child.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedItemCategoryUnit {
    pub inner: ItemCategoryUnit,
    pub item_category: ItemCategory,
    pub unit: Unit,
}

impl NestedItemCategoryUnit {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ItemCategoryUnit::get(id, connection)?;
        Ok(Self {
            inner: ItemCategoryUnit::get(flat_struct.id, connection)?,
            item_category: ItemCategory::get(flat_struct.item_category_id, connection)?,
            unit: Unit::get(flat_struct.unit_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedItemCategoryUnit> for NestedItemCategoryUnit {
    fn from(item: web_common::database::nested_models::NestedItemCategoryUnit) -> Self {
        Self {
            inner: item.inner.into(),
            item_category: item.item_category.into(),
            unit: item.unit.into(),
        }
    }
}
impl From<NestedItemCategoryUnit> for web_common::database::nested_models::NestedItemCategoryUnit {
    fn from(item: NestedItemCategoryUnit) -> Self {
        Self {
            inner: item.inner.into(),
            item_category: item.item_category.into(),
            unit: item.unit.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedItemContinuousQuantity {
    pub inner: ItemContinuousQuantity,
    pub item: NestedItem,
    pub unit: Unit,
    pub sensor: Option<NestedItem>,
    pub measured_by: Option<User>,
}

impl NestedItemContinuousQuantity {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ItemContinuousQuantity::get(id, connection)?;
        Ok(Self {
            inner: ItemContinuousQuantity::get(flat_struct.id, connection)?,
            item: NestedItem::get(flat_struct.item_id, connection)?,
            unit: Unit::get(flat_struct.unit_id, connection)?,
            sensor: flat_struct
                .sensor_id
                .map(|flat_struct| NestedItem::get(flat_struct, connection))
                .transpose()?,
            measured_by: flat_struct
                .measured_by
                .map(|flat_struct| User::get(flat_struct, connection))
                .transpose()?,
        })
    }
}
impl From<web_common::database::nested_models::NestedItemContinuousQuantity>
    for NestedItemContinuousQuantity
{
    fn from(item: web_common::database::nested_models::NestedItemContinuousQuantity) -> Self {
        Self {
            inner: item.inner.into(),
            item: item.item.into(),
            unit: item.unit.into(),
            sensor: item.sensor.map(|item| item.into()),
            measured_by: item.measured_by.map(|item| item.into()),
        }
    }
}
impl From<NestedItemContinuousQuantity>
    for web_common::database::nested_models::NestedItemContinuousQuantity
{
    fn from(item: NestedItemContinuousQuantity) -> Self {
        Self {
            inner: item.inner.into(),
            item: item.item.into(),
            unit: item.unit.into(),
            sensor: item.sensor.map(|item| item.into()),
            measured_by: item.measured_by.map(|item| item.into()),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedItemDiscreteQuantity {
    pub inner: ItemDiscreteQuantity,
    pub item: NestedItem,
    pub unit: Unit,
    pub measured_by: Option<User>,
}

impl NestedItemDiscreteQuantity {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ItemDiscreteQuantity::get(id, connection)?;
        Ok(Self {
            inner: ItemDiscreteQuantity::get(flat_struct.id, connection)?,
            item: NestedItem::get(flat_struct.item_id, connection)?,
            unit: Unit::get(flat_struct.unit_id, connection)?,
            measured_by: flat_struct
                .measured_by
                .map(|flat_struct| User::get(flat_struct, connection))
                .transpose()?,
        })
    }
}
impl From<web_common::database::nested_models::NestedItemDiscreteQuantity>
    for NestedItemDiscreteQuantity
{
    fn from(item: web_common::database::nested_models::NestedItemDiscreteQuantity) -> Self {
        Self {
            inner: item.inner.into(),
            item: item.item.into(),
            unit: item.unit.into(),
            measured_by: item.measured_by.map(|item| item.into()),
        }
    }
}
impl From<NestedItemDiscreteQuantity>
    for web_common::database::nested_models::NestedItemDiscreteQuantity
{
    fn from(item: NestedItemDiscreteQuantity) -> Self {
        Self {
            inner: item.inner.into(),
            item: item.item.into(),
            unit: item.unit.into(),
            measured_by: item.measured_by.map(|item| item.into()),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedItemLocation {
    pub inner: ItemLocation,
    pub item: Option<NestedItem>,
    pub location: Option<NestedLocation>,
    pub previous_location: Option<NestedLocation>,
}

impl NestedItemLocation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ItemLocation::get(id, connection)?;
        Ok(Self {
            inner: ItemLocation::get(flat_struct.id, connection)?,
            item: flat_struct
                .item_id
                .map(|flat_struct| NestedItem::get(flat_struct, connection))
                .transpose()?,
            location: flat_struct
                .location_id
                .map(|flat_struct| NestedLocation::get(flat_struct, connection))
                .transpose()?,
            previous_location: flat_struct
                .previous_location_id
                .map(|flat_struct| NestedLocation::get(flat_struct, connection))
                .transpose()?,
        })
    }
}
impl From<web_common::database::nested_models::NestedItemLocation> for NestedItemLocation {
    fn from(item: web_common::database::nested_models::NestedItemLocation) -> Self {
        Self {
            inner: item.inner.into(),
            item: item.item.map(|item| item.into()),
            location: item.location.map(|item| item.into()),
            previous_location: item.previous_location.map(|item| item.into()),
        }
    }
}
impl From<NestedItemLocation> for web_common::database::nested_models::NestedItemLocation {
    fn from(item: NestedItemLocation) -> Self {
        Self {
            inner: item.inner.into(),
            item: item.item.map(|item| item.into()),
            location: item.location.map(|item| item.into()),
            previous_location: item.previous_location.map(|item| item.into()),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedItemUnit {
    pub inner: ItemUnit,
    pub item: NestedItem,
    pub unit: Unit,
}

impl NestedItemUnit {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ItemUnit::get(id, connection)?;
        Ok(Self {
            inner: ItemUnit::get(flat_struct.id, connection)?,
            item: NestedItem::get(flat_struct.item_id, connection)?,
            unit: Unit::get(flat_struct.unit_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedItemUnit> for NestedItemUnit {
    fn from(item: web_common::database::nested_models::NestedItemUnit) -> Self {
        Self {
            inner: item.inner.into(),
            item: item.item.into(),
            unit: item.unit.into(),
        }
    }
}
impl From<NestedItemUnit> for web_common::database::nested_models::NestedItemUnit {
    fn from(item: NestedItemUnit) -> Self {
        Self {
            inner: item.inner.into(),
            item: item.item.into(),
            unit: item.unit.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedItem {
    pub inner: Item,
    pub parent: Option<Box<NestedItem>>,
}

impl NestedItem {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Item::get(id, connection)?;
        Ok(Self {
            inner: Item::get(flat_struct.id, connection)?,
            parent: flat_struct
                .parent_id
                .map(|flat_struct| NestedItem::get(flat_struct, connection))
                .transpose()?
                .map(Box::new),
        })
    }
}
impl From<web_common::database::nested_models::NestedItem> for NestedItem {
    fn from(item: web_common::database::nested_models::NestedItem) -> Self {
        Self {
            inner: item.inner.into(),
            parent: item.parent.map(|item| item.into()),
        }
    }
}
impl From<Box<web_common::database::nested_models::NestedItem>> for Box<NestedItem> {
    fn from(item: Box<web_common::database::nested_models::NestedItem>) -> Self {
        Box::new(NestedItem {
            inner: item.inner.into(),
            parent: item.parent.map(|item| item.into()),
        })
    }
}
impl From<NestedItem> for web_common::database::nested_models::NestedItem {
    fn from(item: NestedItem) -> Self {
        Self {
            inner: item.inner.into(),
            parent: item.parent.map(|item| item.into()),
        }
    }
}
impl From<Box<NestedItem>> for Box<web_common::database::nested_models::NestedItem> {
    fn from(item: Box<NestedItem>) -> Self {
        Box::new(web_common::database::nested_models::NestedItem {
            inner: item.inner.into(),
            parent: item.parent.map(|item| item.into()),
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedLocation {
    pub inner: Location,
    pub geolocalization_device: Option<NestedItem>,
    pub altitude_device: Option<NestedItem>,
    pub parent_location: Option<Box<NestedLocation>>,
    pub state: LocationState,
}

impl NestedLocation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Location::get(id, connection)?;
        Ok(Self {
            inner: Location::get(flat_struct.id, connection)?,
            geolocalization_device: flat_struct
                .geolocalization_device_id
                .map(|flat_struct| NestedItem::get(flat_struct, connection))
                .transpose()?,
            altitude_device: flat_struct
                .altitude_device_id
                .map(|flat_struct| NestedItem::get(flat_struct, connection))
                .transpose()?,
            parent_location: flat_struct
                .parent_location_id
                .map(|flat_struct| NestedLocation::get(flat_struct, connection))
                .transpose()?
                .map(Box::new),
            state: LocationState::get(flat_struct.state_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedLocation> for NestedLocation {
    fn from(item: web_common::database::nested_models::NestedLocation) -> Self {
        Self {
            inner: item.inner.into(),
            geolocalization_device: item.geolocalization_device.map(|item| item.into()),
            altitude_device: item.altitude_device.map(|item| item.into()),
            parent_location: item.parent_location.map(|item| item.into()),
            state: item.state.into(),
        }
    }
}
impl From<Box<web_common::database::nested_models::NestedLocation>> for Box<NestedLocation> {
    fn from(item: Box<web_common::database::nested_models::NestedLocation>) -> Self {
        Box::new(NestedLocation {
            inner: item.inner.into(),
            geolocalization_device: item.geolocalization_device.map(|item| item.into()),
            altitude_device: item.altitude_device.map(|item| item.into()),
            parent_location: item.parent_location.map(|item| item.into()),
            state: item.state.into(),
        })
    }
}
impl From<NestedLocation> for web_common::database::nested_models::NestedLocation {
    fn from(item: NestedLocation) -> Self {
        Self {
            inner: item.inner.into(),
            geolocalization_device: item.geolocalization_device.map(|item| item.into()),
            altitude_device: item.altitude_device.map(|item| item.into()),
            parent_location: item.parent_location.map(|item| item.into()),
            state: item.state.into(),
        }
    }
}
impl From<Box<NestedLocation>> for Box<web_common::database::nested_models::NestedLocation> {
    fn from(item: Box<NestedLocation>) -> Self {
        Box::new(web_common::database::nested_models::NestedLocation {
            inner: item.inner.into(),
            geolocalization_device: item.geolocalization_device.map(|item| item.into()),
            altitude_device: item.altitude_device.map(|item| item.into()),
            parent_location: item.parent_location.map(|item| item.into()),
            state: item.state.into(),
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedManufacturedItemCategory {
    pub inner: ManufacturedItemCategory,
    pub manifacturer: NestedOrganization,
}

impl NestedManufacturedItemCategory {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ManufacturedItemCategory::get(id, connection)?;
        Ok(Self {
            inner: ManufacturedItemCategory::get(flat_struct.id, connection)?,
            manifacturer: NestedOrganization::get(flat_struct.manifacturer_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedManufacturedItemCategory>
    for NestedManufacturedItemCategory
{
    fn from(item: web_common::database::nested_models::NestedManufacturedItemCategory) -> Self {
        Self {
            inner: item.inner.into(),
            manifacturer: item.manifacturer.into(),
        }
    }
}
impl From<NestedManufacturedItemCategory>
    for web_common::database::nested_models::NestedManufacturedItemCategory
{
    fn from(item: NestedManufacturedItemCategory) -> Self {
        Self {
            inner: item.inner.into(),
            manifacturer: item.manifacturer.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedNotification {
    pub inner: Notification,
    pub user: User,
    pub row: Option<NestedEditable>,
}

impl NestedNotification {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Notification::get(id, connection)?;
        Ok(Self {
            inner: Notification::get(flat_struct.id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            row: flat_struct
                .row_id
                .map(|flat_struct| NestedEditable::get(flat_struct, connection))
                .transpose()?,
        })
    }
}
impl From<web_common::database::nested_models::NestedNotification> for NestedNotification {
    fn from(item: web_common::database::nested_models::NestedNotification) -> Self {
        Self {
            inner: item.inner.into(),
            user: item.user.into(),
            row: item.row.map(|item| item.into()),
        }
    }
}
impl From<NestedNotification> for web_common::database::nested_models::NestedNotification {
    fn from(item: NestedNotification) -> Self {
        Self {
            inner: item.inner.into(),
            user: item.user.into(),
            row: item.row.map(|item| item.into()),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedOrganizationAuthorization {
    pub inner: OrganizationAuthorization,
    pub organization: NestedOrganization,
    pub editable: NestedEditable,
    pub role: Role,
}

impl NestedOrganizationAuthorization {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = OrganizationAuthorization::get(id, connection)?;
        Ok(Self {
            inner: OrganizationAuthorization::get(flat_struct.id, connection)?,
            organization: NestedOrganization::get(flat_struct.organization_id, connection)?,
            editable: NestedEditable::get(flat_struct.editable_id, connection)?,
            role: Role::get(flat_struct.role_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedOrganizationAuthorization>
    for NestedOrganizationAuthorization
{
    fn from(item: web_common::database::nested_models::NestedOrganizationAuthorization) -> Self {
        Self {
            inner: item.inner.into(),
            organization: item.organization.into(),
            editable: item.editable.into(),
            role: item.role.into(),
        }
    }
}
impl From<NestedOrganizationAuthorization>
    for web_common::database::nested_models::NestedOrganizationAuthorization
{
    fn from(item: NestedOrganizationAuthorization) -> Self {
        Self {
            inner: item.inner.into(),
            organization: item.organization.into(),
            editable: item.editable.into(),
            role: item.role.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedOrganizationLocation {
    pub inner: OrganizationLocation,
    pub organization: Option<NestedOrganization>,
    pub location: Option<NestedLocation>,
    pub previous_location: Option<Box<NestedOrganizationLocation>>,
}

impl NestedOrganizationLocation {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = OrganizationLocation::get(id, connection)?;
        Ok(Self {
            inner: OrganizationLocation::get(flat_struct.id, connection)?,
            organization: flat_struct
                .organization_id
                .map(|flat_struct| NestedOrganization::get(flat_struct, connection))
                .transpose()?,
            location: flat_struct
                .location_id
                .map(|flat_struct| NestedLocation::get(flat_struct, connection))
                .transpose()?,
            previous_location: flat_struct
                .previous_location_id
                .map(|flat_struct| NestedOrganizationLocation::get(flat_struct, connection))
                .transpose()?
                .map(Box::new),
        })
    }
}
impl From<web_common::database::nested_models::NestedOrganizationLocation>
    for NestedOrganizationLocation
{
    fn from(item: web_common::database::nested_models::NestedOrganizationLocation) -> Self {
        Self {
            inner: item.inner.into(),
            organization: item.organization.map(|item| item.into()),
            location: item.location.map(|item| item.into()),
            previous_location: item.previous_location.map(|item| item.into()),
        }
    }
}
impl From<Box<web_common::database::nested_models::NestedOrganizationLocation>>
    for Box<NestedOrganizationLocation>
{
    fn from(item: Box<web_common::database::nested_models::NestedOrganizationLocation>) -> Self {
        Box::new(NestedOrganizationLocation {
            inner: item.inner.into(),
            organization: item.organization.map(|item| item.into()),
            location: item.location.map(|item| item.into()),
            previous_location: item.previous_location.map(|item| item.into()),
        })
    }
}
impl From<NestedOrganizationLocation>
    for web_common::database::nested_models::NestedOrganizationLocation
{
    fn from(item: NestedOrganizationLocation) -> Self {
        Self {
            inner: item.inner.into(),
            organization: item.organization.map(|item| item.into()),
            location: item.location.map(|item| item.into()),
            previous_location: item.previous_location.map(|item| item.into()),
        }
    }
}
impl From<Box<NestedOrganizationLocation>>
    for Box<web_common::database::nested_models::NestedOrganizationLocation>
{
    fn from(item: Box<NestedOrganizationLocation>) -> Self {
        Box::new(
            web_common::database::nested_models::NestedOrganizationLocation {
                inner: item.inner.into(),
                organization: item.organization.map(|item| item.into()),
                location: item.location.map(|item| item.into()),
                previous_location: item.previous_location.map(|item| item.into()),
            },
        )
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedOrganization {
    pub inner: Organization,
    pub state: Option<OrganizationState>,
    pub parent_organization: Option<Box<NestedOrganization>>,
    pub logo: Option<NestedDocument>,
}

impl NestedOrganization {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Organization::get(id, connection)?;
        Ok(Self {
            inner: Organization::get(flat_struct.id, connection)?,
            state: flat_struct
                .state_id
                .map(|flat_struct| OrganizationState::get(flat_struct, connection))
                .transpose()?,
            parent_organization: flat_struct
                .parent_organization_id
                .map(|flat_struct| NestedOrganization::get(flat_struct, connection))
                .transpose()?
                .map(Box::new),
            logo: flat_struct
                .logo_id
                .map(|flat_struct| NestedDocument::get(flat_struct, connection))
                .transpose()?,
        })
    }
}
impl From<web_common::database::nested_models::NestedOrganization> for NestedOrganization {
    fn from(item: web_common::database::nested_models::NestedOrganization) -> Self {
        Self {
            inner: item.inner.into(),
            state: item.state.map(|item| item.into()),
            parent_organization: item.parent_organization.map(|item| item.into()),
            logo: item.logo.map(|item| item.into()),
        }
    }
}
impl From<Box<web_common::database::nested_models::NestedOrganization>>
    for Box<NestedOrganization>
{
    fn from(item: Box<web_common::database::nested_models::NestedOrganization>) -> Self {
        Box::new(NestedOrganization {
            inner: item.inner.into(),
            state: item.state.map(|item| item.into()),
            parent_organization: item.parent_organization.map(|item| item.into()),
            logo: item.logo.map(|item| item.into()),
        })
    }
}
impl From<NestedOrganization> for web_common::database::nested_models::NestedOrganization {
    fn from(item: NestedOrganization) -> Self {
        Self {
            inner: item.inner.into(),
            state: item.state.map(|item| item.into()),
            parent_organization: item.parent_organization.map(|item| item.into()),
            logo: item.logo.map(|item| item.into()),
        }
    }
}
impl From<Box<NestedOrganization>>
    for Box<web_common::database::nested_models::NestedOrganization>
{
    fn from(item: Box<NestedOrganization>) -> Self {
        Box::new(web_common::database::nested_models::NestedOrganization {
            inner: item.inner.into(),
            state: item.state.map(|item| item.into()),
            parent_organization: item.parent_organization.map(|item| item.into()),
            logo: item.logo.map(|item| item.into()),
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedProcedureContinuousRequirement {
    pub inner: ProcedureContinuousRequirement,
    pub procedure: Procedure,
    pub item_category: ItemCategory,
    pub unit: Option<Unit>,
}

impl NestedProcedureContinuousRequirement {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ProcedureContinuousRequirement::get(id, connection)?;
        Ok(Self {
            inner: ProcedureContinuousRequirement::get(flat_struct.id, connection)?,
            procedure: Procedure::get(flat_struct.procedure_id, connection)?,
            item_category: ItemCategory::get(flat_struct.item_category_id, connection)?,
            unit: flat_struct
                .unit_id
                .map(|flat_struct| Unit::get(flat_struct, connection))
                .transpose()?,
        })
    }
}
impl From<web_common::database::nested_models::NestedProcedureContinuousRequirement>
    for NestedProcedureContinuousRequirement
{
    fn from(
        item: web_common::database::nested_models::NestedProcedureContinuousRequirement,
    ) -> Self {
        Self {
            inner: item.inner.into(),
            procedure: item.procedure.into(),
            item_category: item.item_category.into(),
            unit: item.unit.map(|item| item.into()),
        }
    }
}
impl From<NestedProcedureContinuousRequirement>
    for web_common::database::nested_models::NestedProcedureContinuousRequirement
{
    fn from(item: NestedProcedureContinuousRequirement) -> Self {
        Self {
            inner: item.inner.into(),
            procedure: item.procedure.into(),
            item_category: item.item_category.into(),
            unit: item.unit.map(|item| item.into()),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedProcedureDiscreteRequirement {
    pub inner: ProcedureDiscreteRequirement,
    pub procedure: Procedure,
    pub item_category: ItemCategory,
    pub unit: Option<Unit>,
}

impl NestedProcedureDiscreteRequirement {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ProcedureDiscreteRequirement::get(id, connection)?;
        Ok(Self {
            inner: ProcedureDiscreteRequirement::get(flat_struct.id, connection)?,
            procedure: Procedure::get(flat_struct.procedure_id, connection)?,
            item_category: ItemCategory::get(flat_struct.item_category_id, connection)?,
            unit: flat_struct
                .unit_id
                .map(|flat_struct| Unit::get(flat_struct, connection))
                .transpose()?,
        })
    }
}
impl From<web_common::database::nested_models::NestedProcedureDiscreteRequirement>
    for NestedProcedureDiscreteRequirement
{
    fn from(item: web_common::database::nested_models::NestedProcedureDiscreteRequirement) -> Self {
        Self {
            inner: item.inner.into(),
            procedure: item.procedure.into(),
            item_category: item.item_category.into(),
            unit: item.unit.map(|item| item.into()),
        }
    }
}
impl From<NestedProcedureDiscreteRequirement>
    for web_common::database::nested_models::NestedProcedureDiscreteRequirement
{
    fn from(item: NestedProcedureDiscreteRequirement) -> Self {
        Self {
            inner: item.inner.into(),
            procedure: item.procedure.into(),
            item_category: item.item_category.into(),
            unit: item.unit.map(|item| item.into()),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedProjectContinuousRequirement {
    pub inner: ProjectContinuousRequirement,
    pub project: NestedProject,
    pub item: ItemCategory,
    pub unit: Option<Unit>,
}

impl NestedProjectContinuousRequirement {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ProjectContinuousRequirement::get(id, connection)?;
        Ok(Self {
            inner: ProjectContinuousRequirement::get(flat_struct.id, connection)?,
            project: NestedProject::get(flat_struct.project_id, connection)?,
            item: ItemCategory::get(flat_struct.item_id, connection)?,
            unit: flat_struct
                .unit_id
                .map(|flat_struct| Unit::get(flat_struct, connection))
                .transpose()?,
        })
    }
}
impl From<web_common::database::nested_models::NestedProjectContinuousRequirement>
    for NestedProjectContinuousRequirement
{
    fn from(item: web_common::database::nested_models::NestedProjectContinuousRequirement) -> Self {
        Self {
            inner: item.inner.into(),
            project: item.project.into(),
            item: item.item.into(),
            unit: item.unit.map(|item| item.into()),
        }
    }
}
impl From<NestedProjectContinuousRequirement>
    for web_common::database::nested_models::NestedProjectContinuousRequirement
{
    fn from(item: NestedProjectContinuousRequirement) -> Self {
        Self {
            inner: item.inner.into(),
            project: item.project.into(),
            item: item.item.into(),
            unit: item.unit.map(|item| item.into()),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct NestedProjectDiscreteRequirement {
    pub inner: ProjectDiscreteRequirement,
    pub project: NestedProject,
    pub item: ItemCategory,
    pub unit: Option<Unit>,
}

impl NestedProjectDiscreteRequirement {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ProjectDiscreteRequirement::get(id, connection)?;
        Ok(Self {
            inner: ProjectDiscreteRequirement::get(flat_struct.id, connection)?,
            project: NestedProject::get(flat_struct.project_id, connection)?,
            item: ItemCategory::get(flat_struct.item_id, connection)?,
            unit: flat_struct
                .unit_id
                .map(|flat_struct| Unit::get(flat_struct, connection))
                .transpose()?,
        })
    }
}
impl From<web_common::database::nested_models::NestedProjectDiscreteRequirement>
    for NestedProjectDiscreteRequirement
{
    fn from(item: web_common::database::nested_models::NestedProjectDiscreteRequirement) -> Self {
        Self {
            inner: item.inner.into(),
            project: item.project.into(),
            item: item.item.into(),
            unit: item.unit.map(|item| item.into()),
        }
    }
}
impl From<NestedProjectDiscreteRequirement>
    for web_common::database::nested_models::NestedProjectDiscreteRequirement
{
    fn from(item: NestedProjectDiscreteRequirement) -> Self {
        Self {
            inner: item.inner.into(),
            project: item.project.into(),
            item: item.item.into(),
            unit: item.unit.map(|item| item.into()),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedProjectMilestone {
    pub inner: ProjectMilestone,
    pub project: NestedProject,
}

impl NestedProjectMilestone {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = ProjectMilestone::get(id, connection)?;
        Ok(Self {
            inner: ProjectMilestone::get(flat_struct.id, connection)?,
            project: NestedProject::get(flat_struct.project_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedProjectMilestone> for NestedProjectMilestone {
    fn from(item: web_common::database::nested_models::NestedProjectMilestone) -> Self {
        Self {
            inner: item.inner.into(),
            project: item.project.into(),
        }
    }
}
impl From<NestedProjectMilestone> for web_common::database::nested_models::NestedProjectMilestone {
    fn from(item: NestedProjectMilestone) -> Self {
        Self {
            inner: item.inner.into(),
            project: item.project.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedProject {
    pub inner: Project,
    pub state: ProjectState,
    pub parent_project: Option<Box<NestedProject>>,
    pub created_by: User,
}

impl NestedProject {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Project::get(id, connection)?;
        Ok(Self {
            inner: Project::get(flat_struct.id, connection)?,
            state: ProjectState::get(flat_struct.state_id, connection)?,
            parent_project: flat_struct
                .parent_project_id
                .map(|flat_struct| NestedProject::get(flat_struct, connection))
                .transpose()?
                .map(Box::new),
            created_by: User::get(flat_struct.created_by, connection)?,
        })
    }
}
impl NestedProject {
    /// Search the table by the query.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    /// * `threshold` - The similarity threshold, by default `0.6`.
    pub fn search(
        query: &str,
        limit: Option<i32>,
        threshold: Option<f64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Vec<Self>, diesel::result::Error> {
        let flat_structs = Project::search(query, limit, threshold, connection)?;
        let mut nested_structs = Vec::new();
        for flat_struct in flat_structs {
            nested_structs.push(Self::get(flat_struct.id, connection)?);
        }
        Ok(nested_structs)
    }
}
impl From<web_common::database::nested_models::NestedProject> for NestedProject {
    fn from(item: web_common::database::nested_models::NestedProject) -> Self {
        Self {
            inner: item.inner.into(),
            state: item.state.into(),
            parent_project: item.parent_project.map(|item| item.into()),
            created_by: item.created_by.into(),
        }
    }
}
impl From<Box<web_common::database::nested_models::NestedProject>> for Box<NestedProject> {
    fn from(item: Box<web_common::database::nested_models::NestedProject>) -> Self {
        Box::new(NestedProject {
            inner: item.inner.into(),
            state: item.state.into(),
            parent_project: item.parent_project.map(|item| item.into()),
            created_by: item.created_by.into(),
        })
    }
}
impl From<NestedProject> for web_common::database::nested_models::NestedProject {
    fn from(item: NestedProject) -> Self {
        Self {
            inner: item.inner.into(),
            state: item.state.into(),
            parent_project: item.parent_project.map(|item| item.into()),
            created_by: item.created_by.into(),
        }
    }
}
impl From<Box<NestedProject>> for Box<web_common::database::nested_models::NestedProject> {
    fn from(item: Box<NestedProject>) -> Self {
        Box::new(web_common::database::nested_models::NestedProject {
            inner: item.inner.into(),
            state: item.state.into(),
            parent_project: item.parent_project.map(|item| item.into()),
            created_by: item.created_by.into(),
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedSampleTaxa {
    pub inner: SampleTaxa,
    pub sample: NestedSample,
    pub taxon: Taxa,
}

impl NestedSampleTaxa {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = SampleTaxa::get(id, connection)?;
        Ok(Self {
            inner: SampleTaxa::get(flat_struct.id, connection)?,
            sample: NestedSample::get(flat_struct.sample_id, connection)?,
            taxon: Taxa::get(flat_struct.taxon_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedSampleTaxa> for NestedSampleTaxa {
    fn from(item: web_common::database::nested_models::NestedSampleTaxa) -> Self {
        Self {
            inner: item.inner.into(),
            sample: item.sample.into(),
            taxon: item.taxon.into(),
        }
    }
}
impl From<NestedSampleTaxa> for web_common::database::nested_models::NestedSampleTaxa {
    fn from(item: NestedSampleTaxa) -> Self {
        Self {
            inner: item.inner.into(),
            sample: item.sample.into(),
            taxon: item.taxon.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedSampledIndividualTaxa {
    pub inner: SampledIndividualTaxa,
    pub sampled_individual: SampledIndividual,
    pub taxon: Taxa,
}

impl NestedSampledIndividualTaxa {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = SampledIndividualTaxa::get(id, connection)?;
        Ok(Self {
            inner: SampledIndividualTaxa::get(flat_struct.id, connection)?,
            sampled_individual: SampledIndividual::get(
                flat_struct.sampled_individual_id,
                connection,
            )?,
            taxon: Taxa::get(flat_struct.taxon_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedSampledIndividualTaxa>
    for NestedSampledIndividualTaxa
{
    fn from(item: web_common::database::nested_models::NestedSampledIndividualTaxa) -> Self {
        Self {
            inner: item.inner.into(),
            sampled_individual: item.sampled_individual.into(),
            taxon: item.taxon.into(),
        }
    }
}
impl From<NestedSampledIndividualTaxa>
    for web_common::database::nested_models::NestedSampledIndividualTaxa
{
    fn from(item: NestedSampledIndividualTaxa) -> Self {
        Self {
            inner: item.inner.into(),
            sampled_individual: item.sampled_individual.into(),
            taxon: item.taxon.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedSample {
    pub inner: Sample,
    pub derived_from: Option<Box<NestedSample>>,
}

impl NestedSample {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Sample::get(id, connection)?;
        Ok(Self {
            inner: Sample::get(flat_struct.id, connection)?,
            derived_from: flat_struct
                .derived_from
                .map(|flat_struct| NestedSample::get(flat_struct, connection))
                .transpose()?
                .map(Box::new),
        })
    }
}
impl From<web_common::database::nested_models::NestedSample> for NestedSample {
    fn from(item: web_common::database::nested_models::NestedSample) -> Self {
        Self {
            inner: item.inner.into(),
            derived_from: item.derived_from.map(|item| item.into()),
        }
    }
}
impl From<Box<web_common::database::nested_models::NestedSample>> for Box<NestedSample> {
    fn from(item: Box<web_common::database::nested_models::NestedSample>) -> Self {
        Box::new(NestedSample {
            inner: item.inner.into(),
            derived_from: item.derived_from.map(|item| item.into()),
        })
    }
}
impl From<NestedSample> for web_common::database::nested_models::NestedSample {
    fn from(item: NestedSample) -> Self {
        Self {
            inner: item.inner.into(),
            derived_from: item.derived_from.map(|item| item.into()),
        }
    }
}
impl From<Box<NestedSample>> for Box<web_common::database::nested_models::NestedSample> {
    fn from(item: Box<NestedSample>) -> Self {
        Box::new(web_common::database::nested_models::NestedSample {
            inner: item.inner.into(),
            derived_from: item.derived_from.map(|item| item.into()),
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedSpectra {
    pub inner: Spectra,
    pub spectra_collection: NestedSpectraCollection,
}

impl NestedSpectra {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Spectra::get(id, connection)?;
        Ok(Self {
            inner: Spectra::get(flat_struct.id, connection)?,
            spectra_collection: NestedSpectraCollection::get(
                flat_struct.spectra_collection_id,
                connection,
            )?,
        })
    }
}
impl From<web_common::database::nested_models::NestedSpectra> for NestedSpectra {
    fn from(item: web_common::database::nested_models::NestedSpectra) -> Self {
        Self {
            inner: item.inner.into(),
            spectra_collection: item.spectra_collection.into(),
        }
    }
}
impl From<NestedSpectra> for web_common::database::nested_models::NestedSpectra {
    fn from(item: NestedSpectra) -> Self {
        Self {
            inner: item.inner.into(),
            spectra_collection: item.spectra_collection.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedSpectraCollection {
    pub inner: SpectraCollection,
    pub sample: NestedSample,
}

impl NestedSpectraCollection {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = SpectraCollection::get(id, connection)?;
        Ok(Self {
            inner: SpectraCollection::get(flat_struct.id, connection)?,
            sample: NestedSample::get(flat_struct.sample_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedSpectraCollection>
    for NestedSpectraCollection
{
    fn from(item: web_common::database::nested_models::NestedSpectraCollection) -> Self {
        Self {
            inner: item.inner.into(),
            sample: item.sample.into(),
        }
    }
}
impl From<NestedSpectraCollection>
    for web_common::database::nested_models::NestedSpectraCollection
{
    fn from(item: NestedSpectraCollection) -> Self {
        Self {
            inner: item.inner.into(),
            sample: item.sample.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedTeamAuthorization {
    pub inner: TeamAuthorization,
    pub team: NestedTeam,
    pub editable: NestedEditable,
    pub role: Role,
}

impl NestedTeamAuthorization {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = TeamAuthorization::get(id, connection)?;
        Ok(Self {
            inner: TeamAuthorization::get(flat_struct.id, connection)?,
            team: NestedTeam::get(flat_struct.team_id, connection)?,
            editable: NestedEditable::get(flat_struct.editable_id, connection)?,
            role: Role::get(flat_struct.role_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedTeamAuthorization>
    for NestedTeamAuthorization
{
    fn from(item: web_common::database::nested_models::NestedTeamAuthorization) -> Self {
        Self {
            inner: item.inner.into(),
            team: item.team.into(),
            editable: item.editable.into(),
            role: item.role.into(),
        }
    }
}
impl From<NestedTeamAuthorization>
    for web_common::database::nested_models::NestedTeamAuthorization
{
    fn from(item: NestedTeamAuthorization) -> Self {
        Self {
            inner: item.inner.into(),
            team: item.team.into(),
            editable: item.editable.into(),
            role: item.role.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedTeam {
    pub inner: Team,
    pub parent_team: Option<Box<NestedTeam>>,
    pub team_state: TeamState,
}

impl NestedTeam {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = Team::get(id, connection)?;
        Ok(Self {
            inner: Team::get(flat_struct.id, connection)?,
            parent_team: flat_struct
                .parent_team_id
                .map(|flat_struct| NestedTeam::get(flat_struct, connection))
                .transpose()?
                .map(Box::new),
            team_state: TeamState::get(flat_struct.team_state_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedTeam> for NestedTeam {
    fn from(item: web_common::database::nested_models::NestedTeam) -> Self {
        Self {
            inner: item.inner.into(),
            parent_team: item.parent_team.map(|item| item.into()),
            team_state: item.team_state.into(),
        }
    }
}
impl From<Box<web_common::database::nested_models::NestedTeam>> for Box<NestedTeam> {
    fn from(item: Box<web_common::database::nested_models::NestedTeam>) -> Self {
        Box::new(NestedTeam {
            inner: item.inner.into(),
            parent_team: item.parent_team.map(|item| item.into()),
            team_state: item.team_state.into(),
        })
    }
}
impl From<NestedTeam> for web_common::database::nested_models::NestedTeam {
    fn from(item: NestedTeam) -> Self {
        Self {
            inner: item.inner.into(),
            parent_team: item.parent_team.map(|item| item.into()),
            team_state: item.team_state.into(),
        }
    }
}
impl From<Box<NestedTeam>> for Box<web_common::database::nested_models::NestedTeam> {
    fn from(item: Box<NestedTeam>) -> Self {
        Box::new(web_common::database::nested_models::NestedTeam {
            inner: item.inner.into(),
            parent_team: item.parent_team.map(|item| item.into()),
            team_state: item.team_state.into(),
        })
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedUserAuthorization {
    pub inner: UserAuthorization,
    pub user: User,
    pub editable: NestedEditable,
    pub role: Role,
}

impl NestedUserAuthorization {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = UserAuthorization::get(id, connection)?;
        Ok(Self {
            inner: UserAuthorization::get(flat_struct.id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            editable: NestedEditable::get(flat_struct.editable_id, connection)?,
            role: Role::get(flat_struct.role_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedUserAuthorization>
    for NestedUserAuthorization
{
    fn from(item: web_common::database::nested_models::NestedUserAuthorization) -> Self {
        Self {
            inner: item.inner.into(),
            user: item.user.into(),
            editable: item.editable.into(),
            role: item.role.into(),
        }
    }
}
impl From<NestedUserAuthorization>
    for web_common::database::nested_models::NestedUserAuthorization
{
    fn from(item: NestedUserAuthorization) -> Self {
        Self {
            inner: item.inner.into(),
            user: item.user.into(),
            editable: item.editable.into(),
            role: item.role.into(),
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct NestedUserEmail {
    pub inner: UserEmail,
    pub user: User,
    pub login_provider: LoginProvider,
}

impl NestedUserEmail {
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub fn get(
        id: uuid::Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,
    ) -> Result<Self, diesel::result::Error> {
        let flat_struct = UserEmail::get(id, connection)?;
        Ok(Self {
            inner: UserEmail::get(flat_struct.id, connection)?,
            user: User::get(flat_struct.user_id, connection)?,
            login_provider: LoginProvider::get(flat_struct.login_provider_id, connection)?,
        })
    }
}
impl From<web_common::database::nested_models::NestedUserEmail> for NestedUserEmail {
    fn from(item: web_common::database::nested_models::NestedUserEmail) -> Self {
        Self {
            inner: item.inner.into(),
            user: item.user.into(),
            login_provider: item.login_provider.into(),
        }
    }
}
impl From<NestedUserEmail> for web_common::database::nested_models::NestedUserEmail {
    fn from(item: NestedUserEmail) -> Self {
        Self {
            inner: item.inner.into(),
            user: item.user.into(),
            login_provider: item.login_provider.into(),
        }
    }
}
