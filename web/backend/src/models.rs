// Generated by diesel_ext

#![allow(unused)]
#![allow(clippy::all)]
use diesel::prelude::*;
use diesel::r2d2::PooledConnection;
use diesel::r2d2::ConnectionManager;
use serde::Serialize;
use serde::Deserialize;
use diesel::Selectable;
use crate::schema::*;
use diesel::Insertable;
use diesel::Identifiable;
use diesel::QueryableByName;
use diesel::Queryable;


use chrono::NaiveDateTime;
use uuid::Uuid;
#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = archivables)]
pub struct Archivable {
    pub id: Uuid,
    pub archived_at: NaiveDateTime,
    pub archived_by: Uuid,
}

impl From<Archivable> for web_common::database::tables::Archivable {
    fn from(item: Archivable) -> Self {
        Self {
            id: item.id,
            archived_at: item.archived_at,
            archived_by: item.archived_by,
        }
    }
}

impl From<web_common::database::tables::Archivable> for Archivable {
    fn from(item: web_common::database::tables::Archivable) -> Self {
        Self {
            id: item.id,
            archived_at: item.archived_at,
            archived_by: item.archived_by,
        }
    }
}

impl Archivable {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        archivables::dsl::archivables
            .filter(archivables::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = container_horizontal_rules)]
pub struct ContainerHorizontalRule {
    pub id: Uuid,
    pub item_type_id: Option<Uuid>,
    pub other_item_type_id: Option<Uuid>,
    pub minimum_temperature: Option<f64>,
    pub maximum_temperature: Option<f64>,
    pub minimum_humidity: Option<f64>,
    pub maximum_humidity: Option<f64>,
    pub minimum_pressure: Option<f64>,
    pub maximum_pressure: Option<f64>,
}

impl From<ContainerHorizontalRule> for web_common::database::tables::ContainerHorizontalRule {
    fn from(item: ContainerHorizontalRule) -> Self {
        Self {
            id: item.id,
            item_type_id: item.item_type_id,
            other_item_type_id: item.other_item_type_id,
            minimum_temperature: item.minimum_temperature,
            maximum_temperature: item.maximum_temperature,
            minimum_humidity: item.minimum_humidity,
            maximum_humidity: item.maximum_humidity,
            minimum_pressure: item.minimum_pressure,
            maximum_pressure: item.maximum_pressure,
        }
    }
}

impl From<web_common::database::tables::ContainerHorizontalRule> for ContainerHorizontalRule {
    fn from(item: web_common::database::tables::ContainerHorizontalRule) -> Self {
        Self {
            id: item.id,
            item_type_id: item.item_type_id,
            other_item_type_id: item.other_item_type_id,
            minimum_temperature: item.minimum_temperature,
            maximum_temperature: item.maximum_temperature,
            minimum_humidity: item.minimum_humidity,
            maximum_humidity: item.maximum_humidity,
            minimum_pressure: item.minimum_pressure,
            maximum_pressure: item.maximum_pressure,
        }
    }
}

impl ContainerHorizontalRule {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        container_horizontal_rules::dsl::container_horizontal_rules
            .filter(container_horizontal_rules::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = container_vertical_rules)]
pub struct ContainerVerticalRule {
    pub id: Uuid,
    pub container_item_type_id: Option<Uuid>,
    pub contained_item_type_id: Option<Uuid>,
    pub minimum_temperature: Option<f64>,
    pub maximum_temperature: Option<f64>,
    pub minimum_humidity: Option<f64>,
    pub maximum_humidity: Option<f64>,
    pub minimum_pressure: Option<f64>,
    pub maximum_pressure: Option<f64>,
}

impl From<ContainerVerticalRule> for web_common::database::tables::ContainerVerticalRule {
    fn from(item: ContainerVerticalRule) -> Self {
        Self {
            id: item.id,
            container_item_type_id: item.container_item_type_id,
            contained_item_type_id: item.contained_item_type_id,
            minimum_temperature: item.minimum_temperature,
            maximum_temperature: item.maximum_temperature,
            minimum_humidity: item.minimum_humidity,
            maximum_humidity: item.maximum_humidity,
            minimum_pressure: item.minimum_pressure,
            maximum_pressure: item.maximum_pressure,
        }
    }
}

impl From<web_common::database::tables::ContainerVerticalRule> for ContainerVerticalRule {
    fn from(item: web_common::database::tables::ContainerVerticalRule) -> Self {
        Self {
            id: item.id,
            container_item_type_id: item.container_item_type_id,
            contained_item_type_id: item.contained_item_type_id,
            minimum_temperature: item.minimum_temperature,
            maximum_temperature: item.maximum_temperature,
            minimum_humidity: item.minimum_humidity,
            maximum_humidity: item.maximum_humidity,
            minimum_pressure: item.minimum_pressure,
            maximum_pressure: item.maximum_pressure,
        }
    }
}

impl ContainerVerticalRule {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        container_vertical_rules::dsl::container_vertical_rules
            .filter(container_vertical_rules::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = continuous_units)]
pub struct ContinuousUnit {
    pub id: Uuid,
}

impl From<ContinuousUnit> for web_common::database::tables::ContinuousUnit {
    fn from(item: ContinuousUnit) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl From<web_common::database::tables::ContinuousUnit> for ContinuousUnit {
    fn from(item: web_common::database::tables::ContinuousUnit) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl ContinuousUnit {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        continuous_units::dsl::continuous_units
            .filter(continuous_units::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = describables)]
pub struct Describable {
    pub id: Uuid,
    pub name: String,
    pub description: Option<String>,
}

impl From<Describable> for web_common::database::tables::Describable {
    fn from(item: Describable) -> Self {
        Self {
            id: item.id,
            name: item.name,
            description: item.description,
        }
    }
}

impl From<web_common::database::tables::Describable> for Describable {
    fn from(item: web_common::database::tables::Describable) -> Self {
        Self {
            id: item.id,
            name: item.name,
            description: item.description,
        }
    }
}

impl Describable {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        describables::dsl::describables
            .filter(describables::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = discrete_units)]
pub struct DiscreteUnit {
    pub id: Uuid,
}

impl From<DiscreteUnit> for web_common::database::tables::DiscreteUnit {
    fn from(item: DiscreteUnit) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl From<web_common::database::tables::DiscreteUnit> for DiscreteUnit {
    fn from(item: web_common::database::tables::DiscreteUnit) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl DiscreteUnit {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        discrete_units::dsl::discrete_units
            .filter(discrete_units::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = document_formats)]
pub struct DocumentFormat {
    pub id: Uuid,
    pub mime_type: String,
}

impl From<DocumentFormat> for web_common::database::tables::DocumentFormat {
    fn from(item: DocumentFormat) -> Self {
        Self {
            id: item.id,
            mime_type: item.mime_type,
        }
    }
}

impl From<web_common::database::tables::DocumentFormat> for DocumentFormat {
    fn from(item: web_common::database::tables::DocumentFormat) -> Self {
        Self {
            id: item.id,
            mime_type: item.mime_type,
        }
    }
}

impl DocumentFormat {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        document_formats::dsl::document_formats
            .filter(document_formats::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = documents)]
pub struct Document {
    pub id: Uuid,
    pub path: String,
    pub format_id: Uuid,
    pub bytes: i32,
}

impl From<Document> for web_common::database::tables::Document {
    fn from(item: Document) -> Self {
        Self {
            id: item.id,
            path: item.path,
            format_id: item.format_id,
            bytes: item.bytes,
        }
    }
}

impl From<web_common::database::tables::Document> for Document {
    fn from(item: web_common::database::tables::Document) -> Self {
        Self {
            id: item.id,
            path: item.path,
            format_id: item.format_id,
            bytes: item.bytes,
        }
    }
}

impl Document {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        documents::dsl::documents
            .filter(documents::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = editables)]
pub struct Editable {
    pub id: Uuid,
    pub created_at: NaiveDateTime,
    pub created_by: Uuid,
}

impl From<Editable> for web_common::database::tables::Editable {
    fn from(item: Editable) -> Self {
        Self {
            id: item.id,
            created_at: item.created_at,
            created_by: item.created_by,
        }
    }
}

impl From<web_common::database::tables::Editable> for Editable {
    fn from(item: web_common::database::tables::Editable) -> Self {
        Self {
            id: item.id,
            created_at: item.created_at,
            created_by: item.created_by,
        }
    }
}

impl Editable {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        editables::dsl::editables
            .filter(editables::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = edits)]
pub struct Edit {
    pub id: Uuid,
    pub editable_id: Uuid,
}

impl From<Edit> for web_common::database::tables::Edit {
    fn from(item: Edit) -> Self {
        Self {
            id: item.id,
            editable_id: item.editable_id,
        }
    }
}

impl From<web_common::database::tables::Edit> for Edit {
    fn from(item: web_common::database::tables::Edit) -> Self {
        Self {
            id: item.id,
            editable_id: item.editable_id,
        }
    }
}

impl Edit {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        edits::dsl::edits
            .filter(edits::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = item_categories)]
pub struct ItemCategory {
    pub id: Uuid,
}

impl From<ItemCategory> for web_common::database::tables::ItemCategory {
    fn from(item: ItemCategory) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl From<web_common::database::tables::ItemCategory> for ItemCategory {
    fn from(item: web_common::database::tables::ItemCategory) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl ItemCategory {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        item_categories::dsl::item_categories
            .filter(item_categories::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = item_category_relationships)]
pub struct ItemCategoryRelationship {
    pub id: Uuid,
    pub parent_id: Uuid,
    pub child_id: Uuid,
}

impl From<ItemCategoryRelationship> for web_common::database::tables::ItemCategoryRelationship {
    fn from(item: ItemCategoryRelationship) -> Self {
        Self {
            id: item.id,
            parent_id: item.parent_id,
            child_id: item.child_id,
        }
    }
}

impl From<web_common::database::tables::ItemCategoryRelationship> for ItemCategoryRelationship {
    fn from(item: web_common::database::tables::ItemCategoryRelationship) -> Self {
        Self {
            id: item.id,
            parent_id: item.parent_id,
            child_id: item.child_id,
        }
    }
}

impl ItemCategoryRelationship {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        item_category_relationships::dsl::item_category_relationships
            .filter(item_category_relationships::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = item_category_units)]
pub struct ItemCategoryUnit {
    pub id: Uuid,
    pub item_category_id: Uuid,
    pub unit_id: Uuid,
}

impl From<ItemCategoryUnit> for web_common::database::tables::ItemCategoryUnit {
    fn from(item: ItemCategoryUnit) -> Self {
        Self {
            id: item.id,
            item_category_id: item.item_category_id,
            unit_id: item.unit_id,
        }
    }
}

impl From<web_common::database::tables::ItemCategoryUnit> for ItemCategoryUnit {
    fn from(item: web_common::database::tables::ItemCategoryUnit) -> Self {
        Self {
            id: item.id,
            item_category_id: item.item_category_id,
            unit_id: item.unit_id,
        }
    }
}

impl ItemCategoryUnit {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        item_category_units::dsl::item_category_units
            .filter(item_category_units::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = item_continuous_quantities)]
pub struct ItemContinuousQuantity {
    pub id: Uuid,
    pub item_id: Option<Uuid>,
    pub weight: f64,
    pub unit_id: Option<Uuid>,
    pub sensor_id: Option<Uuid>,
    pub measured_at: NaiveDateTime,
    pub measured_by: Option<Uuid>,
}

impl From<ItemContinuousQuantity> for web_common::database::tables::ItemContinuousQuantity {
    fn from(item: ItemContinuousQuantity) -> Self {
        Self {
            id: item.id,
            item_id: item.item_id,
            weight: item.weight,
            unit_id: item.unit_id,
            sensor_id: item.sensor_id,
            measured_at: item.measured_at,
            measured_by: item.measured_by,
        }
    }
}

impl From<web_common::database::tables::ItemContinuousQuantity> for ItemContinuousQuantity {
    fn from(item: web_common::database::tables::ItemContinuousQuantity) -> Self {
        Self {
            id: item.id,
            item_id: item.item_id,
            weight: item.weight,
            unit_id: item.unit_id,
            sensor_id: item.sensor_id,
            measured_at: item.measured_at,
            measured_by: item.measured_by,
        }
    }
}

impl ItemContinuousQuantity {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        item_continuous_quantities::dsl::item_continuous_quantities
            .filter(item_continuous_quantities::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = item_discrete_quantities)]
pub struct ItemDiscreteQuantity {
    pub id: Uuid,
    pub item_id: Option<Uuid>,
    pub quantity: i32,
    pub unit_id: Option<Uuid>,
    pub measured_at: NaiveDateTime,
    pub measured_by: Option<Uuid>,
}

impl From<ItemDiscreteQuantity> for web_common::database::tables::ItemDiscreteQuantity {
    fn from(item: ItemDiscreteQuantity) -> Self {
        Self {
            id: item.id,
            item_id: item.item_id,
            quantity: item.quantity,
            unit_id: item.unit_id,
            measured_at: item.measured_at,
            measured_by: item.measured_by,
        }
    }
}

impl From<web_common::database::tables::ItemDiscreteQuantity> for ItemDiscreteQuantity {
    fn from(item: web_common::database::tables::ItemDiscreteQuantity) -> Self {
        Self {
            id: item.id,
            item_id: item.item_id,
            quantity: item.quantity,
            unit_id: item.unit_id,
            measured_at: item.measured_at,
            measured_by: item.measured_by,
        }
    }
}

impl ItemDiscreteQuantity {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        item_discrete_quantities::dsl::item_discrete_quantities
            .filter(item_discrete_quantities::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = item_locations)]
pub struct ItemLocation {
    pub id: Uuid,
    pub item_id: Option<Uuid>,
    pub location_id: Option<Uuid>,
    pub previous_location_id: Option<Uuid>,
}

impl From<ItemLocation> for web_common::database::tables::ItemLocation {
    fn from(item: ItemLocation) -> Self {
        Self {
            id: item.id,
            item_id: item.item_id,
            location_id: item.location_id,
            previous_location_id: item.previous_location_id,
        }
    }
}

impl From<web_common::database::tables::ItemLocation> for ItemLocation {
    fn from(item: web_common::database::tables::ItemLocation) -> Self {
        Self {
            id: item.id,
            item_id: item.item_id,
            location_id: item.location_id,
            previous_location_id: item.previous_location_id,
        }
    }
}

impl ItemLocation {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        item_locations::dsl::item_locations
            .filter(item_locations::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = item_units)]
pub struct ItemUnit {
    pub id: Uuid,
    pub item_id: Uuid,
    pub unit_id: Uuid,
}

impl From<ItemUnit> for web_common::database::tables::ItemUnit {
    fn from(item: ItemUnit) -> Self {
        Self {
            id: item.id,
            item_id: item.item_id,
            unit_id: item.unit_id,
        }
    }
}

impl From<web_common::database::tables::ItemUnit> for ItemUnit {
    fn from(item: web_common::database::tables::ItemUnit) -> Self {
        Self {
            id: item.id,
            item_id: item.item_id,
            unit_id: item.unit_id,
        }
    }
}

impl ItemUnit {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        item_units::dsl::item_units
            .filter(item_units::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = items)]
pub struct Item {
    pub id: Uuid,
    pub parent_id: Option<Uuid>,
}

impl From<Item> for web_common::database::tables::Item {
    fn from(item: Item) -> Self {
        Self {
            id: item.id,
            parent_id: item.parent_id,
        }
    }
}

impl From<web_common::database::tables::Item> for Item {
    fn from(item: web_common::database::tables::Item) -> Self {
        Self {
            id: item.id,
            parent_id: item.parent_id,
        }
    }
}

impl Item {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        items::dsl::items
            .filter(items::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = location_states)]
pub struct LocationState {
    pub id: Uuid,
    pub font_awesome_icon: Option<String>,
}

impl From<LocationState> for web_common::database::tables::LocationState {
    fn from(item: LocationState) -> Self {
        Self {
            id: item.id,
            font_awesome_icon: item.font_awesome_icon,
        }
    }
}

impl From<web_common::database::tables::LocationState> for LocationState {
    fn from(item: web_common::database::tables::LocationState) -> Self {
        Self {
            id: item.id,
            font_awesome_icon: item.font_awesome_icon,
        }
    }
}

impl LocationState {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        location_states::dsl::location_states
            .filter(location_states::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = locations)]
pub struct Location {
    pub id: Uuid,
    pub latitude: Option<f64>,
    pub longitude: Option<f64>,
    pub altitude: Option<f64>,
    pub address: Option<String>,
    pub geolocalization_device_id: Option<Uuid>,
    pub altitude_device_id: Option<Uuid>,
    pub parent_location_id: Option<Uuid>,
    pub state_id: Uuid,
}

impl From<Location> for web_common::database::tables::Location {
    fn from(item: Location) -> Self {
        Self {
            id: item.id,
            latitude: item.latitude,
            longitude: item.longitude,
            altitude: item.altitude,
            address: item.address,
            geolocalization_device_id: item.geolocalization_device_id,
            altitude_device_id: item.altitude_device_id,
            parent_location_id: item.parent_location_id,
            state_id: item.state_id,
        }
    }
}

impl From<web_common::database::tables::Location> for Location {
    fn from(item: web_common::database::tables::Location) -> Self {
        Self {
            id: item.id,
            latitude: item.latitude,
            longitude: item.longitude,
            altitude: item.altitude,
            address: item.address,
            geolocalization_device_id: item.geolocalization_device_id,
            altitude_device_id: item.altitude_device_id,
            parent_location_id: item.parent_location_id,
            state_id: item.state_id,
        }
    }
}

impl Location {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        locations::dsl::locations
            .filter(locations::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = login_providers)]
pub struct LoginProvider {
    pub id: Uuid,
    pub name: String,
    pub font_awesome_icon: String,
    pub client_id_var_name: String,
    pub redirect_uri_var_name: String,
    pub oauth_url: String,
    pub scope: String,
}

impl From<LoginProvider> for web_common::database::tables::LoginProvider {
    fn from(item: LoginProvider) -> Self {
        Self {
            id: item.id,
            name: item.name,
            font_awesome_icon: item.font_awesome_icon,
            client_id_var_name: item.client_id_var_name,
            redirect_uri_var_name: item.redirect_uri_var_name,
            oauth_url: item.oauth_url,
            scope: item.scope,
        }
    }
}

impl From<web_common::database::tables::LoginProvider> for LoginProvider {
    fn from(item: web_common::database::tables::LoginProvider) -> Self {
        Self {
            id: item.id,
            name: item.name,
            font_awesome_icon: item.font_awesome_icon,
            client_id_var_name: item.client_id_var_name,
            redirect_uri_var_name: item.redirect_uri_var_name,
            oauth_url: item.oauth_url,
            scope: item.scope,
        }
    }
}

impl LoginProvider {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        login_providers::dsl::login_providers
            .filter(login_providers::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = manufactured_item_categories)]
pub struct ManufacturedItemCategory {
    pub id: Uuid,
    pub cost: f64,
    pub cost_per_day: f64,
    pub currency: String,
    pub manifacturer_id: Uuid,
}

impl From<ManufacturedItemCategory> for web_common::database::tables::ManufacturedItemCategory {
    fn from(item: ManufacturedItemCategory) -> Self {
        Self {
            id: item.id,
            cost: item.cost,
            cost_per_day: item.cost_per_day,
            currency: item.currency,
            manifacturer_id: item.manifacturer_id,
        }
    }
}

impl From<web_common::database::tables::ManufacturedItemCategory> for ManufacturedItemCategory {
    fn from(item: web_common::database::tables::ManufacturedItemCategory) -> Self {
        Self {
            id: item.id,
            cost: item.cost,
            cost_per_day: item.cost_per_day,
            currency: item.currency,
            manifacturer_id: item.manifacturer_id,
        }
    }
}

impl ManufacturedItemCategory {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        manufactured_item_categories::dsl::manufactured_item_categories
            .filter(manufactured_item_categories::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = notifications)]
pub struct Notification {
    pub id: Uuid,
    pub user_id: Uuid,
    pub operation: String,
    pub table_name: String,
    pub row_id: Option<Uuid>,
    pub read: bool,
}

impl From<Notification> for web_common::database::tables::Notification {
    fn from(item: Notification) -> Self {
        Self {
            id: item.id,
            user_id: item.user_id,
            operation: item.operation,
            table_name: item.table_name,
            row_id: item.row_id,
            read: item.read,
        }
    }
}

impl From<web_common::database::tables::Notification> for Notification {
    fn from(item: web_common::database::tables::Notification) -> Self {
        Self {
            id: item.id,
            user_id: item.user_id,
            operation: item.operation,
            table_name: item.table_name,
            row_id: item.row_id,
            read: item.read,
        }
    }
}

impl Notification {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        notifications::dsl::notifications
            .filter(notifications::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = organization_authorizations)]
pub struct OrganizationAuthorization {
    pub id: Uuid,
    pub organization_id: Uuid,
    pub editable_id: Uuid,
    pub role_id: Uuid,
}

impl From<OrganizationAuthorization> for web_common::database::tables::OrganizationAuthorization {
    fn from(item: OrganizationAuthorization) -> Self {
        Self {
            id: item.id,
            organization_id: item.organization_id,
            editable_id: item.editable_id,
            role_id: item.role_id,
        }
    }
}

impl From<web_common::database::tables::OrganizationAuthorization> for OrganizationAuthorization {
    fn from(item: web_common::database::tables::OrganizationAuthorization) -> Self {
        Self {
            id: item.id,
            organization_id: item.organization_id,
            editable_id: item.editable_id,
            role_id: item.role_id,
        }
    }
}

impl OrganizationAuthorization {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        organization_authorizations::dsl::organization_authorizations
            .filter(organization_authorizations::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = organization_locations)]
pub struct OrganizationLocation {
    pub id: Uuid,
    pub organization_id: Option<Uuid>,
    pub location_id: Option<Uuid>,
    pub previous_location_id: Option<Uuid>,
}

impl From<OrganizationLocation> for web_common::database::tables::OrganizationLocation {
    fn from(item: OrganizationLocation) -> Self {
        Self {
            id: item.id,
            organization_id: item.organization_id,
            location_id: item.location_id,
            previous_location_id: item.previous_location_id,
        }
    }
}

impl From<web_common::database::tables::OrganizationLocation> for OrganizationLocation {
    fn from(item: web_common::database::tables::OrganizationLocation) -> Self {
        Self {
            id: item.id,
            organization_id: item.organization_id,
            location_id: item.location_id,
            previous_location_id: item.previous_location_id,
        }
    }
}

impl OrganizationLocation {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        organization_locations::dsl::organization_locations
            .filter(organization_locations::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = organization_states)]
pub struct OrganizationState {
    pub id: Uuid,
    pub font_awesome_icon: Option<String>,
}

impl From<OrganizationState> for web_common::database::tables::OrganizationState {
    fn from(item: OrganizationState) -> Self {
        Self {
            id: item.id,
            font_awesome_icon: item.font_awesome_icon,
        }
    }
}

impl From<web_common::database::tables::OrganizationState> for OrganizationState {
    fn from(item: web_common::database::tables::OrganizationState) -> Self {
        Self {
            id: item.id,
            font_awesome_icon: item.font_awesome_icon,
        }
    }
}

impl OrganizationState {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        organization_states::dsl::organization_states
            .filter(organization_states::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = organizations)]
pub struct Organization {
    pub id: Uuid,
    pub state_id: Option<Uuid>,
    pub parent_organization_id: Option<Uuid>,
    pub logo_id: Option<Uuid>,
    pub website_url: Option<String>,
}

impl From<Organization> for web_common::database::tables::Organization {
    fn from(item: Organization) -> Self {
        Self {
            id: item.id,
            state_id: item.state_id,
            parent_organization_id: item.parent_organization_id,
            logo_id: item.logo_id,
            website_url: item.website_url,
        }
    }
}

impl From<web_common::database::tables::Organization> for Organization {
    fn from(item: web_common::database::tables::Organization) -> Self {
        Self {
            id: item.id,
            state_id: item.state_id,
            parent_organization_id: item.parent_organization_id,
            logo_id: item.logo_id,
            website_url: item.website_url,
        }
    }
}

impl Organization {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        organizations::dsl::organizations
            .filter(organizations::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = primary_user_emails)]
pub struct PrimaryUserEmail {
    pub id: Uuid,
}

impl From<PrimaryUserEmail> for web_common::database::tables::PrimaryUserEmail {
    fn from(item: PrimaryUserEmail) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl From<web_common::database::tables::PrimaryUserEmail> for PrimaryUserEmail {
    fn from(item: web_common::database::tables::PrimaryUserEmail) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl PrimaryUserEmail {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        primary_user_emails::dsl::primary_user_emails
            .filter(primary_user_emails::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = procedure_continuous_requirements)]
pub struct ProcedureContinuousRequirement {
    pub id: Uuid,
    pub procedure_id: Uuid,
    pub item_category_id: Uuid,
    pub quantity: f64,
    pub unit_id: Option<Uuid>,
}

impl From<ProcedureContinuousRequirement> for web_common::database::tables::ProcedureContinuousRequirement {
    fn from(item: ProcedureContinuousRequirement) -> Self {
        Self {
            id: item.id,
            procedure_id: item.procedure_id,
            item_category_id: item.item_category_id,
            quantity: item.quantity,
            unit_id: item.unit_id,
        }
    }
}

impl From<web_common::database::tables::ProcedureContinuousRequirement> for ProcedureContinuousRequirement {
    fn from(item: web_common::database::tables::ProcedureContinuousRequirement) -> Self {
        Self {
            id: item.id,
            procedure_id: item.procedure_id,
            item_category_id: item.item_category_id,
            quantity: item.quantity,
            unit_id: item.unit_id,
        }
    }
}

impl ProcedureContinuousRequirement {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        procedure_continuous_requirements::dsl::procedure_continuous_requirements
            .filter(procedure_continuous_requirements::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = procedure_discrete_requirements)]
pub struct ProcedureDiscreteRequirement {
    pub id: Uuid,
    pub procedure_id: Uuid,
    pub item_category_id: Uuid,
    pub quantity: i32,
    pub unit_id: Option<Uuid>,
}

impl From<ProcedureDiscreteRequirement> for web_common::database::tables::ProcedureDiscreteRequirement {
    fn from(item: ProcedureDiscreteRequirement) -> Self {
        Self {
            id: item.id,
            procedure_id: item.procedure_id,
            item_category_id: item.item_category_id,
            quantity: item.quantity,
            unit_id: item.unit_id,
        }
    }
}

impl From<web_common::database::tables::ProcedureDiscreteRequirement> for ProcedureDiscreteRequirement {
    fn from(item: web_common::database::tables::ProcedureDiscreteRequirement) -> Self {
        Self {
            id: item.id,
            procedure_id: item.procedure_id,
            item_category_id: item.item_category_id,
            quantity: item.quantity,
            unit_id: item.unit_id,
        }
    }
}

impl ProcedureDiscreteRequirement {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        procedure_discrete_requirements::dsl::procedure_discrete_requirements
            .filter(procedure_discrete_requirements::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = procedures)]
pub struct Procedure {
    pub id: Uuid,
}

impl From<Procedure> for web_common::database::tables::Procedure {
    fn from(item: Procedure) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl From<web_common::database::tables::Procedure> for Procedure {
    fn from(item: web_common::database::tables::Procedure) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl Procedure {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        procedures::dsl::procedures
            .filter(procedures::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = project_continuous_requirements)]
pub struct ProjectContinuousRequirement {
    pub id: Uuid,
    pub project_id: Uuid,
    pub item_id: Uuid,
    pub quantity: f64,
    pub unit_id: Option<Uuid>,
}

impl From<ProjectContinuousRequirement> for web_common::database::tables::ProjectContinuousRequirement {
    fn from(item: ProjectContinuousRequirement) -> Self {
        Self {
            id: item.id,
            project_id: item.project_id,
            item_id: item.item_id,
            quantity: item.quantity,
            unit_id: item.unit_id,
        }
    }
}

impl From<web_common::database::tables::ProjectContinuousRequirement> for ProjectContinuousRequirement {
    fn from(item: web_common::database::tables::ProjectContinuousRequirement) -> Self {
        Self {
            id: item.id,
            project_id: item.project_id,
            item_id: item.item_id,
            quantity: item.quantity,
            unit_id: item.unit_id,
        }
    }
}

impl ProjectContinuousRequirement {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        project_continuous_requirements::dsl::project_continuous_requirements
            .filter(project_continuous_requirements::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = project_discrete_requirements)]
pub struct ProjectDiscreteRequirement {
    pub id: Uuid,
    pub project_id: Uuid,
    pub item_id: Uuid,
    pub quantity: f64,
    pub unit_id: Option<Uuid>,
}

impl From<ProjectDiscreteRequirement> for web_common::database::tables::ProjectDiscreteRequirement {
    fn from(item: ProjectDiscreteRequirement) -> Self {
        Self {
            id: item.id,
            project_id: item.project_id,
            item_id: item.item_id,
            quantity: item.quantity,
            unit_id: item.unit_id,
        }
    }
}

impl From<web_common::database::tables::ProjectDiscreteRequirement> for ProjectDiscreteRequirement {
    fn from(item: web_common::database::tables::ProjectDiscreteRequirement) -> Self {
        Self {
            id: item.id,
            project_id: item.project_id,
            item_id: item.item_id,
            quantity: item.quantity,
            unit_id: item.unit_id,
        }
    }
}

impl ProjectDiscreteRequirement {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        project_discrete_requirements::dsl::project_discrete_requirements
            .filter(project_discrete_requirements::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = project_milestones)]
pub struct ProjectMilestone {
    pub id: Uuid,
    pub project_id: Uuid,
    pub due_date: NaiveDateTime,
    pub completed_at: Option<NaiveDateTime>,
}

impl From<ProjectMilestone> for web_common::database::tables::ProjectMilestone {
    fn from(item: ProjectMilestone) -> Self {
        Self {
            id: item.id,
            project_id: item.project_id,
            due_date: item.due_date,
            completed_at: item.completed_at,
        }
    }
}

impl From<web_common::database::tables::ProjectMilestone> for ProjectMilestone {
    fn from(item: web_common::database::tables::ProjectMilestone) -> Self {
        Self {
            id: item.id,
            project_id: item.project_id,
            due_date: item.due_date,
            completed_at: item.completed_at,
        }
    }
}

impl ProjectMilestone {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        project_milestones::dsl::project_milestones
            .filter(project_milestones::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = project_states)]
pub struct ProjectState {
    pub id: Uuid,
    pub name: String,
    pub description: String,
    pub font_awesome_icon: String,
    pub icon_color: String,
}

impl From<ProjectState> for web_common::database::tables::ProjectState {
    fn from(item: ProjectState) -> Self {
        Self {
            id: item.id,
            name: item.name,
            description: item.description,
            font_awesome_icon: item.font_awesome_icon,
            icon_color: item.icon_color,
        }
    }
}

impl From<web_common::database::tables::ProjectState> for ProjectState {
    fn from(item: web_common::database::tables::ProjectState) -> Self {
        Self {
            id: item.id,
            name: item.name,
            description: item.description,
            font_awesome_icon: item.font_awesome_icon,
            icon_color: item.icon_color,
        }
    }
}

impl ProjectState {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        project_states::dsl::project_states
            .filter(project_states::dsl::id.eq(id))
            .first::<Self>(connection)
    }
    /// Search for the struct by a given string.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    /// * `threshold` - The similarity threshold, by default `0.6`.
    /// * `connection` - The connection to the database.
    ///
    pub fn search(
        query: &str,
        limit: Option<i32>,
        threshold: Option<f64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Vec<Self>, diesel::result::Error> {
        use crate::schema::project_states;
        let limit = limit.unwrap_or(10);
        let threshold = threshold.unwrap_or(0.6);
        let similarity_query = format!(concat!(
            r#"SELECT id, name, description, font_awesome_icon, icon_color FROM project_states WHERE",
            "similarity(name, description, '$1') > $2",
            "ORDER BY similarity(name, description, '$1') DESC LIMIT $3;"#
        ));
        diesel::sql_query(similarity_query)
            .bind::<diesel::sql_types::Text, _>(query)
            .bind::<diesel::sql_types::Float8, _>(threshold)
            .bind::<diesel::sql_types::Integer, _>(limit)
            .load(connection)
}
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = projects)]
pub struct Project {
    pub id: Uuid,
    pub name: String,
    pub description: String,
    pub public: bool,
    pub state_id: Uuid,
    pub parent_project_id: Option<Uuid>,
    pub budget: Option<f64>,
    pub expenses: Option<f64>,
    pub currency: Option<String>,
    pub created_by: Uuid,
    pub created_at: NaiveDateTime,
    pub expected_end_date: Option<NaiveDateTime>,
    pub end_date: Option<NaiveDateTime>,
}

impl From<Project> for web_common::database::tables::Project {
    fn from(item: Project) -> Self {
        Self {
            id: item.id,
            name: item.name,
            description: item.description,
            public: item.public,
            state_id: item.state_id,
            parent_project_id: item.parent_project_id,
            budget: item.budget,
            expenses: item.expenses,
            currency: item.currency,
            created_by: item.created_by,
            created_at: item.created_at,
            expected_end_date: item.expected_end_date,
            end_date: item.end_date,
        }
    }
}

impl From<web_common::database::tables::Project> for Project {
    fn from(item: web_common::database::tables::Project) -> Self {
        Self {
            id: item.id,
            name: item.name,
            description: item.description,
            public: item.public,
            state_id: item.state_id,
            parent_project_id: item.parent_project_id,
            budget: item.budget,
            expenses: item.expenses,
            currency: item.currency,
            created_by: item.created_by,
            created_at: item.created_at,
            expected_end_date: item.expected_end_date,
            end_date: item.end_date,
        }
    }
}

impl Project {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        projects::dsl::projects
            .filter(projects::dsl::id.eq(id))
            .first::<Self>(connection)
    }
    /// Search for the struct by a given string.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    /// * `threshold` - The similarity threshold, by default `0.6`.
    /// * `connection` - The connection to the database.
    ///
    pub fn search(
        query: &str,
        limit: Option<i32>,
        threshold: Option<f64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Vec<Self>, diesel::result::Error> {
        use crate::schema::projects;
        let limit = limit.unwrap_or(10);
        let threshold = threshold.unwrap_or(0.6);
        let similarity_query = format!(concat!(
            r#"SELECT id, name, description, public, state_id, parent_project_id, budget, expenses, currency, created_by, created_at, expected_end_date, end_date FROM projects WHERE",
            "similarity(name, description, '$1') > $2",
            "ORDER BY similarity(name, description, '$1') DESC LIMIT $3;"#
        ));
        diesel::sql_query(similarity_query)
            .bind::<diesel::sql_types::Text, _>(query)
            .bind::<diesel::sql_types::Float8, _>(threshold)
            .bind::<diesel::sql_types::Integer, _>(limit)
            .load(connection)
}
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = roles)]
pub struct Role {
    pub id: Uuid,
}

impl From<Role> for web_common::database::tables::Role {
    fn from(item: Role) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl From<web_common::database::tables::Role> for Role {
    fn from(item: web_common::database::tables::Role) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl Role {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        roles::dsl::roles
            .filter(roles::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = sample_taxa)]
pub struct SampleTaxa {
    pub id: Uuid,
    pub sample_id: Uuid,
    pub taxon_id: Uuid,
}

impl From<SampleTaxa> for web_common::database::tables::SampleTaxa {
    fn from(item: SampleTaxa) -> Self {
        Self {
            id: item.id,
            sample_id: item.sample_id,
            taxon_id: item.taxon_id,
        }
    }
}

impl From<web_common::database::tables::SampleTaxa> for SampleTaxa {
    fn from(item: web_common::database::tables::SampleTaxa) -> Self {
        Self {
            id: item.id,
            sample_id: item.sample_id,
            taxon_id: item.taxon_id,
        }
    }
}

impl SampleTaxa {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        sample_taxa::dsl::sample_taxa
            .filter(sample_taxa::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = sampled_individual_taxa)]
pub struct SampledIndividualTaxa {
    pub id: Uuid,
    pub sampled_individual_id: Uuid,
    pub taxon_id: Uuid,
}

impl From<SampledIndividualTaxa> for web_common::database::tables::SampledIndividualTaxa {
    fn from(item: SampledIndividualTaxa) -> Self {
        Self {
            id: item.id,
            sampled_individual_id: item.sampled_individual_id,
            taxon_id: item.taxon_id,
        }
    }
}

impl From<web_common::database::tables::SampledIndividualTaxa> for SampledIndividualTaxa {
    fn from(item: web_common::database::tables::SampledIndividualTaxa) -> Self {
        Self {
            id: item.id,
            sampled_individual_id: item.sampled_individual_id,
            taxon_id: item.taxon_id,
        }
    }
}

impl SampledIndividualTaxa {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        sampled_individual_taxa::dsl::sampled_individual_taxa
            .filter(sampled_individual_taxa::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = sampled_individuals)]
pub struct SampledIndividual {
    pub id: Uuid,
}

impl From<SampledIndividual> for web_common::database::tables::SampledIndividual {
    fn from(item: SampledIndividual) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl From<web_common::database::tables::SampledIndividual> for SampledIndividual {
    fn from(item: web_common::database::tables::SampledIndividual) -> Self {
        Self {
            id: item.id,
        }
    }
}

impl SampledIndividual {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        sampled_individuals::dsl::sampled_individuals
            .filter(sampled_individuals::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = samples)]
pub struct Sample {
    pub id: Uuid,
    pub derived_from: Option<Uuid>,
}

impl From<Sample> for web_common::database::tables::Sample {
    fn from(item: Sample) -> Self {
        Self {
            id: item.id,
            derived_from: item.derived_from,
        }
    }
}

impl From<web_common::database::tables::Sample> for Sample {
    fn from(item: web_common::database::tables::Sample) -> Self {
        Self {
            id: item.id,
            derived_from: item.derived_from,
        }
    }
}

impl Sample {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        samples::dsl::samples
            .filter(samples::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = spectra)]
pub struct Spectra {
    pub id: Uuid,
    pub spectra_collection_id: Uuid,
}

impl From<Spectra> for web_common::database::tables::Spectra {
    fn from(item: Spectra) -> Self {
        Self {
            id: item.id,
            spectra_collection_id: item.spectra_collection_id,
        }
    }
}

impl From<web_common::database::tables::Spectra> for Spectra {
    fn from(item: web_common::database::tables::Spectra) -> Self {
        Self {
            id: item.id,
            spectra_collection_id: item.spectra_collection_id,
        }
    }
}

impl Spectra {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        spectra::dsl::spectra
            .filter(spectra::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = spectra_collection)]
pub struct SpectraCollection {
    pub id: Uuid,
    pub sample_id: Uuid,
}

impl From<SpectraCollection> for web_common::database::tables::SpectraCollection {
    fn from(item: SpectraCollection) -> Self {
        Self {
            id: item.id,
            sample_id: item.sample_id,
        }
    }
}

impl From<web_common::database::tables::SpectraCollection> for SpectraCollection {
    fn from(item: web_common::database::tables::SpectraCollection) -> Self {
        Self {
            id: item.id,
            sample_id: item.sample_id,
        }
    }
}

impl SpectraCollection {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        spectra_collection::dsl::spectra_collection
            .filter(spectra_collection::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = taxa)]
pub struct Taxa {
    pub id: Uuid,
    pub name: String,
    pub ncbi_taxon_id: Option<i32>,
}

impl From<Taxa> for web_common::database::tables::Taxa {
    fn from(item: Taxa) -> Self {
        Self {
            id: item.id,
            name: item.name,
            ncbi_taxon_id: item.ncbi_taxon_id,
        }
    }
}

impl From<web_common::database::tables::Taxa> for Taxa {
    fn from(item: web_common::database::tables::Taxa) -> Self {
        Self {
            id: item.id,
            name: item.name,
            ncbi_taxon_id: item.ncbi_taxon_id,
        }
    }
}

impl Taxa {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        taxa::dsl::taxa
            .filter(taxa::dsl::id.eq(id))
            .first::<Self>(connection)
    }
    /// Search for the struct by a given string.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    /// * `threshold` - The similarity threshold, by default `0.6`.
    /// * `connection` - The connection to the database.
    ///
    pub fn search(
        query: &str,
        limit: Option<i32>,
        threshold: Option<f64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Vec<Self>, diesel::result::Error> {
        use crate::schema::taxa;
        let limit = limit.unwrap_or(10);
        let threshold = threshold.unwrap_or(0.6);
        let similarity_query = format!(concat!(
            r#"SELECT id, name, ncbi_taxon_id FROM taxa WHERE",
            "similarity(name, '$1') > $2",
            "ORDER BY similarity(name, '$1') DESC LIMIT $3;"#
        ));
        diesel::sql_query(similarity_query)
            .bind::<diesel::sql_types::Text, _>(query)
            .bind::<diesel::sql_types::Float8, _>(threshold)
            .bind::<diesel::sql_types::Integer, _>(limit)
            .load(connection)
}
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = team_authorizations)]
pub struct TeamAuthorization {
    pub id: Uuid,
    pub team_id: Uuid,
    pub editable_id: Uuid,
    pub role_id: Uuid,
}

impl From<TeamAuthorization> for web_common::database::tables::TeamAuthorization {
    fn from(item: TeamAuthorization) -> Self {
        Self {
            id: item.id,
            team_id: item.team_id,
            editable_id: item.editable_id,
            role_id: item.role_id,
        }
    }
}

impl From<web_common::database::tables::TeamAuthorization> for TeamAuthorization {
    fn from(item: web_common::database::tables::TeamAuthorization) -> Self {
        Self {
            id: item.id,
            team_id: item.team_id,
            editable_id: item.editable_id,
            role_id: item.role_id,
        }
    }
}

impl TeamAuthorization {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        team_authorizations::dsl::team_authorizations
            .filter(team_authorizations::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = team_states)]
pub struct TeamState {
    pub id: Uuid,
    pub font_awesome_icon: String,
}

impl From<TeamState> for web_common::database::tables::TeamState {
    fn from(item: TeamState) -> Self {
        Self {
            id: item.id,
            font_awesome_icon: item.font_awesome_icon,
        }
    }
}

impl From<web_common::database::tables::TeamState> for TeamState {
    fn from(item: web_common::database::tables::TeamState) -> Self {
        Self {
            id: item.id,
            font_awesome_icon: item.font_awesome_icon,
        }
    }
}

impl TeamState {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        team_states::dsl::team_states
            .filter(team_states::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = teams)]
pub struct Team {
    pub id: Uuid,
    pub parent_team_id: Option<Uuid>,
    pub team_state_id: Uuid,
}

impl From<Team> for web_common::database::tables::Team {
    fn from(item: Team) -> Self {
        Self {
            id: item.id,
            parent_team_id: item.parent_team_id,
            team_state_id: item.team_state_id,
        }
    }
}

impl From<web_common::database::tables::Team> for Team {
    fn from(item: web_common::database::tables::Team) -> Self {
        Self {
            id: item.id,
            parent_team_id: item.parent_team_id,
            team_state_id: item.team_state_id,
        }
    }
}

impl Team {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        teams::dsl::teams
            .filter(teams::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = units)]
pub struct Unit {
    pub id: Uuid,
    pub symbol: String,
}

impl From<Unit> for web_common::database::tables::Unit {
    fn from(item: Unit) -> Self {
        Self {
            id: item.id,
            symbol: item.symbol,
        }
    }
}

impl From<web_common::database::tables::Unit> for Unit {
    fn from(item: web_common::database::tables::Unit) -> Self {
        Self {
            id: item.id,
            symbol: item.symbol,
        }
    }
}

impl Unit {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        units::dsl::units
            .filter(units::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = user_authorizations)]
pub struct UserAuthorization {
    pub id: Uuid,
    pub user_id: Uuid,
    pub editable_id: Uuid,
    pub role_id: Uuid,
}

impl From<UserAuthorization> for web_common::database::tables::UserAuthorization {
    fn from(item: UserAuthorization) -> Self {
        Self {
            id: item.id,
            user_id: item.user_id,
            editable_id: item.editable_id,
            role_id: item.role_id,
        }
    }
}

impl From<web_common::database::tables::UserAuthorization> for UserAuthorization {
    fn from(item: web_common::database::tables::UserAuthorization) -> Self {
        Self {
            id: item.id,
            user_id: item.user_id,
            editable_id: item.editable_id,
            role_id: item.role_id,
        }
    }
}

impl UserAuthorization {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        user_authorizations::dsl::user_authorizations
            .filter(user_authorizations::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = user_emails)]
pub struct UserEmail {
    pub id: Uuid,
    pub email: String,
    pub user_id: Uuid,
    pub login_provider_id: Uuid,
}

impl From<UserEmail> for web_common::database::tables::UserEmail {
    fn from(item: UserEmail) -> Self {
        Self {
            id: item.id,
            email: item.email,
            user_id: item.user_id,
            login_provider_id: item.login_provider_id,
        }
    }
}

impl From<web_common::database::tables::UserEmail> for UserEmail {
    fn from(item: web_common::database::tables::UserEmail) -> Self {
        Self {
            id: item.id,
            email: item.email,
            user_id: item.user_id,
            login_provider_id: item.login_provider_id,
        }
    }
}

impl UserEmail {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        user_emails::dsl::user_emails
            .filter(user_emails::dsl::id.eq(id))
            .first::<Self>(connection)
    }
}

#[derive(QueryableByName, Insertable, Deserialize, Serialize, PartialEq, Clone, Selectable, Queryable, Debug)]
#[diesel(table_name = users)]
pub struct User {
    pub id: Uuid,
    pub first_name: String,
    pub middle_name: Option<String>,
    pub last_name: String,
    pub created_at: NaiveDateTime,
    pub updated_at: NaiveDateTime,
}

impl From<User> for web_common::database::tables::User {
    fn from(item: User) -> Self {
        Self {
            id: item.id,
            first_name: item.first_name,
            middle_name: item.middle_name,
            last_name: item.last_name,
            created_at: item.created_at,
            updated_at: item.updated_at,
        }
    }
}

impl From<web_common::database::tables::User> for User {
    fn from(item: web_common::database::tables::User) -> Self {
        Self {
            id: item.id,
            first_name: item.first_name,
            middle_name: item.middle_name,
            last_name: item.last_name,
            created_at: item.created_at,
            updated_at: item.updated_at,
        }
    }
}

impl User {
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Self, diesel::result::Error> {
        users::dsl::users
            .filter(users::dsl::id.eq(id))
            .first::<Self>(connection)
    }
    /// Search for the struct by a given string.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    /// * `threshold` - The similarity threshold, by default `0.6`.
    /// * `connection` - The connection to the database.
    ///
    pub fn search(
        query: &str,
        limit: Option<i32>,
        threshold: Option<f64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Vec<Self>, diesel::result::Error> {
        use crate::schema::users;
        let limit = limit.unwrap_or(10);
        let threshold = threshold.unwrap_or(0.6);
        let similarity_query = format!(concat!(
            r#"SELECT id, first_name, middle_name, last_name, created_at, updated_at FROM users WHERE",
            "similarity(first_name, middle_name, last_name, '$1') > $2",
            "ORDER BY similarity(first_name, middle_name, last_name, '$1') DESC LIMIT $3;"#
        ));
        diesel::sql_query(similarity_query)
            .bind::<diesel::sql_types::Text, _>(query)
            .bind::<diesel::sql_types::Float8, _>(threshold)
            .bind::<diesel::sql_types::Integer, _>(limit)
            .load(connection)
}
}



#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]
pub enum TableRow {
    Archivable(Archivable),
    ContainerHorizontalRule(ContainerHorizontalRule),
    ContainerVerticalRule(ContainerVerticalRule),
    ContinuousUnit(ContinuousUnit),
    Describable(Describable),
    DiscreteUnit(DiscreteUnit),
    DocumentFormat(DocumentFormat),
    Document(Document),
    Editable(Editable),
    Edit(Edit),
    ItemCategory(ItemCategory),
    ItemCategoryRelationship(ItemCategoryRelationship),
    ItemCategoryUnit(ItemCategoryUnit),
    ItemContinuousQuantity(ItemContinuousQuantity),
    ItemDiscreteQuantity(ItemDiscreteQuantity),
    ItemLocation(ItemLocation),
    ItemUnit(ItemUnit),
    Item(Item),
    LocationState(LocationState),
    Location(Location),
    LoginProvider(LoginProvider),
    ManufacturedItemCategory(ManufacturedItemCategory),
    Notification(Notification),
    OrganizationAuthorization(OrganizationAuthorization),
    OrganizationLocation(OrganizationLocation),
    OrganizationState(OrganizationState),
    Organization(Organization),
    PrimaryUserEmail(PrimaryUserEmail),
    ProcedureContinuousRequirement(ProcedureContinuousRequirement),
    ProcedureDiscreteRequirement(ProcedureDiscreteRequirement),
    Procedure(Procedure),
    ProjectContinuousRequirement(ProjectContinuousRequirement),
    ProjectDiscreteRequirement(ProjectDiscreteRequirement),
    ProjectMilestone(ProjectMilestone),
    ProjectState(ProjectState),
    Project(Project),
    Role(Role),
    SampleTaxa(SampleTaxa),
    SampledIndividualTaxa(SampledIndividualTaxa),
    SampledIndividual(SampledIndividual),
    Sample(Sample),
    Spectra(Spectra),
    SpectraCollection(SpectraCollection),
    Taxa(Taxa),
    TeamAuthorization(TeamAuthorization),
    TeamState(TeamState),
    Team(Team),
    Unit(Unit),
    UserAuthorization(UserAuthorization),
    UserEmail(UserEmail),
    User(User),
}

impl From<web_common::database::tables::TableRow> for TableRow {
    fn from(item: web_common::database::tables::TableRow) -> Self {
        match item {
            web_common::database::tables::TableRow::Archivable(item) => TableRow::Archivable(item.into()),
            web_common::database::tables::TableRow::ContainerHorizontalRule(item) => TableRow::ContainerHorizontalRule(item.into()),
            web_common::database::tables::TableRow::ContainerVerticalRule(item) => TableRow::ContainerVerticalRule(item.into()),
            web_common::database::tables::TableRow::ContinuousUnit(item) => TableRow::ContinuousUnit(item.into()),
            web_common::database::tables::TableRow::Describable(item) => TableRow::Describable(item.into()),
            web_common::database::tables::TableRow::DiscreteUnit(item) => TableRow::DiscreteUnit(item.into()),
            web_common::database::tables::TableRow::DocumentFormat(item) => TableRow::DocumentFormat(item.into()),
            web_common::database::tables::TableRow::Document(item) => TableRow::Document(item.into()),
            web_common::database::tables::TableRow::Editable(item) => TableRow::Editable(item.into()),
            web_common::database::tables::TableRow::Edit(item) => TableRow::Edit(item.into()),
            web_common::database::tables::TableRow::ItemCategory(item) => TableRow::ItemCategory(item.into()),
            web_common::database::tables::TableRow::ItemCategoryRelationship(item) => TableRow::ItemCategoryRelationship(item.into()),
            web_common::database::tables::TableRow::ItemCategoryUnit(item) => TableRow::ItemCategoryUnit(item.into()),
            web_common::database::tables::TableRow::ItemContinuousQuantity(item) => TableRow::ItemContinuousQuantity(item.into()),
            web_common::database::tables::TableRow::ItemDiscreteQuantity(item) => TableRow::ItemDiscreteQuantity(item.into()),
            web_common::database::tables::TableRow::ItemLocation(item) => TableRow::ItemLocation(item.into()),
            web_common::database::tables::TableRow::ItemUnit(item) => TableRow::ItemUnit(item.into()),
            web_common::database::tables::TableRow::Item(item) => TableRow::Item(item.into()),
            web_common::database::tables::TableRow::LocationState(item) => TableRow::LocationState(item.into()),
            web_common::database::tables::TableRow::Location(item) => TableRow::Location(item.into()),
            web_common::database::tables::TableRow::LoginProvider(item) => TableRow::LoginProvider(item.into()),
            web_common::database::tables::TableRow::ManufacturedItemCategory(item) => TableRow::ManufacturedItemCategory(item.into()),
            web_common::database::tables::TableRow::Notification(item) => TableRow::Notification(item.into()),
            web_common::database::tables::TableRow::OrganizationAuthorization(item) => TableRow::OrganizationAuthorization(item.into()),
            web_common::database::tables::TableRow::OrganizationLocation(item) => TableRow::OrganizationLocation(item.into()),
            web_common::database::tables::TableRow::OrganizationState(item) => TableRow::OrganizationState(item.into()),
            web_common::database::tables::TableRow::Organization(item) => TableRow::Organization(item.into()),
            web_common::database::tables::TableRow::PrimaryUserEmail(item) => TableRow::PrimaryUserEmail(item.into()),
            web_common::database::tables::TableRow::ProcedureContinuousRequirement(item) => TableRow::ProcedureContinuousRequirement(item.into()),
            web_common::database::tables::TableRow::ProcedureDiscreteRequirement(item) => TableRow::ProcedureDiscreteRequirement(item.into()),
            web_common::database::tables::TableRow::Procedure(item) => TableRow::Procedure(item.into()),
            web_common::database::tables::TableRow::ProjectContinuousRequirement(item) => TableRow::ProjectContinuousRequirement(item.into()),
            web_common::database::tables::TableRow::ProjectDiscreteRequirement(item) => TableRow::ProjectDiscreteRequirement(item.into()),
            web_common::database::tables::TableRow::ProjectMilestone(item) => TableRow::ProjectMilestone(item.into()),
            web_common::database::tables::TableRow::ProjectState(item) => TableRow::ProjectState(item.into()),
            web_common::database::tables::TableRow::Project(item) => TableRow::Project(item.into()),
            web_common::database::tables::TableRow::Role(item) => TableRow::Role(item.into()),
            web_common::database::tables::TableRow::SampleTaxa(item) => TableRow::SampleTaxa(item.into()),
            web_common::database::tables::TableRow::SampledIndividualTaxa(item) => TableRow::SampledIndividualTaxa(item.into()),
            web_common::database::tables::TableRow::SampledIndividual(item) => TableRow::SampledIndividual(item.into()),
            web_common::database::tables::TableRow::Sample(item) => TableRow::Sample(item.into()),
            web_common::database::tables::TableRow::Spectra(item) => TableRow::Spectra(item.into()),
            web_common::database::tables::TableRow::SpectraCollection(item) => TableRow::SpectraCollection(item.into()),
            web_common::database::tables::TableRow::Taxa(item) => TableRow::Taxa(item.into()),
            web_common::database::tables::TableRow::TeamAuthorization(item) => TableRow::TeamAuthorization(item.into()),
            web_common::database::tables::TableRow::TeamState(item) => TableRow::TeamState(item.into()),
            web_common::database::tables::TableRow::Team(item) => TableRow::Team(item.into()),
            web_common::database::tables::TableRow::Unit(item) => TableRow::Unit(item.into()),
            web_common::database::tables::TableRow::UserAuthorization(item) => TableRow::UserAuthorization(item.into()),
            web_common::database::tables::TableRow::UserEmail(item) => TableRow::UserEmail(item.into()),
            web_common::database::tables::TableRow::User(item) => TableRow::User(item.into()),
        }
    }
}
impl From<TableRow> for web_common::database::tables::TableRow {
    fn from(item: TableRow) -> Self {
        match item {
            TableRow::Archivable(item) => web_common::database::tables::TableRow::Archivable(item.into()),
            TableRow::ContainerHorizontalRule(item) => web_common::database::tables::TableRow::ContainerHorizontalRule(item.into()),
            TableRow::ContainerVerticalRule(item) => web_common::database::tables::TableRow::ContainerVerticalRule(item.into()),
            TableRow::ContinuousUnit(item) => web_common::database::tables::TableRow::ContinuousUnit(item.into()),
            TableRow::Describable(item) => web_common::database::tables::TableRow::Describable(item.into()),
            TableRow::DiscreteUnit(item) => web_common::database::tables::TableRow::DiscreteUnit(item.into()),
            TableRow::DocumentFormat(item) => web_common::database::tables::TableRow::DocumentFormat(item.into()),
            TableRow::Document(item) => web_common::database::tables::TableRow::Document(item.into()),
            TableRow::Editable(item) => web_common::database::tables::TableRow::Editable(item.into()),
            TableRow::Edit(item) => web_common::database::tables::TableRow::Edit(item.into()),
            TableRow::ItemCategory(item) => web_common::database::tables::TableRow::ItemCategory(item.into()),
            TableRow::ItemCategoryRelationship(item) => web_common::database::tables::TableRow::ItemCategoryRelationship(item.into()),
            TableRow::ItemCategoryUnit(item) => web_common::database::tables::TableRow::ItemCategoryUnit(item.into()),
            TableRow::ItemContinuousQuantity(item) => web_common::database::tables::TableRow::ItemContinuousQuantity(item.into()),
            TableRow::ItemDiscreteQuantity(item) => web_common::database::tables::TableRow::ItemDiscreteQuantity(item.into()),
            TableRow::ItemLocation(item) => web_common::database::tables::TableRow::ItemLocation(item.into()),
            TableRow::ItemUnit(item) => web_common::database::tables::TableRow::ItemUnit(item.into()),
            TableRow::Item(item) => web_common::database::tables::TableRow::Item(item.into()),
            TableRow::LocationState(item) => web_common::database::tables::TableRow::LocationState(item.into()),
            TableRow::Location(item) => web_common::database::tables::TableRow::Location(item.into()),
            TableRow::LoginProvider(item) => web_common::database::tables::TableRow::LoginProvider(item.into()),
            TableRow::ManufacturedItemCategory(item) => web_common::database::tables::TableRow::ManufacturedItemCategory(item.into()),
            TableRow::Notification(item) => web_common::database::tables::TableRow::Notification(item.into()),
            TableRow::OrganizationAuthorization(item) => web_common::database::tables::TableRow::OrganizationAuthorization(item.into()),
            TableRow::OrganizationLocation(item) => web_common::database::tables::TableRow::OrganizationLocation(item.into()),
            TableRow::OrganizationState(item) => web_common::database::tables::TableRow::OrganizationState(item.into()),
            TableRow::Organization(item) => web_common::database::tables::TableRow::Organization(item.into()),
            TableRow::PrimaryUserEmail(item) => web_common::database::tables::TableRow::PrimaryUserEmail(item.into()),
            TableRow::ProcedureContinuousRequirement(item) => web_common::database::tables::TableRow::ProcedureContinuousRequirement(item.into()),
            TableRow::ProcedureDiscreteRequirement(item) => web_common::database::tables::TableRow::ProcedureDiscreteRequirement(item.into()),
            TableRow::Procedure(item) => web_common::database::tables::TableRow::Procedure(item.into()),
            TableRow::ProjectContinuousRequirement(item) => web_common::database::tables::TableRow::ProjectContinuousRequirement(item.into()),
            TableRow::ProjectDiscreteRequirement(item) => web_common::database::tables::TableRow::ProjectDiscreteRequirement(item.into()),
            TableRow::ProjectMilestone(item) => web_common::database::tables::TableRow::ProjectMilestone(item.into()),
            TableRow::ProjectState(item) => web_common::database::tables::TableRow::ProjectState(item.into()),
            TableRow::Project(item) => web_common::database::tables::TableRow::Project(item.into()),
            TableRow::Role(item) => web_common::database::tables::TableRow::Role(item.into()),
            TableRow::SampleTaxa(item) => web_common::database::tables::TableRow::SampleTaxa(item.into()),
            TableRow::SampledIndividualTaxa(item) => web_common::database::tables::TableRow::SampledIndividualTaxa(item.into()),
            TableRow::SampledIndividual(item) => web_common::database::tables::TableRow::SampledIndividual(item.into()),
            TableRow::Sample(item) => web_common::database::tables::TableRow::Sample(item.into()),
            TableRow::Spectra(item) => web_common::database::tables::TableRow::Spectra(item.into()),
            TableRow::SpectraCollection(item) => web_common::database::tables::TableRow::SpectraCollection(item.into()),
            TableRow::Taxa(item) => web_common::database::tables::TableRow::Taxa(item.into()),
            TableRow::TeamAuthorization(item) => web_common::database::tables::TableRow::TeamAuthorization(item.into()),
            TableRow::TeamState(item) => web_common::database::tables::TableRow::TeamState(item.into()),
            TableRow::Team(item) => web_common::database::tables::TableRow::Team(item.into()),
            TableRow::Unit(item) => web_common::database::tables::TableRow::Unit(item.into()),
            TableRow::UserAuthorization(item) => web_common::database::tables::TableRow::UserAuthorization(item.into()),
            TableRow::UserEmail(item) => web_common::database::tables::TableRow::UserEmail(item.into()),
            TableRow::User(item) => web_common::database::tables::TableRow::User(item.into()),
        }
    }
}
impl From<Archivable> for TableRow {
    fn from(item: Archivable) -> Self {
        TableRow::Archivable(item)
    }
}
impl From<ContainerHorizontalRule> for TableRow {
    fn from(item: ContainerHorizontalRule) -> Self {
        TableRow::ContainerHorizontalRule(item)
    }
}
impl From<ContainerVerticalRule> for TableRow {
    fn from(item: ContainerVerticalRule) -> Self {
        TableRow::ContainerVerticalRule(item)
    }
}
impl From<ContinuousUnit> for TableRow {
    fn from(item: ContinuousUnit) -> Self {
        TableRow::ContinuousUnit(item)
    }
}
impl From<Describable> for TableRow {
    fn from(item: Describable) -> Self {
        TableRow::Describable(item)
    }
}
impl From<DiscreteUnit> for TableRow {
    fn from(item: DiscreteUnit) -> Self {
        TableRow::DiscreteUnit(item)
    }
}
impl From<DocumentFormat> for TableRow {
    fn from(item: DocumentFormat) -> Self {
        TableRow::DocumentFormat(item)
    }
}
impl From<Document> for TableRow {
    fn from(item: Document) -> Self {
        TableRow::Document(item)
    }
}
impl From<Editable> for TableRow {
    fn from(item: Editable) -> Self {
        TableRow::Editable(item)
    }
}
impl From<Edit> for TableRow {
    fn from(item: Edit) -> Self {
        TableRow::Edit(item)
    }
}
impl From<ItemCategory> for TableRow {
    fn from(item: ItemCategory) -> Self {
        TableRow::ItemCategory(item)
    }
}
impl From<ItemCategoryRelationship> for TableRow {
    fn from(item: ItemCategoryRelationship) -> Self {
        TableRow::ItemCategoryRelationship(item)
    }
}
impl From<ItemCategoryUnit> for TableRow {
    fn from(item: ItemCategoryUnit) -> Self {
        TableRow::ItemCategoryUnit(item)
    }
}
impl From<ItemContinuousQuantity> for TableRow {
    fn from(item: ItemContinuousQuantity) -> Self {
        TableRow::ItemContinuousQuantity(item)
    }
}
impl From<ItemDiscreteQuantity> for TableRow {
    fn from(item: ItemDiscreteQuantity) -> Self {
        TableRow::ItemDiscreteQuantity(item)
    }
}
impl From<ItemLocation> for TableRow {
    fn from(item: ItemLocation) -> Self {
        TableRow::ItemLocation(item)
    }
}
impl From<ItemUnit> for TableRow {
    fn from(item: ItemUnit) -> Self {
        TableRow::ItemUnit(item)
    }
}
impl From<Item> for TableRow {
    fn from(item: Item) -> Self {
        TableRow::Item(item)
    }
}
impl From<LocationState> for TableRow {
    fn from(item: LocationState) -> Self {
        TableRow::LocationState(item)
    }
}
impl From<Location> for TableRow {
    fn from(item: Location) -> Self {
        TableRow::Location(item)
    }
}
impl From<LoginProvider> for TableRow {
    fn from(item: LoginProvider) -> Self {
        TableRow::LoginProvider(item)
    }
}
impl From<ManufacturedItemCategory> for TableRow {
    fn from(item: ManufacturedItemCategory) -> Self {
        TableRow::ManufacturedItemCategory(item)
    }
}
impl From<Notification> for TableRow {
    fn from(item: Notification) -> Self {
        TableRow::Notification(item)
    }
}
impl From<OrganizationAuthorization> for TableRow {
    fn from(item: OrganizationAuthorization) -> Self {
        TableRow::OrganizationAuthorization(item)
    }
}
impl From<OrganizationLocation> for TableRow {
    fn from(item: OrganizationLocation) -> Self {
        TableRow::OrganizationLocation(item)
    }
}
impl From<OrganizationState> for TableRow {
    fn from(item: OrganizationState) -> Self {
        TableRow::OrganizationState(item)
    }
}
impl From<Organization> for TableRow {
    fn from(item: Organization) -> Self {
        TableRow::Organization(item)
    }
}
impl From<PrimaryUserEmail> for TableRow {
    fn from(item: PrimaryUserEmail) -> Self {
        TableRow::PrimaryUserEmail(item)
    }
}
impl From<ProcedureContinuousRequirement> for TableRow {
    fn from(item: ProcedureContinuousRequirement) -> Self {
        TableRow::ProcedureContinuousRequirement(item)
    }
}
impl From<ProcedureDiscreteRequirement> for TableRow {
    fn from(item: ProcedureDiscreteRequirement) -> Self {
        TableRow::ProcedureDiscreteRequirement(item)
    }
}
impl From<Procedure> for TableRow {
    fn from(item: Procedure) -> Self {
        TableRow::Procedure(item)
    }
}
impl From<ProjectContinuousRequirement> for TableRow {
    fn from(item: ProjectContinuousRequirement) -> Self {
        TableRow::ProjectContinuousRequirement(item)
    }
}
impl From<ProjectDiscreteRequirement> for TableRow {
    fn from(item: ProjectDiscreteRequirement) -> Self {
        TableRow::ProjectDiscreteRequirement(item)
    }
}
impl From<ProjectMilestone> for TableRow {
    fn from(item: ProjectMilestone) -> Self {
        TableRow::ProjectMilestone(item)
    }
}
impl From<ProjectState> for TableRow {
    fn from(item: ProjectState) -> Self {
        TableRow::ProjectState(item)
    }
}
impl From<Project> for TableRow {
    fn from(item: Project) -> Self {
        TableRow::Project(item)
    }
}
impl From<Role> for TableRow {
    fn from(item: Role) -> Self {
        TableRow::Role(item)
    }
}
impl From<SampleTaxa> for TableRow {
    fn from(item: SampleTaxa) -> Self {
        TableRow::SampleTaxa(item)
    }
}
impl From<SampledIndividualTaxa> for TableRow {
    fn from(item: SampledIndividualTaxa) -> Self {
        TableRow::SampledIndividualTaxa(item)
    }
}
impl From<SampledIndividual> for TableRow {
    fn from(item: SampledIndividual) -> Self {
        TableRow::SampledIndividual(item)
    }
}
impl From<Sample> for TableRow {
    fn from(item: Sample) -> Self {
        TableRow::Sample(item)
    }
}
impl From<Spectra> for TableRow {
    fn from(item: Spectra) -> Self {
        TableRow::Spectra(item)
    }
}
impl From<SpectraCollection> for TableRow {
    fn from(item: SpectraCollection) -> Self {
        TableRow::SpectraCollection(item)
    }
}
impl From<Taxa> for TableRow {
    fn from(item: Taxa) -> Self {
        TableRow::Taxa(item)
    }
}
impl From<TeamAuthorization> for TableRow {
    fn from(item: TeamAuthorization) -> Self {
        TableRow::TeamAuthorization(item)
    }
}
impl From<TeamState> for TableRow {
    fn from(item: TeamState) -> Self {
        TableRow::TeamState(item)
    }
}
impl From<Team> for TableRow {
    fn from(item: Team) -> Self {
        TableRow::Team(item)
    }
}
impl From<Unit> for TableRow {
    fn from(item: Unit) -> Self {
        TableRow::Unit(item)
    }
}
impl From<UserAuthorization> for TableRow {
    fn from(item: UserAuthorization) -> Self {
        TableRow::UserAuthorization(item)
    }
}
impl From<UserEmail> for TableRow {
    fn from(item: UserEmail) -> Self {
        TableRow::UserEmail(item)
    }
}
impl From<User> for TableRow {
    fn from(item: User) -> Self {
        TableRow::User(item)
    }
}
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Copy, Eq, )]
pub enum Table {
    Archivable,
    ContainerHorizontalRule,
    ContainerVerticalRule,
    ContinuousUnit,
    Describable,
    DiscreteUnit,
    DocumentFormat,
    Document,
    Editable,
    Edit,
    ItemCategory,
    ItemCategoryRelationship,
    ItemCategoryUnit,
    ItemContinuousQuantity,
    ItemDiscreteQuantity,
    ItemLocation,
    ItemUnit,
    Item,
    LocationState,
    Location,
    LoginProvider,
    ManufacturedItemCategory,
    Notification,
    OrganizationAuthorization,
    OrganizationLocation,
    OrganizationState,
    Organization,
    PrimaryUserEmail,
    ProcedureContinuousRequirement,
    ProcedureDiscreteRequirement,
    Procedure,
    ProjectContinuousRequirement,
    ProjectDiscreteRequirement,
    ProjectMilestone,
    ProjectState,
    Project,
    Role,
    SampleTaxa,
    SampledIndividualTaxa,
    SampledIndividual,
    Sample,
    Spectra,
    SpectraCollection,
    Taxa,
    TeamAuthorization,
    TeamState,
    Team,
    Unit,
    UserAuthorization,
    UserEmail,
    User,
}

impl Table {
    pub fn name(&self) -> &'static str {
        match self {
            Table::Archivable => "archivables",
            Table::ContainerHorizontalRule => "container_horizontal_rules",
            Table::ContainerVerticalRule => "container_vertical_rules",
            Table::ContinuousUnit => "continuous_units",
            Table::Describable => "describables",
            Table::DiscreteUnit => "discrete_units",
            Table::DocumentFormat => "document_formats",
            Table::Document => "documents",
            Table::Editable => "editables",
            Table::Edit => "edits",
            Table::ItemCategory => "item_categories",
            Table::ItemCategoryRelationship => "item_category_relationships",
            Table::ItemCategoryUnit => "item_category_units",
            Table::ItemContinuousQuantity => "item_continuous_quantities",
            Table::ItemDiscreteQuantity => "item_discrete_quantities",
            Table::ItemLocation => "item_locations",
            Table::ItemUnit => "item_units",
            Table::Item => "items",
            Table::LocationState => "location_states",
            Table::Location => "locations",
            Table::LoginProvider => "login_providers",
            Table::ManufacturedItemCategory => "manufactured_item_categories",
            Table::Notification => "notifications",
            Table::OrganizationAuthorization => "organization_authorizations",
            Table::OrganizationLocation => "organization_locations",
            Table::OrganizationState => "organization_states",
            Table::Organization => "organizations",
            Table::PrimaryUserEmail => "primary_user_emails",
            Table::ProcedureContinuousRequirement => "procedure_continuous_requirements",
            Table::ProcedureDiscreteRequirement => "procedure_discrete_requirements",
            Table::Procedure => "procedures",
            Table::ProjectContinuousRequirement => "project_continuous_requirements",
            Table::ProjectDiscreteRequirement => "project_discrete_requirements",
            Table::ProjectMilestone => "project_milestones",
            Table::ProjectState => "project_states",
            Table::Project => "projects",
            Table::Role => "roles",
            Table::SampleTaxa => "sample_taxa",
            Table::SampledIndividualTaxa => "sampled_individual_taxa",
            Table::SampledIndividual => "sampled_individuals",
            Table::Sample => "samples",
            Table::Spectra => "spectra",
            Table::SpectraCollection => "spectra_collection",
            Table::Taxa => "taxa",
            Table::TeamAuthorization => "team_authorizations",
            Table::TeamState => "team_states",
            Table::Team => "teams",
            Table::Unit => "units",
            Table::UserAuthorization => "user_authorizations",
            Table::UserEmail => "user_emails",
            Table::User => "users",
        }
    }
    /// Get the struct from the database by its ID.
    ///
    /// # Arguments
    /// * `id` - The ID of the struct to get.
    /// * `connection` - The connection to the database.
    ///
    pub fn get(
        &self,
        id: Uuid,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<TableRow, diesel::result::Error> {
        Ok(match self {
            Table::Archivable => TableRow::Archivable(Archivable::get(id, connection)?),
            Table::ContainerHorizontalRule => TableRow::ContainerHorizontalRule(ContainerHorizontalRule::get(id, connection)?),
            Table::ContainerVerticalRule => TableRow::ContainerVerticalRule(ContainerVerticalRule::get(id, connection)?),
            Table::ContinuousUnit => TableRow::ContinuousUnit(ContinuousUnit::get(id, connection)?),
            Table::Describable => TableRow::Describable(Describable::get(id, connection)?),
            Table::DiscreteUnit => TableRow::DiscreteUnit(DiscreteUnit::get(id, connection)?),
            Table::DocumentFormat => TableRow::DocumentFormat(DocumentFormat::get(id, connection)?),
            Table::Document => TableRow::Document(Document::get(id, connection)?),
            Table::Editable => TableRow::Editable(Editable::get(id, connection)?),
            Table::Edit => TableRow::Edit(Edit::get(id, connection)?),
            Table::ItemCategory => TableRow::ItemCategory(ItemCategory::get(id, connection)?),
            Table::ItemCategoryRelationship => TableRow::ItemCategoryRelationship(ItemCategoryRelationship::get(id, connection)?),
            Table::ItemCategoryUnit => TableRow::ItemCategoryUnit(ItemCategoryUnit::get(id, connection)?),
            Table::ItemContinuousQuantity => TableRow::ItemContinuousQuantity(ItemContinuousQuantity::get(id, connection)?),
            Table::ItemDiscreteQuantity => TableRow::ItemDiscreteQuantity(ItemDiscreteQuantity::get(id, connection)?),
            Table::ItemLocation => TableRow::ItemLocation(ItemLocation::get(id, connection)?),
            Table::ItemUnit => TableRow::ItemUnit(ItemUnit::get(id, connection)?),
            Table::Item => TableRow::Item(Item::get(id, connection)?),
            Table::LocationState => TableRow::LocationState(LocationState::get(id, connection)?),
            Table::Location => TableRow::Location(Location::get(id, connection)?),
            Table::LoginProvider => TableRow::LoginProvider(LoginProvider::get(id, connection)?),
            Table::ManufacturedItemCategory => TableRow::ManufacturedItemCategory(ManufacturedItemCategory::get(id, connection)?),
            Table::Notification => TableRow::Notification(Notification::get(id, connection)?),
            Table::OrganizationAuthorization => TableRow::OrganizationAuthorization(OrganizationAuthorization::get(id, connection)?),
            Table::OrganizationLocation => TableRow::OrganizationLocation(OrganizationLocation::get(id, connection)?),
            Table::OrganizationState => TableRow::OrganizationState(OrganizationState::get(id, connection)?),
            Table::Organization => TableRow::Organization(Organization::get(id, connection)?),
            Table::PrimaryUserEmail => TableRow::PrimaryUserEmail(PrimaryUserEmail::get(id, connection)?),
            Table::ProcedureContinuousRequirement => TableRow::ProcedureContinuousRequirement(ProcedureContinuousRequirement::get(id, connection)?),
            Table::ProcedureDiscreteRequirement => TableRow::ProcedureDiscreteRequirement(ProcedureDiscreteRequirement::get(id, connection)?),
            Table::Procedure => TableRow::Procedure(Procedure::get(id, connection)?),
            Table::ProjectContinuousRequirement => TableRow::ProjectContinuousRequirement(ProjectContinuousRequirement::get(id, connection)?),
            Table::ProjectDiscreteRequirement => TableRow::ProjectDiscreteRequirement(ProjectDiscreteRequirement::get(id, connection)?),
            Table::ProjectMilestone => TableRow::ProjectMilestone(ProjectMilestone::get(id, connection)?),
            Table::ProjectState => TableRow::ProjectState(ProjectState::get(id, connection)?),
            Table::Project => TableRow::Project(Project::get(id, connection)?),
            Table::Role => TableRow::Role(Role::get(id, connection)?),
            Table::SampleTaxa => TableRow::SampleTaxa(SampleTaxa::get(id, connection)?),
            Table::SampledIndividualTaxa => TableRow::SampledIndividualTaxa(SampledIndividualTaxa::get(id, connection)?),
            Table::SampledIndividual => TableRow::SampledIndividual(SampledIndividual::get(id, connection)?),
            Table::Sample => TableRow::Sample(Sample::get(id, connection)?),
            Table::Spectra => TableRow::Spectra(Spectra::get(id, connection)?),
            Table::SpectraCollection => TableRow::SpectraCollection(SpectraCollection::get(id, connection)?),
            Table::Taxa => TableRow::Taxa(Taxa::get(id, connection)?),
            Table::TeamAuthorization => TableRow::TeamAuthorization(TeamAuthorization::get(id, connection)?),
            Table::TeamState => TableRow::TeamState(TeamState::get(id, connection)?),
            Table::Team => TableRow::Team(Team::get(id, connection)?),
            Table::Unit => TableRow::Unit(Unit::get(id, connection)?),
            Table::UserAuthorization => TableRow::UserAuthorization(UserAuthorization::get(id, connection)?),
            Table::UserEmail => TableRow::UserEmail(UserEmail::get(id, connection)?),
            Table::User => TableRow::User(User::get(id, connection)?),
        })
    }
}
impl std::fmt::Display for Table {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl From<&str> for Table {
    fn from(item: &str) -> Self {
        match item {
            "archivables" => Table::Archivable,
            "container_horizontal_rules" => Table::ContainerHorizontalRule,
            "container_vertical_rules" => Table::ContainerVerticalRule,
            "continuous_units" => Table::ContinuousUnit,
            "describables" => Table::Describable,
            "discrete_units" => Table::DiscreteUnit,
            "document_formats" => Table::DocumentFormat,
            "documents" => Table::Document,
            "editables" => Table::Editable,
            "edits" => Table::Edit,
            "item_categories" => Table::ItemCategory,
            "item_category_relationships" => Table::ItemCategoryRelationship,
            "item_category_units" => Table::ItemCategoryUnit,
            "item_continuous_quantities" => Table::ItemContinuousQuantity,
            "item_discrete_quantities" => Table::ItemDiscreteQuantity,
            "item_locations" => Table::ItemLocation,
            "item_units" => Table::ItemUnit,
            "items" => Table::Item,
            "location_states" => Table::LocationState,
            "locations" => Table::Location,
            "login_providers" => Table::LoginProvider,
            "manufactured_item_categories" => Table::ManufacturedItemCategory,
            "notifications" => Table::Notification,
            "organization_authorizations" => Table::OrganizationAuthorization,
            "organization_locations" => Table::OrganizationLocation,
            "organization_states" => Table::OrganizationState,
            "organizations" => Table::Organization,
            "primary_user_emails" => Table::PrimaryUserEmail,
            "procedure_continuous_requirements" => Table::ProcedureContinuousRequirement,
            "procedure_discrete_requirements" => Table::ProcedureDiscreteRequirement,
            "procedures" => Table::Procedure,
            "project_continuous_requirements" => Table::ProjectContinuousRequirement,
            "project_discrete_requirements" => Table::ProjectDiscreteRequirement,
            "project_milestones" => Table::ProjectMilestone,
            "project_states" => Table::ProjectState,
            "projects" => Table::Project,
            "roles" => Table::Role,
            "sample_taxa" => Table::SampleTaxa,
            "sampled_individual_taxa" => Table::SampledIndividualTaxa,
            "sampled_individuals" => Table::SampledIndividual,
            "samples" => Table::Sample,
            "spectra" => Table::Spectra,
            "spectra_collection" => Table::SpectraCollection,
            "taxa" => Table::Taxa,
            "team_authorizations" => Table::TeamAuthorization,
            "team_states" => Table::TeamState,
            "teams" => Table::Team,
            "units" => Table::Unit,
            "user_authorizations" => Table::UserAuthorization,
            "user_emails" => Table::UserEmail,
            "users" => Table::User,
            _ => panic!("Unknown tables name"),
        }
    }
}
impl From<web_common::database::tables::Table> for Table {
    fn from(item: web_common::database::tables::Table) -> Self {
        match item {
            web_common::database::tables::Table::Archivable => Table::Archivable,
            web_common::database::tables::Table::ContainerHorizontalRule => Table::ContainerHorizontalRule,
            web_common::database::tables::Table::ContainerVerticalRule => Table::ContainerVerticalRule,
            web_common::database::tables::Table::ContinuousUnit => Table::ContinuousUnit,
            web_common::database::tables::Table::Describable => Table::Describable,
            web_common::database::tables::Table::DiscreteUnit => Table::DiscreteUnit,
            web_common::database::tables::Table::DocumentFormat => Table::DocumentFormat,
            web_common::database::tables::Table::Document => Table::Document,
            web_common::database::tables::Table::Editable => Table::Editable,
            web_common::database::tables::Table::Edit => Table::Edit,
            web_common::database::tables::Table::ItemCategory => Table::ItemCategory,
            web_common::database::tables::Table::ItemCategoryRelationship => Table::ItemCategoryRelationship,
            web_common::database::tables::Table::ItemCategoryUnit => Table::ItemCategoryUnit,
            web_common::database::tables::Table::ItemContinuousQuantity => Table::ItemContinuousQuantity,
            web_common::database::tables::Table::ItemDiscreteQuantity => Table::ItemDiscreteQuantity,
            web_common::database::tables::Table::ItemLocation => Table::ItemLocation,
            web_common::database::tables::Table::ItemUnit => Table::ItemUnit,
            web_common::database::tables::Table::Item => Table::Item,
            web_common::database::tables::Table::LocationState => Table::LocationState,
            web_common::database::tables::Table::Location => Table::Location,
            web_common::database::tables::Table::LoginProvider => Table::LoginProvider,
            web_common::database::tables::Table::ManufacturedItemCategory => Table::ManufacturedItemCategory,
            web_common::database::tables::Table::Notification => Table::Notification,
            web_common::database::tables::Table::OrganizationAuthorization => Table::OrganizationAuthorization,
            web_common::database::tables::Table::OrganizationLocation => Table::OrganizationLocation,
            web_common::database::tables::Table::OrganizationState => Table::OrganizationState,
            web_common::database::tables::Table::Organization => Table::Organization,
            web_common::database::tables::Table::PrimaryUserEmail => Table::PrimaryUserEmail,
            web_common::database::tables::Table::ProcedureContinuousRequirement => Table::ProcedureContinuousRequirement,
            web_common::database::tables::Table::ProcedureDiscreteRequirement => Table::ProcedureDiscreteRequirement,
            web_common::database::tables::Table::Procedure => Table::Procedure,
            web_common::database::tables::Table::ProjectContinuousRequirement => Table::ProjectContinuousRequirement,
            web_common::database::tables::Table::ProjectDiscreteRequirement => Table::ProjectDiscreteRequirement,
            web_common::database::tables::Table::ProjectMilestone => Table::ProjectMilestone,
            web_common::database::tables::Table::ProjectState => Table::ProjectState,
            web_common::database::tables::Table::Project => Table::Project,
            web_common::database::tables::Table::Role => Table::Role,
            web_common::database::tables::Table::SampleTaxa => Table::SampleTaxa,
            web_common::database::tables::Table::SampledIndividualTaxa => Table::SampledIndividualTaxa,
            web_common::database::tables::Table::SampledIndividual => Table::SampledIndividual,
            web_common::database::tables::Table::Sample => Table::Sample,
            web_common::database::tables::Table::Spectra => Table::Spectra,
            web_common::database::tables::Table::SpectraCollection => Table::SpectraCollection,
            web_common::database::tables::Table::Taxa => Table::Taxa,
            web_common::database::tables::Table::TeamAuthorization => Table::TeamAuthorization,
            web_common::database::tables::Table::TeamState => Table::TeamState,
            web_common::database::tables::Table::Team => Table::Team,
            web_common::database::tables::Table::Unit => Table::Unit,
            web_common::database::tables::Table::UserAuthorization => Table::UserAuthorization,
            web_common::database::tables::Table::UserEmail => Table::UserEmail,
            web_common::database::tables::Table::User => Table::User,
        }
    }
}
impl From<Table> for web_common::database::tables::Table {
    fn from(item: Table) -> Self {
        match item {
            Table::Archivable => web_common::database::tables::Table::Archivable,
            Table::ContainerHorizontalRule => web_common::database::tables::Table::ContainerHorizontalRule,
            Table::ContainerVerticalRule => web_common::database::tables::Table::ContainerVerticalRule,
            Table::ContinuousUnit => web_common::database::tables::Table::ContinuousUnit,
            Table::Describable => web_common::database::tables::Table::Describable,
            Table::DiscreteUnit => web_common::database::tables::Table::DiscreteUnit,
            Table::DocumentFormat => web_common::database::tables::Table::DocumentFormat,
            Table::Document => web_common::database::tables::Table::Document,
            Table::Editable => web_common::database::tables::Table::Editable,
            Table::Edit => web_common::database::tables::Table::Edit,
            Table::ItemCategory => web_common::database::tables::Table::ItemCategory,
            Table::ItemCategoryRelationship => web_common::database::tables::Table::ItemCategoryRelationship,
            Table::ItemCategoryUnit => web_common::database::tables::Table::ItemCategoryUnit,
            Table::ItemContinuousQuantity => web_common::database::tables::Table::ItemContinuousQuantity,
            Table::ItemDiscreteQuantity => web_common::database::tables::Table::ItemDiscreteQuantity,
            Table::ItemLocation => web_common::database::tables::Table::ItemLocation,
            Table::ItemUnit => web_common::database::tables::Table::ItemUnit,
            Table::Item => web_common::database::tables::Table::Item,
            Table::LocationState => web_common::database::tables::Table::LocationState,
            Table::Location => web_common::database::tables::Table::Location,
            Table::LoginProvider => web_common::database::tables::Table::LoginProvider,
            Table::ManufacturedItemCategory => web_common::database::tables::Table::ManufacturedItemCategory,
            Table::Notification => web_common::database::tables::Table::Notification,
            Table::OrganizationAuthorization => web_common::database::tables::Table::OrganizationAuthorization,
            Table::OrganizationLocation => web_common::database::tables::Table::OrganizationLocation,
            Table::OrganizationState => web_common::database::tables::Table::OrganizationState,
            Table::Organization => web_common::database::tables::Table::Organization,
            Table::PrimaryUserEmail => web_common::database::tables::Table::PrimaryUserEmail,
            Table::ProcedureContinuousRequirement => web_common::database::tables::Table::ProcedureContinuousRequirement,
            Table::ProcedureDiscreteRequirement => web_common::database::tables::Table::ProcedureDiscreteRequirement,
            Table::Procedure => web_common::database::tables::Table::Procedure,
            Table::ProjectContinuousRequirement => web_common::database::tables::Table::ProjectContinuousRequirement,
            Table::ProjectDiscreteRequirement => web_common::database::tables::Table::ProjectDiscreteRequirement,
            Table::ProjectMilestone => web_common::database::tables::Table::ProjectMilestone,
            Table::ProjectState => web_common::database::tables::Table::ProjectState,
            Table::Project => web_common::database::tables::Table::Project,
            Table::Role => web_common::database::tables::Table::Role,
            Table::SampleTaxa => web_common::database::tables::Table::SampleTaxa,
            Table::SampledIndividualTaxa => web_common::database::tables::Table::SampledIndividualTaxa,
            Table::SampledIndividual => web_common::database::tables::Table::SampledIndividual,
            Table::Sample => web_common::database::tables::Table::Sample,
            Table::Spectra => web_common::database::tables::Table::Spectra,
            Table::SpectraCollection => web_common::database::tables::Table::SpectraCollection,
            Table::Taxa => web_common::database::tables::Table::Taxa,
            Table::TeamAuthorization => web_common::database::tables::Table::TeamAuthorization,
            Table::TeamState => web_common::database::tables::Table::TeamState,
            Table::Team => web_common::database::tables::Table::Team,
            Table::Unit => web_common::database::tables::Table::Unit,
            Table::UserAuthorization => web_common::database::tables::Table::UserAuthorization,
            Table::UserEmail => web_common::database::tables::Table::UserEmail,
            Table::User => web_common::database::tables::Table::User,
        }
    }
}
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Copy, Eq, )]
pub enum SearcheableTable {
    ProjectState,
    Project,
    Taxa,
    User,
}

impl SearcheableTable {
    /// Search for the struct by a given string.
    ///
    /// # Arguments
    /// * `query` - The string to search for.
    /// * `limit` - The maximum number of results, by default `10`.
    /// * `threshold` - The similarity threshold, by default `0.6`.
    /// * `connection` - The connection to the database.
    ///
    pub fn search(
        &self,
        query: &str,
        limit: Option<i32>,
        threshold: Option<f64>,
        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>
    ) -> Result<Vec<TableRow>, diesel::result::Error> {
        Ok(match self {
            SearcheableTable::ProjectState => ProjectState::search(query, limit, threshold, connection)?.into_iter().map(TableRow::from).collect::<Vec<TableRow>>(),
            SearcheableTable::Project => Project::search(query, limit, threshold, connection)?.into_iter().map(TableRow::from).collect::<Vec<TableRow>>(),
            SearcheableTable::Taxa => Taxa::search(query, limit, threshold, connection)?.into_iter().map(TableRow::from).collect::<Vec<TableRow>>(),
            SearcheableTable::User => User::search(query, limit, threshold, connection)?.into_iter().map(TableRow::from).collect::<Vec<TableRow>>(),
        })
    }
}
impl From<&str> for SearcheableTable {
    fn from(item: &str) -> Self {
        match item {
            "project_states" => SearcheableTable::ProjectState,
            "projects" => SearcheableTable::Project,
            "taxa" => SearcheableTable::Taxa,
            "users" => SearcheableTable::User,
            _ => panic!("Unknown tables name"),
        }
    }
}
impl From<SearcheableTable> for web_common::database::tables::SearcheableTable {
    fn from(item: SearcheableTable) -> Self {
        match item {
            SearcheableTable::ProjectState => web_common::database::tables::SearcheableTable::ProjectState,
            SearcheableTable::Project => web_common::database::tables::SearcheableTable::Project,
            SearcheableTable::Taxa => web_common::database::tables::SearcheableTable::Taxa,
            SearcheableTable::User => web_common::database::tables::SearcheableTable::User,
        }
    }
}
impl From<web_common::database::tables::SearcheableTable> for SearcheableTable {
    fn from(item: web_common::database::tables::SearcheableTable) -> Self {
        match item {
            web_common::database::tables::SearcheableTable::ProjectState => SearcheableTable::ProjectState,
            web_common::database::tables::SearcheableTable::Project => SearcheableTable::Project,
            web_common::database::tables::SearcheableTable::Taxa => SearcheableTable::Taxa,
            web_common::database::tables::SearcheableTable::User => SearcheableTable::User,
        }
    }
}
