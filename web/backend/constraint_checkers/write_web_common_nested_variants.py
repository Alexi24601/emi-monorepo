"""This module contains the function to write the nested structs to the web_common crate."""

from typing import List
import os
from tqdm.auto import tqdm
from constraint_checkers.struct_metadata import StructMetadata, MethodDefinition, AttributeMetadata

# from constraint_checkers.rust_implementation_check import trait_implementation_exist
from constraint_checkers.is_file_changed import is_file_changed
from constraint_checkers.migrations_changed import are_migrations_changed


def write_web_common_nested_variants(nested_structs: List[StructMetadata]):
    """Writes the nested structs to the web_common crate."""

    if not (
        are_migrations_changed()
        or is_file_changed(__file__)
        or is_file_changed("./constraint_checkers/write_web_common_flat_variants.py")
    ):
        print(
            "No change in migrations or file. Skipping writing frontend nested variants."
        )
        return

    # We open the file to write the nested structs
    path = "../web_common/src/database/nested_variants.rs"
    directory = path.rsplit(".", maxsplit=1)[0]
    os.makedirs(directory, exist_ok=True)
    document_module = open(path, "w", encoding="utf8")

    warning = (
        "//! This module contains the nested structs for the database tables.\n"
        "//!\n"
        "//! This file is automatically generated. Do not write anything here.\n\n"
    )

    # Preliminarly, we write a docstring at the very head
    # of this submodule to explain what it does and warn the
    # reader not to write anything in this file as it is
    # automatically generated.
    document_module.write(warning)

    # We start with the necessary imports.
    imports = [
        "use std::rc::Rc;",
    ]

    for nested_struct in tqdm(
        nested_structs,
        desc="Writing wecommon nested structs",
        unit="nested struct",
        leave=False,
    ):
        document = open(
            f"{directory}/{nested_struct.table_name}.rs", "w", encoding="utf8"
        )
        document.write(warning)
        document.write("\n".join(imports) + "\n\n")

        document_module.write(
            f"mod {nested_struct.table_name};\n"
            f"pub use {nested_struct.table_name}::*;\n\n"
        )

        nested_struct.write_to(document)

        document.write(
            f"impl crate::database::Tabular for {nested_struct.name} {{\n"
            f"    const TABLE: crate::database::Table = crate::database::Table::{nested_struct.capitalized_table_name()};\n"
            "}\n"
        )

        if nested_struct.has_filter_variant():
            filter_variant = nested_struct.get_filter_variant()

            document.write(
                f"impl crate::database::Filtrable for {nested_struct.name} {{\n"
                f"    type Filter = {filter_variant.full_path(route='web_common')};\n"
                "}\n"
            )

        # if not trait_implementation_exist(
        #     "Describable",
        #     nested_struct.name,
        #     deny_file_list=("database/nested_variants",),
        #     root="webcommon",
        # ):
        inner = nested_struct.get_inner_attribute()

        document.write(
            f"impl crate::database::Describable for {nested_struct.name} {{\n"
            "    fn description(&self) -> Option<&str> {\n"
        )
        if inner is not None:
            document.write("        self.inner.description()\n")
        else:
            document.write("        None\n")
        document.write("    }\n}\n")

        # if not trait_implementation_exist(
        #     "Colorable",
        #     nested_struct.name,
        #     deny_file_list=("database/nested_variants.rs",),
        #     root="webcommon",
        # ):
        color_attribute = nested_struct.get_color_attribute()

        document.write(
            f"impl crate::database::Colorable for {nested_struct.name} {{\n"
            "    fn color(&self) -> Option<&str> {\n"
        )
        if color_attribute:
            if color_attribute.optional:
                document.write(
                    f"        self.{color_attribute.name}.as_ref().map(|color| color.name.as_str())\n"
                )
            else:
                document.write(
                    f"        Some(self.{color_attribute.name}.name.as_str())\n"
                )
        else:
            document.write("        None\n")
        document.write("    }\n}\n")

        underscored_filter = "" if nested_struct.has_filter_variant() else "_"

        document.write(
            '#[cfg(feature = "frontend")]\n'
            f"impl crate::database::AllRecords for {nested_struct.name} {{\n"
            "    fn all_records<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(\n"
            f"        {underscored_filter}filter: Option<&<Self as crate::database::Filtrable>::Filter>,\n"
            "        limit: Option<i64>,\n"
            "        offset: Option<i64>,\n"
            "        connection: &mut gluesql::prelude::Glue<C>,\n"
            "    ) -> impl std::future::Future<Output = Result<Vec<Self>, crate::api::ApiError>> {\n"
        )
        # Depending on whether the struct has a filter variant or not, we
        # write the appropriate code to query the database.
        if nested_struct.has_filter_variant():
            document.write("Self::all(filter, limit, offset, connection)\n")
        else:
            document.write("Self::all(limit, offset, connection)\n")

        document.write("    }\n}\n")

        # We implement the `get` method for the struct when the frontend feature
        # is enabled using GlueSQL. This method will be extremely similar to the
        # `get` method for the Diesel-based approach of the backend.

        flat_variant = nested_struct.get_flat_variant()

        document.write(f'#[cfg(feature = "frontend")]\nimpl {nested_struct.name} {{\n')

        # First, we implement the `from_flat` method that will be used to convert
        # the flat struct to the nested struct. This method receives the flat struct
        # and the connection to the database and returns the nested struct.
        document.write(
            "    /// Convert the flat struct to the nested struct.\n"
            "    ///\n"
            "    /// # Arguments\n"
            "    /// * `flat_variant` - The flat struct.\n"
            "    /// * `connection` - The database connection.\n"
            "    pub(crate) async fn from_flat(\n"
            f"        flat_variant: {flat_variant.full_path(route='web_common')},\n"
            "        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,\n"
            "    ) -> Result<Self, crate::api::ApiError> {\n"
            "        Ok(Self {\n"
        )
        for attribute in nested_struct.attributes:
            if attribute.name == "inner":
                continue
            if attribute.raw_data_type() == nested_struct or flat_variant.has_attribute(
                attribute
            ):
                if attribute.rc:
                    document.write(
                        f"            {attribute.name}: Rc::new(flat_variant.{attribute.name}),\n"
                    )
                else:
                    document.write(
                        f"            {attribute.name}: flat_variant.{attribute.name},\n"
                    )
                continue
            if attribute.optional:
                assert attribute.rc
                document.write(
                    f"            {attribute.name}: if let Some({attribute.original_name}) = flat_variant.{attribute.original_name} {{ {attribute.data_type(route='web_common')}::get({attribute.original_name}, connection).await?.map(Rc::from) }} else {{ None }},\n"
                )
            else:
                assert attribute.rc
                document.write(
                    f"            {attribute.name}: Rc::from({attribute.data_type(route='web_common')}::get(flat_variant.{attribute.original_name}, connection).await?.unwrap()),\n"
                )

        inner_attribute = nested_struct.get_inner_attribute()
        if inner_attribute is not None:
            if inner_attribute.rc:
                document.write("            inner: Rc::from(flat_variant),\n")
            else:
                document.write("            inner: flat_variant,\n")

        document.write("        })\n    }\n")

        contains_struct_that_may_be_hidden = (
            nested_struct.has_attribute_that_may_be_hidden()
        )

        assert len(flat_variant.webcommon_methods()) > 0, (
            "The flat variant must have at least one method. "
            f"The struct {flat_variant.name} has no methods."
        )
        for method in flat_variant.webcommon_methods():
            if method.is_private():
                continue

            if method.name == "update_or_insert":
                # We handle the update_or_insert method separately.
                continue
            return_type = method.get_return_type()
            nested_struct.add_webcommon_method(method.into_new_owner(nested_struct))
            author_user_id = method.get_argument_by_name("author_user_id")
            this_author_user_id_argument = ""

            if author_user_id is None:
                # assert not contains_struct_that_may_be_hidden
                assert this_author_user_id_argument == ""
            elif contains_struct_that_may_be_hidden:
                if author_user_id.optional:
                    this_author_user_id_argument = f"{author_user_id.name}, "
                else:
                    this_author_user_id_argument = f"Some({author_user_id.name}), "

            method.write_header_to(document)

            waits = ".await" if method.is_async else ""

            if (
                not return_type.has_struct_data_type()
                and return_type.raw_data_type()
                == "Result<Vec<Self>, crate::api::ApiError>"
            ):
                document.write(
                    "{\n"
                    f"        let mut {flat_variant.table_name} = Vec::new();\n"
                    f"        for flat_variant in {flat_variant.full_path(route='web_common')}::{method.name}({', '.join(arg.name for arg in method.arguments)}){waits}?.into_iter() {{\n"
                    f"            {flat_variant.table_name}.push(Self::from_flat(flat_variant, {this_author_user_id_argument}connection).await?);\n"
                    "         }\n"
                    f"         Ok({flat_variant.table_name})\n"
                    "}\n"
                )
            elif (
                not return_type.has_struct_data_type()
                and return_type.raw_data_type() == "Result<Self, crate::api::ApiError>"
            ):
                document.write(
                    "{\n"
                    f"        Self::from_flat({flat_variant.full_path(route='web_common')}::{method.name}({', '.join(arg.name for arg in method.arguments)}){waits}?, {this_author_user_id_argument}connection).await\n"
                    "}\n"
                )
            elif (
                not return_type.has_struct_data_type()
                and return_type.raw_data_type()
                == "Result<Option<Self>, crate::api::ApiError>"
            ):
                document.write(
                    "{\n"
                    f"        if let Some(flat_variant) = {flat_variant.full_path(route='web_common')}::{method.name}({', '.join(arg.name for arg in method.arguments)}){waits}? {{\n"
                    f"            Ok(Some(Self::from_flat(flat_variant, {this_author_user_id_argument}connection).await?))\n"
                    "        } else {\n"
                    "            Ok(None)\n"
                    "        }\n"
                    "}\n"
                )
            elif (
                not return_type.has_struct_data_type()
                and "Self" in return_type.raw_data_type()
            ):
                raise NotImplementedError(
                    "All cases returning a Self must be handled. "
                    f"The method {method.name} returns {return_type.format_data_type(route='web_common')}. "
                    f"The method {method.name} is in the struct {nested_struct.name}."
                )
            elif method.has_self_reference():
                assert any(attr.is_inner() for attr in nested_struct.attributes), (
                    "The struct must have at least one inner attribute, which is the flat struct. "
                    f"The struct {nested_struct.name} has the following attributes: {nested_struct.attributes}."
                )

                document.write(
                    "{\n"
                    f"        self.inner.{method.name}({', '.join(arg.name for arg in method.arguments if arg.name != 'self')}){waits}\n"
                    "}\n"
                )
            elif method.has_self_owned():
                assert any(attr.is_inner() for attr in nested_struct.attributes), (
                    "The struct must have at least one inner attribute, which is the flat struct. "
                    f"The struct {nested_struct.name} has the following attributes: {nested_struct.attributes}."
                )

                inner_attribute = nested_struct.get_inner_attribute()
                if inner_attribute.implements_copy():
                    clone = ""
                else:
                    clone = ".as_ref().clone()"
                document.write(
                    "{\n"
                    f"        self.inner{clone}.{method.name}({', '.join(arg.name for arg in method.arguments if arg.name != 'self')}){waits}\n"
                    "}\n"
                )
            else:
                document.write(
                    "{\n"
                    f"        {flat_variant.full_path(route='web_common')}::{method.name}({', '.join(arg.name for arg in method.arguments)}){waits}\n"
                    "}\n"
                )

        # Here we implement the `update_or_insert` method for the nested struct, which
        # dispatches the update_or_insert call to all the internal structs.
        update_or_insert_method = nested_struct.add_webcommon_method(
            MethodDefinition(
                name="update_or_insert",
                summary="Update or insert the record in the database.",
                is_async=True,
            )
        )
        
        update_or_insert_method.add_generic(
            "C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut"
        )

        update_or_insert_method.include_self_ref()

        update_or_insert_method.add_argument(
            AttributeMetadata(
                original_name="connection",
                name="connection",
                data_type="gluesql::prelude::Glue<C>",
                reference=True,
                mutable=True,
            ),
            "The connection to the database.",
        )

        update_or_insert_method.set_return_type(
            AttributeMetadata(
                original_name="_",
                name="_",
                data_type="Result<usize, crate::api::ApiError>",
                optional=False,
            ),
        )
        assert nested_struct.is_nested()

        update_or_insert_method.write_header_to(document)

        document.write(
            "{\n"
        )
        for attribute in nested_struct.attributes:
            if attribute.is_inner():
                continue
            assert attribute.rc
            if attribute.optional:
                document.write(
                    f"if let Some({attribute.name}) = self.{attribute.name}.as_ref() {{\n"
                    f"    {attribute.data_type(route='web_common')}::update_or_insert({attribute.name}, connection).await?;\n"
                    "}\n"
                )
            else:
                document.write(
                    f"{attribute.data_type(route='web_common')}::update_or_insert(self.{attribute.name}.as_ref(), connection).await?;\n"
                )

        inner_attribute = nested_struct.get_inner_attribute()
        if inner_attribute is not None:
            assert not inner_attribute.optional
            if inner_attribute.rc:
                document.write(
                    f"{inner_attribute.data_type(route='web_common')}::update_or_insert(self.inner.as_ref(), connection).await\n"
                )
            else:
                document.write(
                    f"{inner_attribute.data_type(route='web_common')}::update_or_insert(&self.inner, connection).await\n"
                )
        else:
            document.write(
                "        Ok(1)\n"
            )

        document.write(
            "}\n}\n"
        )

    document.flush()
    document.close()
