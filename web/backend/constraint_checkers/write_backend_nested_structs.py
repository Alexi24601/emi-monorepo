"""Write the nested structs to the backend crate."""

from typing import List
from constraint_checkers.struct_metadata import StructMetadata
from constraint_checkers.indices import PGIndices


def write_backend_nested_structs(nested_structs: List[StructMetadata]):
    """Write the nested structs to the backend crate."""
    assert isinstance(nested_structs, list), "The nested structs must be a list."
    assert all(
        isinstance(nested_struct, StructMetadata) for nested_struct in nested_structs
    ), "All the nested structs must be of type StructMetadata."
    assert len(nested_structs) > 0, "No nested structs to write."

    # We open the file to write the nested structs
    document = open("./src/nested_models.rs", "w", encoding="utf8")

    # We start with the necessary imports.
    imports = [
        "use serde::Deserialize;",
        "use serde::Serialize;",
        "use diesel::r2d2::ConnectionManager;",
        "use diesel::r2d2::PooledConnection;",
        "use uuid::Uuid;",
        "use crate::models::*;",
        # "use crate::views::views::*;",
    ]

    document.write("\n".join(imports) + "\n\n")

    # Preliminarly, we write a docstring at the very head
    # of this submodule to explain what it does and warn the
    # reader not to write anything in this file as it is
    # automatically generated.
    document.write(
        "//! This module contains the nested structs for the database tables.\n"
        "//!\n"
        "//! This file is automatically generated. Do not write anything here.\n\n"
    )

    for nested_struct in nested_structs:
        nested_struct.write_to(document)
        flat_variant = nested_struct.get_flat_variant()

        # We implement the all for the nested structs

        # First, we implement a method that will be reused by several of the following methods,
        # including the all, get and search ones: a method that given the flat struct and a connection
        # to the database returns a result containing the nested struct.
        document.write(
            f"impl {nested_struct.name} {{\n"
            "    /// Convert the flat struct to the nested struct.\n"
            "    ///\n"
            "    /// # Arguments\n"
            "    /// * `flat_variant` - The flat struct.\n"
            "    /// * `connection` - The database connection.\n"
            "    pub fn from_flat(\n"
            f"        flat_variant: {flat_variant.name},\n"
            "        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,\n"
            "    ) -> Result<Self, diesel::result::Error> {\n"
            "        Ok(Self {\n"
        )
        for attribute in nested_struct.attributes:
            if attribute.name == "inner":
                continue
            if (
                attribute.data_type() == nested_struct.name
                or flat_variant.has_attribute(attribute)
            ):
                document.write(
                    f"            {attribute.name}: flat_variant.{attribute.name},\n"
                )
                continue
            if attribute.optional:
                document.write(
                    f"            {attribute.name}: flat_variant.{attribute.original_name}.map(|flat_variant| {attribute.data_type()}::get(flat_variant, connection)).transpose()?,\n"
                )
            else:
                document.write(
                    f"            {attribute.name}: {attribute.data_type()}::get(flat_variant.{attribute.original_name}, connection)?,\n"
                )

        document.write("                inner: flat_variant,\n        })\n    }\n}\n")

        # Then we implement the all query.

        document.write(
            f"impl {nested_struct.name} {{\n"
            "    /// Get all the nested structs from the database.\n"
            "    ///\n"
            "    /// # Arguments\n"
        )
        if nested_struct.has_filter_variant():
            document.write("    /// * `filter` - The filter to apply to the results.\n")
        document.write(
            "    /// * `limit` - The maximum number of rows to return. By default `10`.\n"
            "    /// * `offset` - The offset of the rows to return. By default `0`.\n"
            "    /// * `connection` - The database connection.\n"
            "    pub fn all(\n"
        )
        if nested_struct.has_filter_variant():
            filter_variant = nested_struct.get_filter_variant()
            document.write(
                f"        filter: Option<&web_common::database::{filter_variant.name}>,\n"
            )
        document.write(
            "        limit: Option<i64>,\n"
            "        offset: Option<i64>,\n"
            "        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,\n"
            "    ) -> Result<Vec<Self>, diesel::result::Error> {\n"
        )
        if nested_struct.has_filter_variant():
            document.write(
                f"        {flat_variant.name}::all(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()\n"
            )
        else:
            document.write(
                f"        {flat_variant.name}::all(limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()\n"
            )
        document.write("    }\n}\n")

        if nested_struct.has_associated_roles() and nested_struct.table_name != "users":
            document.write(
                f"impl {nested_struct.name} {{\n"
                "    /// Get all the editables nested structs from the database.\n"
                "    ///\n"
                "    /// # Arguments\n"
                "    /// * `author_user_id` - The user id.\n"
            )
            if nested_struct.has_filter_variant():
                document.write(
                    "    /// * `filter` - The filter to apply to the results.\n"
                )
            document.write(
                "    /// * `limit` - The maximum number of rows to return. By default `10`.\n"
                "    /// * `offset` - The offset of the rows to return. By default `0`.\n"
                "    /// * `connection` - The database connection.\n"
                "    pub fn all_editables(\n"
                "        author_user_id: i32,\n"
            )
            if nested_struct.has_filter_variant():
                filter_variant = nested_struct.get_filter_variant()
                document.write(
                    f"        filter: Option<&web_common::database::{filter_variant.name}>,\n"
                )
            document.write(
                "        limit: Option<i64>,\n"
                "        offset: Option<i64>,\n"
                "        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,\n"
                "    ) -> Result<Vec<Self>, diesel::result::Error> {\n"
            )
            if nested_struct.has_filter_variant():
                document.write(
                    f"        {flat_variant.name}::all_editables(author_user_id, filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()\n"
                )
            else:
                document.write(
                    f"        {flat_variant.name}::all_editables(author_user_id, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()\n"
                )
            document.write("    }\n}\n")

        # Then, for all the tables that have an updated_at column, we implement the
        # `all_by_updated_at` method, which returns all of the nested structs ordered
        # by the `updated_at` column.
        if flat_variant.table_metadata.has_updated_at_column(flat_variant.table_name):
            document.write(
                f"impl {nested_struct.name} {{\n"
                "    /// Get all the nested structs from the database ordered by the `updated_at` column.\n"
                "    ///\n"
                "    /// # Arguments\n"
            )
            if nested_struct.has_filter_variant():
                document.write(
                    "    /// * `filter` - The filter to apply to the results.\n"
                )
            document.write(
                "    /// * `limit` - The maximum number of rows to return. By default `10`.\n"
                "    /// * `offset` - The offset of the rows to return. By default `0`.\n"
                "    /// * `connection` - The database connection.\n"
                "    pub fn all_by_updated_at(\n"
            )
            if nested_struct.has_filter_variant():
                filter_variant = nested_struct.get_filter_variant()
                document.write(
                    f"        filter: Option<&web_common::database::{filter_variant.name}>,\n"
                )
            document.write(
                "        limit: Option<i64>,\n"
                "        offset: Option<i64>,\n"
                "        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,\n"
                "    ) -> Result<Vec<Self>, diesel::result::Error> {\n"
            )
            if nested_struct.has_filter_variant():
                document.write(
                    f"        {flat_variant.name}::all_by_updated_at(filter, limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()\n"
                )
            else:
                document.write(
                    f"        {flat_variant.name}::all_by_updated_at(limit, offset, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()\n"
                )
            document.write("    }\n}\n")

        document.write(
            f"impl {nested_struct.name} {{\n"
            "    /// Get the nested struct from the provided primary key.\n"
            "    ///\n"
            "    /// # Arguments\n"
            f"    /// * `{nested_struct.get_formatted_primary_keys(include_prefix=False)}` - The primary key(s) of the row.\n"
            "    /// * `connection` - The database connection.\n"
            "    pub fn get(\n"
            f"        {nested_struct.get_formatted_primary_keys(include_prefix=False)}: {nested_struct.get_formatted_primary_key_data_types()},\n"
            "        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,\n"
            "    ) -> Result<Self, diesel::result::Error>\n"
            "    {\n"
            f"       {flat_variant.name}::get({nested_struct.get_formatted_primary_keys(include_prefix=False)}, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))\n"
            "    }\n"
            "}\n"
        )

        # For each of the columns in the struct that have a UNIQUE constraint,
        # we implement the methods `from_{column_name}` by employing the method
        # of the same name available for the main struct associated to this struct
        for unique_columns in flat_variant.get_unique_constraints():

            unique_column_references = [
                unique_column.as_ref() for unique_column in unique_columns
            ]

            joined = "_and_".join(
                [unique_column.name for unique_column in unique_column_references]
            )
            from_method_name = f"from_{joined}"

            if len(unique_column_references) == 1:
                human_readable_column_names = unique_column_references[0].name
            else:
                human_readable_column_names = (
                    ", ".join(
                        [
                            unique_column.name
                            for unique_column in unique_column_references[:-1]
                        ]
                    )
                    + f" and {unique_column_references[-1].name}"
                )

            comma_separated_column_names = ", ".join(
                [unique_column.name for unique_column in unique_column_references]
            )

            document.write(
                f"impl {nested_struct.name} {{\n"
                f"    /// Get the nested struct from the provided {human_readable_column_names}.\n"
                "    ///\n"
                f"    /// # Arguments\n"
            )
            for unique_column in unique_column_references:
                document.write(
                    f"    /// * `{unique_column.name}` - The {unique_column.name} of the row.\n"
                )
            document.write(
                "    /// * `connection` - The database connection.\n"
                f"    pub fn {from_method_name}(\n"
            )
            for unique_column in unique_column_references:
                document.write(
                    f"        {unique_column.name}: {unique_column.format_data_type()},\n"
                )
            document.write(
                "        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,\n"
                "    ) -> Result<Self, diesel::result::Error>\n"
                "    {\n"
                f"        {flat_variant.name}::{from_method_name}({comma_separated_column_names}, connection).and_then(|flat_variant| Self::from_flat(flat_variant, connection))\n"
                "    }\n"
                "}\n"
            )

        # If there is an index on the table, we implement the search method that
        # calls search on the flat version of the struct and then iterates on the
        # primary keys of the results and constructs the nested structs by calling
        # the `get` method several times.
        if flat_variant.is_searchable():
            for method_name, _, _ in PGIndices.SIMILARITY_METHODS:
                document.write(
                    f"impl {nested_struct.name} {{\n"
                    "    /// Search the table by the query.\n"
                    "    ///\n"
                    "    /// # Arguments\n"
                    "    /// * `query` - The string to search for.\n"
                    "    /// * `limit` - The maximum number of results, by default `10`.\n"
                    f"    pub fn {method_name}_search(\n"
                    "        query: &str,\n"
                    "        limit: Option<i32>,\n"
                    "        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,\n"
                    "    ) -> Result<Vec<Self>, diesel::result::Error> {\n"
                    f"       {flat_variant.name}::{method_name}_search(query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()\n"
                    "    }\n"
                    "}\n"
                )

                if (
                    nested_struct.has_associated_roles()
                    and nested_struct.table_name != "users"
                ):
                    document.write(
                        f"impl {nested_struct.name} {{\n"
                        "    /// Search the table by the query.\n"
                        "    ///\n"
                        "    /// # Arguments\n"
                        "    /// * `author_user_id` - The user id.\n"
                        "    /// * `query` - The string to search for.\n"
                        "    /// * `limit` - The maximum number of results, by default `10`.\n"
                        f"    pub fn {method_name}_search_editables(\n"
                        "        author_user_id: i32,\n"
                        "        query: &str,\n"
                        "        limit: Option<i32>,\n"
                        "        connection: &mut PooledConnection<ConnectionManager<diesel::prelude::PgConnection>>,\n"
                        "    ) -> Result<Vec<Self>, diesel::result::Error> {\n"
                        f"       {flat_variant.name}::{method_name}_search_editables(author_user_id, query, limit, connection)?.into_iter().map(|flat_variant| Self::from_flat(flat_variant, connection)).collect()\n"
                        "    }\n"
                        "}\n"
                    )

        # We implement the bidirectional From methods for the nested struct
        # present in the web_common crate, which does not use Diesel or its
        # structs, but the web_common version of the structs.
        document.write(
            f"impl From<web_common::database::nested_models::{nested_struct.name}> for {nested_struct.name} {{\n"
            f"    fn from(item: web_common::database::nested_models::{nested_struct.name}) -> Self {{\n"
            "        Self {\n"
        )
        for attribute in nested_struct.attributes:
            if attribute.optional:
                document.write(
                    f"            {attribute.name}: item.{attribute.name}.map(|item| item.into()),\n"
                )
            else:
                document.write(
                    f"            {attribute.name}: item.{attribute.name}.into(),\n"
                )
        document.write("        }\n    }\n}\n")

        document.write(
            f"impl From<{nested_struct.name}> for web_common::database::nested_models::{nested_struct.name} {{\n"
            f"    fn from(item: {nested_struct.name}) -> Self {{\n"
            "        Self {\n"
        )
        for attribute in nested_struct.attributes:
            if attribute.optional:
                document.write(
                    f"            {attribute.name}: item.{attribute.name}.map(|item| item.into()),\n"
                )
            else:
                document.write(
                    f"            {attribute.name}: item.{attribute.name}.into(),\n"
                )
        document.write("        }\n    }\n}\n")

    document.close()

    return nested_structs
