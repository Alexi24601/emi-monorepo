"""Submodule to retrieve and generate Diesel bindings for PostgreSQL types."""

from typing import List
import os
from functools import lru_cache
from tqdm.auto import tqdm
from constraint_checkers.cursor import get_cursor
from constraint_checkers.is_file_changed import is_file_changed
from constraint_checkers.migrations_changed import are_migrations_changed
from constraint_checkers.regroup_tables import get_types


class SQLType:
    """Class to represent a PostgreSQL type."""

    def __init__(self, name: str):
        """Initialize the SQLType object.

        Parameters
        ----------
        name : str
            The name of the type.
        """
        assert isinstance(name, str)
        assert len(name) > 0
        self.name = name

    def rust_diesel_name(self):
        """Returns the name of the type capitalized in camel case."""
        return "".join(word.capitalize() for word in self.name.split("_"))

    def sanitized_name(self):
        """Returns the name of the type sanitized for use in Rust code."""
        if self.name in ("box",):
            return f"r#{self.name}"
        return self.name

    def import_path(self):
        """Returns the import path for the type."""
        return f"crate::database::sql_type_bindings::{self.rust_diesel_name()}"

    def write_diesel_binding_to_file(self, file):
        """Write the Diesel binding for the type to a file.

        Parameters
        ----------
        file : file
            The file to write the binding to.
        """
        file.write(
            "#[derive(diesel::query_builder::QueryId, diesel::sql_types::SqlType)]\n"
            f'#[diesel(postgres_type(name = "{self.name}"))]\n'
            f"pub struct {self.rust_diesel_name()};\n"
        )


@lru_cache
def get_all_postgres_types() -> List[SQLType]:
    """Retrieve all PostgreSQL types from the database."""
    # _connection, cursor = get_cursor()
    # # We exclude all types that start with "_" as they are internal types
    # # and similarly we exclude all types that start with "pg_" as they are
    # # system types. Furthermore, we exclude all types that are placeholders.
    # cursor.execute(
    #     "SELECT typname, oid FROM pg_type WHERE "
    #     r"typname NOT LIKE '\_%' AND typname NOT LIKE 'pg_%' "
    #     "AND typname NOT LIKE 'any%'"
    # )
    # types = [SQLType(name, oid) for name, oid in cursor.fetchall()]
    # cursor.close()

    # # We sort the types by name to ensure consistent output
    # types = sorted(types, key=lambda x: x.name)

    # As a self-consistency check, we ensure that all of the types that we are
    # defining in the migrations are actually being retrieved by the aforementioned
    # query.
    # for defined_type in get_types():
    #     assert any(
    #         defined_type == sql_type.name for sql_type in types
    #     ), f"Type {defined_type} is not being retrieved from the database."

    types = [SQLType(defined_type) for defined_type in get_types()]

    types = sorted(types, key=lambda x: x.name)

    return types


def write_diesel_sql_types_bindings():
    """Write the SQL type bindings for the Diesel ORM as loaded from the database."""
    if not (are_migrations_changed() or is_file_changed(__file__)):
        print("No change in migrations or file. Skipping writing SQL type bindings.")
        return

    sql_types: List[SQLType] = get_all_postgres_types()
    os.makedirs("src/database/sql_type_bindings", exist_ok=True)

    with open("src/database/sql_type_bindings.rs", "w", encoding="utf8") as module_document:
        # First thing, we write that this file is automatically generated
        # and discourage the user from editing it manually.

        warning = (
            "//! This file is automatically generated by the code generation suite.\n"
            "//! Do not edit it manually.\n"
            "//!\n"
            "//! This file contains the bindings for the SQL types in the database.\n\n"
        )

        os.makedirs("src/database/sql_type_bindings", exist_ok=True)

        module_document.write(warning)

        for i, sql_type in tqdm(
            enumerate(sql_types),
            desc="Writing SQL type bindings",
            unit="type",
            total=len(sql_types),
            leave=False,
        ):
            module_document.write(
                f"mod {sql_type.sanitized_name()};\n" f"pub use {sql_type.sanitized_name()}::*;\n"
            )

            with open(
                f"src/database/sql_type_bindings/{sql_type.sanitized_name()}.rs", "w", encoding="utf8"
            ) as f:
                f.write(warning)

                try:
                    sql_type.write_diesel_binding_to_file(f)
                except NotImplementedError as e:
                    raise NotImplementedError(
                        f"Failed to write binding for SQL type {sql_type.name}. "
                        f"We are at the {i}th type out of {len(sql_types)}."
                    ) from e

    print(
        f"Successfully wrote {len(sql_types)} SQL type bindings."
    )
