//! This module contains the nested structs for the database tables.
//!
//! This file is automatically generated. Do not write anything here.

use serde::Deserialize;
use serde::Serialize;
use uuid::Uuid;
use super::tables::*;
use super::views::*;
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedBioOttRank {
    pub inner: BioOttRank,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

#[cfg(feature = "frontend")]
impl NestedBioOttRank {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: BioOttRank,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap(),
            color: Color::get(flat_variant.color_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = BioOttRank::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = BioOttRank::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedBioOttTaxonItem {
    pub inner: BioOttTaxonItem,
    pub ott_rank: NestedBioOttRank,
    pub domain: Option<BioOttTaxonItem>,
    pub kingdom: Option<BioOttTaxonItem>,
    pub phylum: Option<BioOttTaxonItem>,
    pub class: Option<BioOttTaxonItem>,
    pub order: Option<BioOttTaxonItem>,
    pub family: Option<BioOttTaxonItem>,
    pub genus: Option<BioOttTaxonItem>,
    pub parent: BioOttTaxonItem,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

#[cfg(feature = "frontend")]
impl NestedBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: BioOttTaxonItem,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            ott_rank: NestedBioOttRank::get(flat_variant.ott_rank_id, connection).await?.unwrap(),
            domain: if let Some(domain_id) = flat_variant.domain_id { BioOttTaxonItem::get(domain_id, connection).await? } else { None },
            kingdom: if let Some(kingdom_id) = flat_variant.kingdom_id { BioOttTaxonItem::get(kingdom_id, connection).await? } else { None },
            phylum: if let Some(phylum_id) = flat_variant.phylum_id { BioOttTaxonItem::get(phylum_id, connection).await? } else { None },
            class: if let Some(class_id) = flat_variant.class_id { BioOttTaxonItem::get(class_id, connection).await? } else { None },
            order: if let Some(order_id) = flat_variant.order_id { BioOttTaxonItem::get(order_id, connection).await? } else { None },
            family: if let Some(family_id) = flat_variant.family_id { BioOttTaxonItem::get(family_id, connection).await? } else { None },
            genus: if let Some(genus_id) = flat_variant.genus_id { BioOttTaxonItem::get(genus_id, connection).await? } else { None },
            parent: BioOttTaxonItem::get(flat_variant.parent_id, connection).await?.unwrap(),
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap(),
            color: Color::get(flat_variant.color_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = BioOttTaxonItem::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = BioOttTaxonItem::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.ott_rank.update_or_insert(connection).await?;
        if let Some(domain) = self.domain {
            domain.update_or_insert(connection).await?;
        }
        if let Some(kingdom) = self.kingdom {
            kingdom.update_or_insert(connection).await?;
        }
        if let Some(phylum) = self.phylum {
            phylum.update_or_insert(connection).await?;
        }
        if let Some(class) = self.class {
            class.update_or_insert(connection).await?;
        }
        if let Some(order) = self.order {
            order.update_or_insert(connection).await?;
        }
        if let Some(family) = self.family {
            family.update_or_insert(connection).await?;
        }
        if let Some(genus) = self.genus {
            genus.update_or_insert(connection).await?;
        }
        self.parent.update_or_insert(connection).await?;
        self.icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedDerivedSample {
    pub inner: DerivedSample,
    pub created_by: User,
    pub updated_by: User,
    pub parent_sample: NestedSample,
    pub child_sample: NestedSample,
}

#[cfg(feature = "frontend")]
impl NestedDerivedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: DerivedSample,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_variant.updated_by, connection).await?.unwrap(),
            parent_sample: NestedSample::get(flat_variant.parent_sample_id, connection).await?.unwrap(),
            child_sample: NestedSample::get(flat_variant.child_sample_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( parent_sample_id, child_sample_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( parent_sample_id, child_sample_id ): ( Uuid, Uuid ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = DerivedSample::get(( parent_sample_id, child_sample_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = DerivedSample::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = DerivedSample::all_by_updated_at(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        self.parent_sample.update_or_insert(connection).await?;
        self.child_sample.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedDocumentFormat {
    pub inner: DocumentFormat,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

#[cfg(feature = "frontend")]
impl NestedDocumentFormat {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: DocumentFormat,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap(),
            color: Color::get(flat_variant.color_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = DocumentFormat::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = DocumentFormat::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedLoginProvider {
    pub inner: LoginProvider,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

#[cfg(feature = "frontend")]
impl NestedLoginProvider {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: LoginProvider,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap(),
            color: Color::get(flat_variant.color_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = LoginProvider::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = LoginProvider::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedNotification {
    pub inner: Notification,
    pub user: User,
}

#[cfg(feature = "frontend")]
impl NestedNotification {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Notification,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Notification::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Notification::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedOrganization {
    pub inner: Organization,
    pub country: Country,
}

#[cfg(feature = "frontend")]
impl NestedOrganization {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Organization,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            country: Country::get(flat_variant.country_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Organization::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Organization::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.country.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectState {
    pub inner: ProjectState,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

#[cfg(feature = "frontend")]
impl NestedProjectState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectState,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap(),
            color: Color::get(flat_variant.color_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectState::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectState::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProject {
    pub inner: Project,
    pub parent_project: Option<Project>,
    pub created_by: User,
    pub updated_by: User,
    pub state: NestedProjectState,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

#[cfg(feature = "frontend")]
impl NestedProject {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Project,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            parent_project: if let Some(parent_project_id) = flat_variant.parent_project_id { Project::get(parent_project_id, connection).await? } else { None },
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_variant.updated_by, connection).await?.unwrap(),
            state: NestedProjectState::get(flat_variant.state_id, connection).await?.unwrap(),
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap(),
            color: Color::get(flat_variant.color_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Project::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Project::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Project::all_by_updated_at(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        if let Some(parent_project) = self.parent_project {
            parent_project.update_or_insert(connection).await?;
        }
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        self.state.update_or_insert(connection).await?;
        self.icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsTeamsRoleInvitation {
    pub inner: ProjectsTeamsRoleInvitation,
    pub table: NestedProject,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedProjectsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsTeamsRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsTeamsRoleInvitation::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsTeamsRoleInvitation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsTeamsRoleRequest {
    pub inner: ProjectsTeamsRoleRequest,
    pub table: NestedProject,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedProjectsTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsTeamsRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsTeamsRoleRequest::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsTeamsRoleRequest::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsTeamsRole {
    pub inner: ProjectsTeamsRole,
    pub table: NestedProject,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedProjectsTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsTeamsRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsTeamsRole::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsTeamsRole::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsUsersRoleInvitation {
    pub inner: ProjectsUsersRoleInvitation,
    pub table: NestedProject,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedProjectsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsUsersRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsUsersRoleInvitation::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsUsersRoleInvitation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsUsersRoleRequest {
    pub inner: ProjectsUsersRoleRequest,
    pub table: NestedProject,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedProjectsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsUsersRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsUsersRoleRequest::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsUsersRoleRequest::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedProjectsUsersRole {
    pub inner: ProjectsUsersRole,
    pub table: NestedProject,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedProjectsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsUsersRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedProject::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsUsersRole::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsUsersRole::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedRole {
    pub inner: Role,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

#[cfg(feature = "frontend")]
impl NestedRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Role,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap(),
            color: Color::get(flat_variant.color_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Role::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Role::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampleBioOttTaxonItem {
    pub inner: SampleBioOttTaxonItem,
    pub created_by: User,
    pub updated_by: User,
    pub sample: NestedSample,
    pub taxon: NestedBioOttTaxonItem,
}

#[cfg(feature = "frontend")]
impl NestedSampleBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampleBioOttTaxonItem,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_variant.updated_by, connection).await?.unwrap(),
            sample: NestedSample::get(flat_variant.sample_id, connection).await?.unwrap(),
            taxon: NestedBioOttTaxonItem::get(flat_variant.taxon_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( sample_id, taxon_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( sample_id, taxon_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampleBioOttTaxonItem::get(( sample_id, taxon_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampleBioOttTaxonItem::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampleBioOttTaxonItem::all_by_updated_at(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        self.sample.update_or_insert(connection).await?;
        self.taxon.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampleState {
    pub inner: SampleState,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

#[cfg(feature = "frontend")]
impl NestedSampleState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampleState,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap(),
            color: Color::get(flat_variant.color_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampleState::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampleState::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualBioOttTaxonItem {
    pub inner: SampledIndividualBioOttTaxonItem,
    pub created_by: User,
    pub updated_by: User,
    pub sampled_individual: NestedSampledIndividual,
    pub taxon: NestedBioOttTaxonItem,
}

#[cfg(feature = "frontend")]
impl NestedSampledIndividualBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampledIndividualBioOttTaxonItem,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_variant.updated_by, connection).await?.unwrap(),
            sampled_individual: NestedSampledIndividual::get(flat_variant.sampled_individual_id, connection).await?.unwrap(),
            taxon: NestedBioOttTaxonItem::get(flat_variant.taxon_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( sampled_individual_id, taxon_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( sampled_individual_id, taxon_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampledIndividualBioOttTaxonItem::get(( sampled_individual_id, taxon_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampledIndividualBioOttTaxonItem::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampledIndividualBioOttTaxonItem::all_by_updated_at(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        self.sampled_individual.update_or_insert(connection).await?;
        self.taxon.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividual {
    pub inner: SampledIndividual,
    pub created_by: User,
    pub updated_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSampledIndividual {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampledIndividual,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_variant.updated_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampledIndividual::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampledIndividual::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampledIndividual::all_by_updated_at(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsTeamsRoleInvitation {
    pub inner: SampledIndividualsTeamsRoleInvitation,
    pub table: NestedSampledIndividual,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSampledIndividualsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampledIndividualsTeamsRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampledIndividualsTeamsRoleInvitation::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampledIndividualsTeamsRoleInvitation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsTeamsRoleRequest {
    pub inner: SampledIndividualsTeamsRoleRequest,
    pub table: NestedSampledIndividual,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSampledIndividualsTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampledIndividualsTeamsRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampledIndividualsTeamsRoleRequest::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampledIndividualsTeamsRoleRequest::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsTeamsRole {
    pub inner: SampledIndividualsTeamsRole,
    pub table: NestedSampledIndividual,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSampledIndividualsTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampledIndividualsTeamsRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampledIndividualsTeamsRole::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampledIndividualsTeamsRole::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsUsersRoleInvitation {
    pub inner: SampledIndividualsUsersRoleInvitation,
    pub table: NestedSampledIndividual,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSampledIndividualsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampledIndividualsUsersRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampledIndividualsUsersRoleInvitation::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampledIndividualsUsersRoleInvitation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsUsersRoleRequest {
    pub inner: SampledIndividualsUsersRoleRequest,
    pub table: NestedSampledIndividual,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSampledIndividualsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampledIndividualsUsersRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampledIndividualsUsersRoleRequest::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampledIndividualsUsersRoleRequest::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSampledIndividualsUsersRole {
    pub inner: SampledIndividualsUsersRole,
    pub table: NestedSampledIndividual,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSampledIndividualsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampledIndividualsUsersRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSampledIndividual::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampledIndividualsUsersRole::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampledIndividualsUsersRole::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSample {
    pub inner: Sample,
    pub created_by: User,
    pub sampled_by: User,
    pub updated_by: User,
    pub state: NestedSampleState,
}

#[cfg(feature = "frontend")]
impl NestedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Sample,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            sampled_by: User::get(flat_variant.sampled_by, connection).await?.unwrap(),
            updated_by: User::get(flat_variant.updated_by, connection).await?.unwrap(),
            state: NestedSampleState::get(flat_variant.state, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Sample::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Sample::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Sample::all_by_updated_at(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.sampled_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        self.state.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesTeamsRoleInvitation {
    pub inner: SamplesTeamsRoleInvitation,
    pub table: NestedSample,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSamplesTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SamplesTeamsRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SamplesTeamsRoleInvitation::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SamplesTeamsRoleInvitation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesTeamsRoleRequest {
    pub inner: SamplesTeamsRoleRequest,
    pub table: NestedSample,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSamplesTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SamplesTeamsRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SamplesTeamsRoleRequest::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SamplesTeamsRoleRequest::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesTeamsRole {
    pub inner: SamplesTeamsRole,
    pub table: NestedSample,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSamplesTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SamplesTeamsRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SamplesTeamsRole::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SamplesTeamsRole::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesUsersRoleInvitation {
    pub inner: SamplesUsersRoleInvitation,
    pub table: NestedSample,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSamplesUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SamplesUsersRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SamplesUsersRoleInvitation::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SamplesUsersRoleInvitation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesUsersRoleRequest {
    pub inner: SamplesUsersRoleRequest,
    pub table: NestedSample,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSamplesUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SamplesUsersRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SamplesUsersRoleRequest::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SamplesUsersRoleRequest::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSamplesUsersRole {
    pub inner: SamplesUsersRole,
    pub table: NestedSample,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSamplesUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SamplesUsersRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSample::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SamplesUsersRole::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SamplesUsersRole::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectra {
    pub inner: Spectra,
    pub spectra_collection: NestedSpectraCollection,
}

#[cfg(feature = "frontend")]
impl NestedSpectra {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Spectra,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            spectra_collection: NestedSpectraCollection::get(flat_variant.spectra_collection_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Spectra::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Spectra::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.spectra_collection.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollection {
    pub inner: SpectraCollection,
    pub sample: NestedSample,
    pub created_by: User,
    pub updated_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSpectraCollection {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SpectraCollection,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            sample: NestedSample::get(flat_variant.sample_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_variant.updated_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SpectraCollection::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SpectraCollection::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SpectraCollection::all_by_updated_at(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.sample.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsTeamsRoleInvitation {
    pub inner: SpectraCollectionsTeamsRoleInvitation,
    pub table: NestedSpectraCollection,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSpectraCollectionsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SpectraCollectionsTeamsRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SpectraCollectionsTeamsRoleInvitation::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SpectraCollectionsTeamsRoleInvitation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsTeamsRoleRequest {
    pub inner: SpectraCollectionsTeamsRoleRequest,
    pub table: NestedSpectraCollection,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSpectraCollectionsTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SpectraCollectionsTeamsRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SpectraCollectionsTeamsRoleRequest::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SpectraCollectionsTeamsRoleRequest::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsTeamsRole {
    pub inner: SpectraCollectionsTeamsRole,
    pub table: NestedSpectraCollection,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSpectraCollectionsTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SpectraCollectionsTeamsRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SpectraCollectionsTeamsRole::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SpectraCollectionsTeamsRole::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsUsersRoleInvitation {
    pub inner: SpectraCollectionsUsersRoleInvitation,
    pub table: NestedSpectraCollection,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSpectraCollectionsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SpectraCollectionsUsersRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SpectraCollectionsUsersRoleInvitation::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SpectraCollectionsUsersRoleInvitation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsUsersRoleRequest {
    pub inner: SpectraCollectionsUsersRoleRequest,
    pub table: NestedSpectraCollection,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSpectraCollectionsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SpectraCollectionsUsersRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SpectraCollectionsUsersRoleRequest::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SpectraCollectionsUsersRoleRequest::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedSpectraCollectionsUsersRole {
    pub inner: SpectraCollectionsUsersRole,
    pub table: NestedSpectraCollection,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedSpectraCollectionsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SpectraCollectionsUsersRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedSpectraCollection::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SpectraCollectionsUsersRole::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SpectraCollectionsUsersRole::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamState {
    pub inner: TeamState,
    pub icon: FontAwesomeIcon,
    pub color: Color,
}

#[cfg(feature = "frontend")]
impl NestedTeamState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: TeamState,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap(),
            color: Color::get(flat_variant.color_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = TeamState::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = TeamState::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeam {
    pub inner: Team,
    pub icon: FontAwesomeIcon,
    pub color: Color,
    pub parent_team: Option<Team>,
    pub created_by: User,
    pub updated_by: User,
}

#[cfg(feature = "frontend")]
impl NestedTeam {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Team,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap(),
            color: Color::get(flat_variant.color_id, connection).await?.unwrap(),
            parent_team: if let Some(parent_team_id) = flat_variant.parent_team_id { Team::get(parent_team_id, connection).await? } else { None },
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_variant.updated_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Team::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Team::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Team::all_by_updated_at(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        if let Some(parent_team) = self.parent_team {
            parent_team.update_or_insert(connection).await?;
        }
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsTeamsRoleInvitation {
    pub inner: TeamsTeamsRoleInvitation,
    pub table: NestedTeam,
    pub team: NestedTeam,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedTeamsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: TeamsTeamsRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_variant.table_id, connection).await?.unwrap(),
            team: NestedTeam::get(flat_variant.team_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = TeamsTeamsRoleInvitation::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = TeamsTeamsRoleInvitation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.team.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsUsersRoleInvitation {
    pub inner: TeamsUsersRoleInvitation,
    pub table: NestedTeam,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedTeamsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: TeamsUsersRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = TeamsUsersRoleInvitation::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = TeamsUsersRoleInvitation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsUsersRoleRequest {
    pub inner: TeamsUsersRoleRequest,
    pub table: NestedTeam,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedTeamsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: TeamsUsersRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = TeamsUsersRoleRequest::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = TeamsUsersRoleRequest::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedTeamsUsersRole {
    pub inner: TeamsUsersRole,
    pub table: NestedTeam,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedTeamsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: TeamsUsersRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: NestedTeam::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = TeamsUsersRole::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = TeamsUsersRole::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUserEmail {
    pub inner: UserEmail,
    pub created_by: User,
    pub login_provider: NestedLoginProvider,
}

#[cfg(feature = "frontend")]
impl NestedUserEmail {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: UserEmail,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            login_provider: NestedLoginProvider::get(flat_variant.login_provider_id, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = UserEmail::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = UserEmail::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.login_provider.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUsersUsersRoleInvitation {
    pub inner: UsersUsersRoleInvitation,
    pub table: User,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedUsersUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: UsersUsersRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: User::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = UsersUsersRoleInvitation::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = UsersUsersRoleInvitation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUsersUsersRoleRequest {
    pub inner: UsersUsersRoleRequest,
    pub table: User,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedUsersUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: UsersUsersRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: User::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = UsersUsersRoleRequest::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = UsersUsersRoleRequest::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Eq, PartialEq, Debug, Clone, Serialize, Deserialize, Default)]
pub struct NestedUsersUsersRole {
    pub inner: UsersUsersRole,
    pub table: User,
    pub user: User,
    pub role: NestedRole,
    pub created_by: User,
}

#[cfg(feature = "frontend")]
impl NestedUsersUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: UsersUsersRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: User::get(flat_variant.table_id, connection).await?.unwrap(),
            user: User::get(flat_variant.user_id, connection).await?.unwrap(),
            role: NestedRole::get(flat_variant.role_id, connection).await?.unwrap(),
            created_by: User::get(flat_variant.created_by, connection).await?.unwrap(),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = UsersUsersRole::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = UsersUsersRole::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.role.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
