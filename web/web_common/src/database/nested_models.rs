//! This module contains the nested structs for the database tables.
//!
//! This file is automatically generated. Do not write anything here.

use serde::Deserialize;
use serde::Serialize;
use super::tables::*;
use super::views::*;
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedBioOttRank {
    pub inner: BioOttRank,
    pub font_awesome_icon: FontAwesomeIcon,
}
#[cfg(feature = "frontend")]
impl NestedBioOttRank {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: BioOttRank,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = BioOttRank::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = BioOttRank::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.font_awesome_icon.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedBioOttTaxonItem {
    pub inner: BioOttTaxonItem,
    pub ott_rank: NestedBioOttRank,
    pub domain: Option<BioOttTaxonItem>,
    pub kingdom: Option<BioOttTaxonItem>,
    pub phylum: Option<BioOttTaxonItem>,
    pub class: Option<BioOttTaxonItem>,
    pub order: Option<BioOttTaxonItem>,
    pub family: Option<BioOttTaxonItem>,
    pub genus: Option<BioOttTaxonItem>,
    pub parent: BioOttTaxonItem,
    pub font_awesome_icon: FontAwesomeIcon,
    pub color: Color,
}
#[cfg(feature = "frontend")]
impl NestedBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: BioOttTaxonItem,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            ott_rank: NestedBioOttRank::get(flat_struct.ott_rank_id, connection).await?.unwrap(),
            domain: if let Some(domain_id) = flat_struct.domain_id { BioOttTaxonItem::get(domain_id, connection).await? } else { None },
            kingdom: if let Some(kingdom_id) = flat_struct.kingdom_id { BioOttTaxonItem::get(kingdom_id, connection).await? } else { None },
            phylum: if let Some(phylum_id) = flat_struct.phylum_id { BioOttTaxonItem::get(phylum_id, connection).await? } else { None },
            class: if let Some(class_id) = flat_struct.class_id { BioOttTaxonItem::get(class_id, connection).await? } else { None },
            order: if let Some(order_id) = flat_struct.order_id { BioOttTaxonItem::get(order_id, connection).await? } else { None },
            family: if let Some(family_id) = flat_struct.family_id { BioOttTaxonItem::get(family_id, connection).await? } else { None },
            genus: if let Some(genus_id) = flat_struct.genus_id { BioOttTaxonItem::get(genus_id, connection).await? } else { None },
            parent: BioOttTaxonItem::get(flat_struct.parent_id, connection).await?.unwrap(),
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection).await?.unwrap(),
            color: Color::get(flat_struct.color_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = BioOttTaxonItem::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = BioOttTaxonItem::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.ott_rank.update_or_insert(connection).await?;
        if let Some(domain) = self.domain {
            domain.update_or_insert(connection).await?;
        }
        if let Some(kingdom) = self.kingdom {
            kingdom.update_or_insert(connection).await?;
        }
        if let Some(phylum) = self.phylum {
            phylum.update_or_insert(connection).await?;
        }
        if let Some(class) = self.class {
            class.update_or_insert(connection).await?;
        }
        if let Some(order) = self.order {
            order.update_or_insert(connection).await?;
        }
        if let Some(family) = self.family {
            family.update_or_insert(connection).await?;
        }
        if let Some(genus) = self.genus {
            genus.update_or_insert(connection).await?;
        }
        self.parent.update_or_insert(connection).await?;
        self.font_awesome_icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedContainerHorizontalRule {
    pub inner: ContainerHorizontalRule,
    pub created_by: User,
    pub updated_by: User,
    pub item_type: NestedItemCategory,
    pub other_item_type: NestedItemCategory,
}
#[cfg(feature = "frontend")]
impl NestedContainerHorizontalRule {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: ContainerHorizontalRule,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_struct.updated_by, connection).await?.unwrap(),
            item_type: NestedItemCategory::get(flat_struct.item_type_id, connection).await?.unwrap(),
            other_item_type: NestedItemCategory::get(flat_struct.other_item_type_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = ContainerHorizontalRule::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = ContainerHorizontalRule::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        self.item_type.update_or_insert(connection).await?;
        self.other_item_type.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedContainerVerticalRule {
    pub inner: ContainerVerticalRule,
    pub created_by: User,
    pub updated_by: User,
    pub container_item_type: NestedItemCategory,
    pub contained_item_type: NestedItemCategory,
}
#[cfg(feature = "frontend")]
impl NestedContainerVerticalRule {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: ContainerVerticalRule,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_struct.updated_by, connection).await?.unwrap(),
            container_item_type: NestedItemCategory::get(flat_struct.container_item_type_id, connection).await?.unwrap(),
            contained_item_type: NestedItemCategory::get(flat_struct.contained_item_type_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = ContainerVerticalRule::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = ContainerVerticalRule::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        self.container_item_type.update_or_insert(connection).await?;
        self.contained_item_type.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedDerivedSample {
    pub inner: DerivedSample,
    pub created_by: User,
    pub updated_by: User,
    pub parent_sample: NestedSample,
    pub child_sample: NestedSample,
}
#[cfg(feature = "frontend")]
impl NestedDerivedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: DerivedSample,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_struct.updated_by, connection).await?.unwrap(),
            parent_sample: NestedSample::get(flat_struct.parent_sample_id, connection).await?.unwrap(),
            child_sample: NestedSample::get(flat_struct.child_sample_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = DerivedSample::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = DerivedSample::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        self.parent_sample.update_or_insert(connection).await?;
        self.child_sample.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedDocument {
    pub inner: Document,
    pub author: User,
    pub format: DocumentFormat,
}
#[cfg(feature = "frontend")]
impl NestedDocument {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: Document,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            author: User::get(flat_struct.author_id, connection).await?.unwrap(),
            format: DocumentFormat::get(flat_struct.format_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = Document::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = Document::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.author.update_or_insert(connection).await?;
        self.format.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedItemCategory {
    pub inner: ItemCategory,
    pub created_by: User,
    pub updated_by: User,
}
#[cfg(feature = "frontend")]
impl NestedItemCategory {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: ItemCategory,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_struct.updated_by, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = ItemCategory::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = ItemCategory::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedItemCategoryRelationship {
    pub inner: ItemCategoryRelationship,
    pub parent: NestedItemCategory,
    pub child: NestedItemCategory,
    pub added_by: User,
}
#[cfg(feature = "frontend")]
impl NestedItemCategoryRelationship {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: ItemCategoryRelationship,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            parent: NestedItemCategory::get(flat_struct.parent_id, connection).await?.unwrap(),
            child: NestedItemCategory::get(flat_struct.child_id, connection).await?.unwrap(),
            added_by: User::get(flat_struct.added_by, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = ItemCategoryRelationship::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = ItemCategoryRelationship::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.parent.update_or_insert(connection).await?;
        self.child.update_or_insert(connection).await?;
        self.added_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedItemCategoryUnit {
    pub inner: ItemCategoryUnit,
    pub item_category: NestedItemCategory,
    pub unit: Unit,
}
#[cfg(feature = "frontend")]
impl NestedItemCategoryUnit {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: ItemCategoryUnit,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            item_category: NestedItemCategory::get(flat_struct.item_category_id, connection).await?.unwrap(),
            unit: Unit::get(flat_struct.unit_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = ItemCategoryUnit::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = ItemCategoryUnit::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.item_category.update_or_insert(connection).await?;
        self.unit.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedItemLocation {
    pub inner: ItemLocation,
    pub item: Option<NestedItem>,
    pub located_by: Option<User>,
    pub location: Option<NestedLocation>,
}
#[cfg(feature = "frontend")]
impl NestedItemLocation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: ItemLocation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            item: if let Some(item_id) = flat_struct.item_id { NestedItem::get(item_id, connection).await? } else { None },
            located_by: if let Some(located_by) = flat_struct.located_by { User::get(located_by, connection).await? } else { None },
            location: if let Some(location_id) = flat_struct.location_id { NestedLocation::get(location_id, connection).await? } else { None },
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = ItemLocation::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = ItemLocation::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        if let Some(item) = self.item {
            item.update_or_insert(connection).await?;
        }
        if let Some(located_by) = self.located_by {
            located_by.update_or_insert(connection).await?;
        }
        if let Some(location) = self.location {
            location.update_or_insert(connection).await?;
        }
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedItemUnit {
    pub inner: ItemUnit,
    pub item: NestedItem,
    pub unit: Unit,
}
#[cfg(feature = "frontend")]
impl NestedItemUnit {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: ItemUnit,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            item: NestedItem::get(flat_struct.item_id, connection).await?.unwrap(),
            unit: Unit::get(flat_struct.unit_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = ItemUnit::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = ItemUnit::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.item.update_or_insert(connection).await?;
        self.unit.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedItem {
    pub inner: Item,
    pub parent: Option<Item>,
}
#[cfg(feature = "frontend")]
impl NestedItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: Item,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            parent: if let Some(parent_id) = flat_struct.parent_id { Item::get(parent_id, connection).await? } else { None },
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = Item::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = Item::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        if let Some(parent) = self.parent {
            parent.update_or_insert(connection).await?;
        }
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedLocation {
    pub inner: Location,
    pub geolocalization_device: Option<NestedItem>,
    pub altitude_device: Option<NestedItem>,
    pub parent_location: Option<Location>,
}
#[cfg(feature = "frontend")]
impl NestedLocation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: Location,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            geolocalization_device: if let Some(geolocalization_device_id) = flat_struct.geolocalization_device_id { NestedItem::get(geolocalization_device_id, connection).await? } else { None },
            altitude_device: if let Some(altitude_device_id) = flat_struct.altitude_device_id { NestedItem::get(altitude_device_id, connection).await? } else { None },
            parent_location: if let Some(parent_location_id) = flat_struct.parent_location_id { Location::get(parent_location_id, connection).await? } else { None },
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = Location::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = Location::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        if let Some(geolocalization_device) = self.geolocalization_device {
            geolocalization_device.update_or_insert(connection).await?;
        }
        if let Some(altitude_device) = self.altitude_device {
            altitude_device.update_or_insert(connection).await?;
        }
        if let Some(parent_location) = self.parent_location {
            parent_location.update_or_insert(connection).await?;
        }
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedLoginProvider {
    pub inner: LoginProvider,
    pub font_awesome_icon: FontAwesomeIcon,
    pub color: Color,
}
#[cfg(feature = "frontend")]
impl NestedLoginProvider {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: LoginProvider,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection).await?.unwrap(),
            color: Color::get(flat_struct.color_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = LoginProvider::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = LoginProvider::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.font_awesome_icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedManufacturedItemCategory {
    pub inner: ManufacturedItemCategory,
    pub manifacturer: NestedOrganization,
}
#[cfg(feature = "frontend")]
impl NestedManufacturedItemCategory {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: ManufacturedItemCategory,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            manifacturer: NestedOrganization::get(flat_struct.manifacturer_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = ManufacturedItemCategory::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = ManufacturedItemCategory::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.manifacturer.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedNotification {
    pub inner: Notification,
    pub user: User,
}
#[cfg(feature = "frontend")]
impl NestedNotification {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: Notification,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            user: User::get(flat_struct.user_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = Notification::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = Notification::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedOrganization {
    pub inner: Organization,
    pub parent_organization: Option<Organization>,
}
#[cfg(feature = "frontend")]
impl NestedOrganization {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: Organization,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            parent_organization: if let Some(parent_organization_id) = flat_struct.parent_organization_id { Organization::get(parent_organization_id, connection).await? } else { None },
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = Organization::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = Organization::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        if let Some(parent_organization) = self.parent_organization {
            parent_organization.update_or_insert(connection).await?;
        }
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedProcedure {
    pub inner: Procedure,
    pub created_by: User,
    pub updated_by: User,
}
#[cfg(feature = "frontend")]
impl NestedProcedure {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: Procedure,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_struct.updated_by, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = Procedure::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = Procedure::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedProjectRequirement {
    pub inner: ProjectRequirement,
    pub created_by: User,
    pub updated_by: User,
    pub project: NestedProject,
    pub item_category: NestedItemCategory,
    pub unit: Option<Unit>,
}
#[cfg(feature = "frontend")]
impl NestedProjectRequirement {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: ProjectRequirement,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_struct.updated_by, connection).await?.unwrap(),
            project: NestedProject::get(flat_struct.project_id, connection).await?.unwrap(),
            item_category: NestedItemCategory::get(flat_struct.item_category_id, connection).await?.unwrap(),
            unit: if let Some(unit_id) = flat_struct.unit_id { Unit::get(unit_id, connection).await? } else { None },
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = ProjectRequirement::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = ProjectRequirement::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        self.project.update_or_insert(connection).await?;
        self.item_category.update_or_insert(connection).await?;
        if let Some(unit) = self.unit {
            unit.update_or_insert(connection).await?;
        }
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedProjectState {
    pub inner: ProjectState,
    pub font_awesome_icon: FontAwesomeIcon,
    pub color: Color,
}
#[cfg(feature = "frontend")]
impl NestedProjectState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: ProjectState,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection).await?.unwrap(),
            color: Color::get(flat_struct.color_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = ProjectState::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = ProjectState::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.font_awesome_icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedProject {
    pub inner: Project,
    pub state: NestedProjectState,
    pub parent_project: Option<Project>,
    pub created_by: User,
    pub updated_by: User,
}
#[cfg(feature = "frontend")]
impl NestedProject {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: Project,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            state: NestedProjectState::get(flat_struct.state_id, connection).await?.unwrap(),
            parent_project: if let Some(parent_project_id) = flat_struct.parent_project_id { Project::get(parent_project_id, connection).await? } else { None },
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_struct.updated_by, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = Project::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = Project::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.state.update_or_insert(connection).await?;
        if let Some(parent_project) = self.parent_project {
            parent_project.update_or_insert(connection).await?;
        }
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedSampleBioOttTaxonItem {
    pub inner: SampleBioOttTaxonItem,
    pub created_by: User,
    pub sample: NestedSample,
    pub taxon: NestedBioOttTaxonItem,
}
#[cfg(feature = "frontend")]
impl NestedSampleBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: SampleBioOttTaxonItem,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            sample: NestedSample::get(flat_struct.sample_id, connection).await?.unwrap(),
            taxon: NestedBioOttTaxonItem::get(flat_struct.taxon_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = SampleBioOttTaxonItem::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = SampleBioOttTaxonItem::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.sample.update_or_insert(connection).await?;
        self.taxon.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedSampleState {
    pub inner: SampleState,
    pub font_awesome_icon: FontAwesomeIcon,
    pub color: Color,
}
#[cfg(feature = "frontend")]
impl NestedSampleState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: SampleState,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection).await?.unwrap(),
            color: Color::get(flat_struct.color_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = SampleState::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = SampleState::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.font_awesome_icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedSampledIndividualBioOttTaxonItem {
    pub inner: SampledIndividualBioOttTaxonItem,
    pub created_by: User,
    pub sampled_individual: NestedSampledIndividual,
    pub taxon: NestedBioOttTaxonItem,
}
#[cfg(feature = "frontend")]
impl NestedSampledIndividualBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: SampledIndividualBioOttTaxonItem,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            sampled_individual: NestedSampledIndividual::get(flat_struct.sampled_individual_id, connection).await?.unwrap(),
            taxon: NestedBioOttTaxonItem::get(flat_struct.taxon_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = SampledIndividualBioOttTaxonItem::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = SampledIndividualBioOttTaxonItem::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.sampled_individual.update_or_insert(connection).await?;
        self.taxon.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedSampledIndividual {
    pub inner: SampledIndividual,
    pub created_by: User,
    pub updated_by: User,
}
#[cfg(feature = "frontend")]
impl NestedSampledIndividual {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: SampledIndividual,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_struct.updated_by, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = SampledIndividual::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = SampledIndividual::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedSample {
    pub inner: Sample,
    pub inserted_by: User,
    pub sampled_by: User,
    pub updated_by: User,
    pub procedure: NestedSamplingProcedure,
    pub state: NestedSampleState,
}
#[cfg(feature = "frontend")]
impl NestedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: Sample,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            inserted_by: User::get(flat_struct.inserted_by, connection).await?.unwrap(),
            sampled_by: User::get(flat_struct.sampled_by, connection).await?.unwrap(),
            updated_by: User::get(flat_struct.updated_by, connection).await?.unwrap(),
            procedure: NestedSamplingProcedure::get(flat_struct.procedure_id, connection).await?.unwrap(),
            state: NestedSampleState::get(flat_struct.state, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = Sample::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = Sample::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.inserted_by.update_or_insert(connection).await?;
        self.sampled_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        self.procedure.update_or_insert(connection).await?;
        self.state.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedSamplingProcedure {
    pub inner: SamplingProcedure,
    pub created_by: User,
    pub updated_by: User,
}
#[cfg(feature = "frontend")]
impl NestedSamplingProcedure {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: SamplingProcedure,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_struct.updated_by, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = SamplingProcedure::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = SamplingProcedure::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedSpectra {
    pub inner: Spectra,
    pub spectra_collection: NestedSpectraCollection,
}
#[cfg(feature = "frontend")]
impl NestedSpectra {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: Spectra,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            spectra_collection: NestedSpectraCollection::get(flat_struct.spectra_collection_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = Spectra::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = Spectra::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.spectra_collection.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedSpectraCollection {
    pub inner: SpectraCollection,
    pub sample: NestedSample,
    pub created_by: User,
}
#[cfg(feature = "frontend")]
impl NestedSpectraCollection {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: SpectraCollection,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            sample: NestedSample::get(flat_struct.sample_id, connection).await?.unwrap(),
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = SpectraCollection::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = SpectraCollection::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.sample.update_or_insert(connection).await?;
        self.created_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedTeamState {
    pub inner: TeamState,
    pub font_awesome_icon: FontAwesomeIcon,
    pub color: Color,
}
#[cfg(feature = "frontend")]
impl NestedTeamState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: TeamState,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            font_awesome_icon: FontAwesomeIcon::get(flat_struct.font_awesome_icon_id, connection).await?.unwrap(),
            color: Color::get(flat_struct.color_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = TeamState::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = TeamState::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.font_awesome_icon.update_or_insert(connection).await?;
        self.color.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedTeam {
    pub inner: Team,
    pub parent_team: Option<Team>,
    pub created_by: User,
    pub updated_by: User,
}
#[cfg(feature = "frontend")]
impl NestedTeam {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: Team,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            parent_team: if let Some(parent_team_id) = flat_struct.parent_team_id { Team::get(parent_team_id, connection).await? } else { None },
            created_by: User::get(flat_struct.created_by, connection).await?.unwrap(),
            updated_by: User::get(flat_struct.updated_by, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = Team::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = Team::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        if let Some(parent_team) = self.parent_team {
            parent_team.update_or_insert(connection).await?;
        }
        self.created_by.update_or_insert(connection).await?;
        self.updated_by.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedUserEmail {
    pub inner: UserEmail,
    pub user: User,
    pub login_provider: NestedLoginProvider,
}
#[cfg(feature = "frontend")]
impl NestedUserEmail {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: UserEmail,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            user: User::get(flat_struct.user_id, connection).await?.unwrap(),
            login_provider: NestedLoginProvider::get(flat_struct.login_provider_id, connection).await?.unwrap(),
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = UserEmail::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = UserEmail::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.user.update_or_insert(connection).await?;
        self.login_provider.update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Default)]
pub struct NestedPublicUser {
    pub inner: PublicUser,
    pub thumbnail: Option<NestedDocument>,
    pub picture: Option<NestedDocument>,
}
#[cfg(feature = "frontend")]
impl NestedPublicUser {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_struct` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_struct: PublicUser,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            thumbnail: if let Some(thumbnail_id) = flat_struct.thumbnail_id { NestedDocument::get(thumbnail_id, connection).await? } else { None },
            picture: if let Some(picture_id) = flat_struct.picture_id { NestedDocument::get(picture_id, connection).await? } else { None },
            inner: flat_struct,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_struct = PublicUser::get(id, connection).await?;        match flat_struct {
            Some(flat_struct) => Ok(Some(Self::from_flat(flat_struct, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_structs = PublicUser::all(limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_structs.len());
         for flat_struct in flat_structs {
             nested_structs.push(Self::from_flat(flat_struct, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        if let Some(thumbnail) = self.thumbnail {
            thumbnail.update_or_insert(connection).await?;
        }
        if let Some(picture) = self.picture {
            picture.update_or_insert(connection).await?;
        }
        Ok(())
    }
}
