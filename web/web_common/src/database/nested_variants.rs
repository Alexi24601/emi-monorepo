//! This module contains the nested structs for the database tables.
//!
//! This file is automatically generated. Do not write anything here.

use std::rc::Rc;
use super::*;

#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedBioOttRank {
    pub inner: Rc<crate::database::flat_variants::BioOttRank>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedBioOttRank {}
unsafe impl Sync for NestedBioOttRank {}
impl Tabular for NestedBioOttRank {
    const TABLE: Table = Table::BioOttRanks;
}
impl Filtrable for NestedBioOttRank {
    type Filter = BioOttRankFilter;
}
impl Describable for NestedBioOttRank {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedBioOttRank {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedBioOttRank {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: BioOttRank,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = BioOttRank::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&BioOttRankFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = BioOttRank::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedBioOttTaxonItem {
    pub inner: Rc<crate::database::flat_variants::BioOttTaxonItem>,
    pub ott_rank: Rc<crate::database::nested_variants::NestedBioOttRank>,
    pub domain: Option<Rc<crate::database::flat_variants::BioOttTaxonItem>>,
    pub kingdom: Option<Rc<crate::database::flat_variants::BioOttTaxonItem>>,
    pub phylum: Option<Rc<crate::database::flat_variants::BioOttTaxonItem>>,
    pub class: Option<Rc<crate::database::flat_variants::BioOttTaxonItem>>,
    pub order: Option<Rc<crate::database::flat_variants::BioOttTaxonItem>>,
    pub family: Option<Rc<crate::database::flat_variants::BioOttTaxonItem>>,
    pub genus: Option<Rc<crate::database::flat_variants::BioOttTaxonItem>>,
    pub parent: Rc<crate::database::flat_variants::BioOttTaxonItem>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedBioOttTaxonItem {}
unsafe impl Sync for NestedBioOttTaxonItem {}
impl Tabular for NestedBioOttTaxonItem {
    const TABLE: Table = Table::BioOttTaxonItems;
}
impl Filtrable for NestedBioOttTaxonItem {
    type Filter = BioOttTaxonItemFilter;
}
impl Describable for NestedBioOttTaxonItem {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedBioOttTaxonItem {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: BioOttTaxonItem,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            ott_rank: Rc::from(crate::database::nested_variants::NestedBioOttRank::get(flat_variant.ott_rank_id, connection).await?.unwrap()),
            domain: if let Some(domain_id) = flat_variant.domain_id { crate::database::flat_variants::BioOttTaxonItem::get(domain_id, connection).await?.map(Rc::from) } else { None },
            kingdom: if let Some(kingdom_id) = flat_variant.kingdom_id { crate::database::flat_variants::BioOttTaxonItem::get(kingdom_id, connection).await?.map(Rc::from) } else { None },
            phylum: if let Some(phylum_id) = flat_variant.phylum_id { crate::database::flat_variants::BioOttTaxonItem::get(phylum_id, connection).await?.map(Rc::from) } else { None },
            class: if let Some(class_id) = flat_variant.class_id { crate::database::flat_variants::BioOttTaxonItem::get(class_id, connection).await?.map(Rc::from) } else { None },
            order: if let Some(order_id) = flat_variant.order_id { crate::database::flat_variants::BioOttTaxonItem::get(order_id, connection).await?.map(Rc::from) } else { None },
            family: if let Some(family_id) = flat_variant.family_id { crate::database::flat_variants::BioOttTaxonItem::get(family_id, connection).await?.map(Rc::from) } else { None },
            genus: if let Some(genus_id) = flat_variant.genus_id { crate::database::flat_variants::BioOttTaxonItem::get(genus_id, connection).await?.map(Rc::from) } else { None },
            parent: Rc::from(crate::database::flat_variants::BioOttTaxonItem::get(flat_variant.parent_id, connection).await?.unwrap()),
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = BioOttTaxonItem::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&BioOttTaxonItemFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = BioOttTaxonItem::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.ott_rank.as_ref().clone().update_or_insert(connection).await?;
        if let Some(domain) = self.domain {
            domain.as_ref().clone().update_or_insert(connection).await?;
        }
        if let Some(kingdom) = self.kingdom {
            kingdom.as_ref().clone().update_or_insert(connection).await?;
        }
        if let Some(phylum) = self.phylum {
            phylum.as_ref().clone().update_or_insert(connection).await?;
        }
        if let Some(class) = self.class {
            class.as_ref().clone().update_or_insert(connection).await?;
        }
        if let Some(order) = self.order {
            order.as_ref().clone().update_or_insert(connection).await?;
        }
        if let Some(family) = self.family {
            family.as_ref().clone().update_or_insert(connection).await?;
        }
        if let Some(genus) = self.genus {
            genus.as_ref().clone().update_or_insert(connection).await?;
        }
        self.parent.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedDerivedSample {
    pub inner: crate::database::flat_variants::DerivedSample,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub updated_by: Rc<crate::database::nested_variants::NestedUser>,
    pub parent_sample: Rc<crate::database::nested_variants::NestedSample>,
    pub child_sample: Rc<crate::database::nested_variants::NestedSample>,
    pub unit: Rc<crate::database::nested_variants::NestedUnit>,
}

unsafe impl Send for NestedDerivedSample {}
unsafe impl Sync for NestedDerivedSample {}
impl Tabular for NestedDerivedSample {
    const TABLE: Table = Table::DerivedSamples;
}
impl Filtrable for NestedDerivedSample {
    type Filter = DerivedSampleFilter;
}
impl Describable for NestedDerivedSample {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedDerivedSample {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedDerivedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: DerivedSample,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            updated_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.updated_by, connection).await?.unwrap()),
            parent_sample: Rc::from(crate::database::nested_variants::NestedSample::get(flat_variant.parent_sample_id, connection).await?.unwrap()),
            child_sample: Rc::from(crate::database::nested_variants::NestedSample::get(flat_variant.child_sample_id, connection).await?.unwrap()),
            unit: Rc::from(crate::database::nested_variants::NestedUnit::get(flat_variant.unit_id, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( parent_sample_id, child_sample_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( parent_sample_id, child_sample_id ): ( uuid::Uuid, uuid::Uuid ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = DerivedSample::get(( parent_sample_id, child_sample_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&DerivedSampleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = DerivedSample::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        filter: Option<&DerivedSampleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = DerivedSample::all_by_updated_at(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.updated_by.as_ref().clone().update_or_insert(connection).await?;
        self.parent_sample.as_ref().clone().update_or_insert(connection).await?;
        self.child_sample.as_ref().clone().update_or_insert(connection).await?;
        self.unit.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedDocumentFormat {
    pub inner: Rc<crate::database::flat_variants::DocumentFormat>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedDocumentFormat {}
unsafe impl Sync for NestedDocumentFormat {}
impl Tabular for NestedDocumentFormat {
    const TABLE: Table = Table::DocumentFormats;
}
impl Filtrable for NestedDocumentFormat {
    type Filter = DocumentFormatFilter;
}
impl Describable for NestedDocumentFormat {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedDocumentFormat {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedDocumentFormat {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: DocumentFormat,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = DocumentFormat::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&DocumentFormatFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = DocumentFormat::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedLoginProvider {
    pub inner: Rc<crate::database::flat_variants::LoginProvider>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedLoginProvider {}
unsafe impl Sync for NestedLoginProvider {}
impl Tabular for NestedLoginProvider {
    const TABLE: Table = Table::LoginProviders;
}
impl Filtrable for NestedLoginProvider {
    type Filter = LoginProviderFilter;
}
impl Describable for NestedLoginProvider {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedLoginProvider {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedLoginProvider {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: LoginProvider,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = LoginProvider::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&LoginProviderFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = LoginProvider::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedMaterial {
    pub inner: Rc<crate::database::flat_variants::Material>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedMaterial {}
unsafe impl Sync for NestedMaterial {}
impl Tabular for NestedMaterial {
    const TABLE: Table = Table::Materials;
}
impl Filtrable for NestedMaterial {
    type Filter = MaterialFilter;
}
impl Describable for NestedMaterial {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedMaterial {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedMaterial {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Material,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Material::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&MaterialFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Material::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedNameplateCategory {
    pub inner: Rc<crate::database::flat_variants::NameplateCategory>,
    pub permanence: Rc<crate::database::nested_variants::NestedPermanenceCategory>,
    pub material: Rc<crate::database::nested_variants::NestedMaterial>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedNameplateCategory {}
unsafe impl Sync for NestedNameplateCategory {}
impl Tabular for NestedNameplateCategory {
    const TABLE: Table = Table::NameplateCategories;
}
impl Filtrable for NestedNameplateCategory {
    type Filter = NameplateCategoryFilter;
}
impl Describable for NestedNameplateCategory {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedNameplateCategory {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedNameplateCategory {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: NameplateCategory,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            permanence: Rc::from(crate::database::nested_variants::NestedPermanenceCategory::get(flat_variant.permanence_id, connection).await?.unwrap()),
            material: Rc::from(crate::database::nested_variants::NestedMaterial::get(flat_variant.material_id, connection).await?.unwrap()),
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = NameplateCategory::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&NameplateCategoryFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = NameplateCategory::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.permanence.as_ref().clone().update_or_insert(connection).await?;
        self.material.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct NestedNameplate {
    pub inner: Rc<crate::database::flat_variants::Nameplate>,
    pub project: Rc<crate::database::nested_variants::NestedProject>,
    pub category: Rc<crate::database::nested_variants::NestedNameplateCategory>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub updated_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedNameplate {}
unsafe impl Sync for NestedNameplate {}
impl Tabular for NestedNameplate {
    const TABLE: Table = Table::Nameplates;
}
impl Filtrable for NestedNameplate {
    type Filter = NameplateFilter;
}
impl Describable for NestedNameplate {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedNameplate {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedNameplate {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Nameplate,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            project: Rc::from(crate::database::nested_variants::NestedProject::get(flat_variant.project_id, connection).await?.unwrap()),
            category: Rc::from(crate::database::nested_variants::NestedNameplateCategory::get(flat_variant.category_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            updated_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.updated_by, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Nameplate::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&NameplateFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Nameplate::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        filter: Option<&NameplateFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Nameplate::all_by_updated_at(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.project.as_ref().clone().update_or_insert(connection).await?;
        self.category.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.updated_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedNotification {
    pub inner: Rc<crate::database::flat_variants::Notification>,
    pub user: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedNotification {}
unsafe impl Sync for NestedNotification {}
impl Tabular for NestedNotification {
    const TABLE: Table = Table::Notifications;
}
impl Filtrable for NestedNotification {
    type Filter = NotificationFilter;
}
impl Describable for NestedNotification {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedNotification {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedNotification {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Notification,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            user: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.user_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Notification::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&NotificationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Notification::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.user.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedObservationSubject {
    pub inner: Rc<crate::database::flat_variants::ObservationSubject>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedObservationSubject {}
unsafe impl Sync for NestedObservationSubject {}
impl Tabular for NestedObservationSubject {
    const TABLE: Table = Table::ObservationSubjects;
}
impl Filtrable for NestedObservationSubject {
    type Filter = ObservationSubjectFilter;
}
impl Describable for NestedObservationSubject {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedObservationSubject {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedObservationSubject {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ObservationSubject,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ObservationSubject::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&ObservationSubjectFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ObservationSubject::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct NestedObservation {
    pub inner: Rc<crate::database::flat_variants::Observation>,
    pub parent_observation: Option<Rc<crate::database::flat_variants::Observation>>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub updated_by: Rc<crate::database::nested_variants::NestedUser>,
    pub project: Rc<crate::database::nested_variants::NestedProject>,
    pub organism: Option<Rc<crate::database::nested_variants::NestedOrganism>>,
    pub sample: Option<Rc<crate::database::nested_variants::NestedSample>>,
    pub subject: Rc<crate::database::nested_variants::NestedObservationSubject>,
}

unsafe impl Send for NestedObservation {}
unsafe impl Sync for NestedObservation {}
impl Tabular for NestedObservation {
    const TABLE: Table = Table::Observations;
}
impl Filtrable for NestedObservation {
    type Filter = ObservationFilter;
}
impl Describable for NestedObservation {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedObservation {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedObservation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Observation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            parent_observation: if let Some(parent_observation_id) = flat_variant.parent_observation_id { crate::database::flat_variants::Observation::get(parent_observation_id, connection).await?.map(Rc::from) } else { None },
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            updated_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.updated_by, connection).await?.unwrap()),
            project: Rc::from(crate::database::nested_variants::NestedProject::get(flat_variant.project_id, connection).await?.unwrap()),
            organism: if let Some(organism_id) = flat_variant.organism_id { crate::database::nested_variants::NestedOrganism::get(organism_id, connection).await?.map(Rc::from) } else { None },
            sample: if let Some(sample_id) = flat_variant.sample_id { crate::database::nested_variants::NestedSample::get(sample_id, connection).await?.map(Rc::from) } else { None },
            subject: Rc::from(crate::database::nested_variants::NestedObservationSubject::get(flat_variant.subject_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Observation::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&ObservationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Observation::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        filter: Option<&ObservationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Observation::all_by_updated_at(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        if let Some(parent_observation) = self.parent_observation {
            parent_observation.as_ref().clone().update_or_insert(connection).await?;
        }
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.updated_by.as_ref().clone().update_or_insert(connection).await?;
        self.project.as_ref().clone().update_or_insert(connection).await?;
        if let Some(organism) = self.organism {
            organism.as_ref().clone().update_or_insert(connection).await?;
        }
        if let Some(sample) = self.sample {
            sample.as_ref().clone().update_or_insert(connection).await?;
        }
        self.subject.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct NestedOrganismBioOttTaxonItem {
    pub inner: crate::database::flat_variants::OrganismBioOttTaxonItem,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub organism: Rc<crate::database::nested_variants::NestedOrganism>,
    pub taxon: Rc<crate::database::nested_variants::NestedBioOttTaxonItem>,
}

unsafe impl Send for NestedOrganismBioOttTaxonItem {}
unsafe impl Sync for NestedOrganismBioOttTaxonItem {}
impl Tabular for NestedOrganismBioOttTaxonItem {
    const TABLE: Table = Table::OrganismBioOttTaxonItems;
}
impl Filtrable for NestedOrganismBioOttTaxonItem {
    type Filter = OrganismBioOttTaxonItemFilter;
}
impl Describable for NestedOrganismBioOttTaxonItem {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedOrganismBioOttTaxonItem {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedOrganismBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: OrganismBioOttTaxonItem,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            organism: Rc::from(crate::database::nested_variants::NestedOrganism::get(flat_variant.organism_id, connection).await?.unwrap()),
            taxon: Rc::from(crate::database::nested_variants::NestedBioOttTaxonItem::get(flat_variant.taxon_id, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( organism_id, taxon_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( organism_id, taxon_id ): ( uuid::Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = OrganismBioOttTaxonItem::get(( organism_id, taxon_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&OrganismBioOttTaxonItemFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = OrganismBioOttTaxonItem::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.organism.as_ref().clone().update_or_insert(connection).await?;
        self.taxon.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct NestedOrganism {
    pub inner: Rc<crate::database::flat_variants::Organism>,
    pub host_organism: Option<Rc<crate::database::flat_variants::Organism>>,
    pub sample: Option<Rc<crate::database::nested_variants::NestedSample>>,
    pub nameplate: Rc<crate::database::nested_variants::NestedNameplate>,
    pub project: Rc<crate::database::nested_variants::NestedProject>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub updated_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedOrganism {}
unsafe impl Sync for NestedOrganism {}
impl Tabular for NestedOrganism {
    const TABLE: Table = Table::Organisms;
}
impl Filtrable for NestedOrganism {
    type Filter = OrganismFilter;
}
impl Describable for NestedOrganism {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedOrganism {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedOrganism {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Organism,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            host_organism: if let Some(host_organism_id) = flat_variant.host_organism_id { crate::database::flat_variants::Organism::get(host_organism_id, connection).await?.map(Rc::from) } else { None },
            sample: if let Some(sample_id) = flat_variant.sample_id { crate::database::nested_variants::NestedSample::get(sample_id, connection).await?.map(Rc::from) } else { None },
            nameplate: Rc::from(crate::database::nested_variants::NestedNameplate::get(flat_variant.nameplate_id, connection).await?.unwrap()),
            project: Rc::from(crate::database::nested_variants::NestedProject::get(flat_variant.project_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            updated_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.updated_by, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Organism::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&OrganismFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Organism::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        filter: Option<&OrganismFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Organism::all_by_updated_at(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        if let Some(host_organism) = self.host_organism {
            host_organism.as_ref().clone().update_or_insert(connection).await?;
        }
        if let Some(sample) = self.sample {
            sample.as_ref().clone().update_or_insert(connection).await?;
        }
        self.nameplate.as_ref().clone().update_or_insert(connection).await?;
        self.project.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.updated_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedOrganization {
    pub inner: Rc<crate::database::flat_variants::Organization>,
    pub country: Rc<crate::database::flat_variants::Country>,
}

unsafe impl Send for NestedOrganization {}
unsafe impl Sync for NestedOrganization {}
impl Tabular for NestedOrganization {
    const TABLE: Table = Table::Organizations;
}
impl Filtrable for NestedOrganization {
    type Filter = OrganizationFilter;
}
impl Describable for NestedOrganization {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedOrganization {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedOrganization {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Organization,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            country: Rc::from(crate::database::flat_variants::Country::get(flat_variant.country_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Organization::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&OrganizationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Organization::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.country.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedPermanenceCategory {
    pub inner: Rc<crate::database::flat_variants::PermanenceCategory>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedPermanenceCategory {}
unsafe impl Sync for NestedPermanenceCategory {}
impl Tabular for NestedPermanenceCategory {
    const TABLE: Table = Table::PermanenceCategories;
}
impl Filtrable for NestedPermanenceCategory {
    type Filter = PermanenceCategoryFilter;
}
impl Describable for NestedPermanenceCategory {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedPermanenceCategory {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedPermanenceCategory {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: PermanenceCategory,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = PermanenceCategory::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&PermanenceCategoryFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = PermanenceCategory::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedProjectState {
    pub inner: Rc<crate::database::flat_variants::ProjectState>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedProjectState {}
unsafe impl Sync for NestedProjectState {}
impl Tabular for NestedProjectState {
    const TABLE: Table = Table::ProjectStates;
}
impl Filtrable for NestedProjectState {
    type Filter = ProjectStateFilter;
}
impl Describable for NestedProjectState {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedProjectState {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedProjectState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectState,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectState::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&ProjectStateFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectState::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedProject {
    pub inner: Rc<crate::database::flat_variants::Project>,
    pub state: Rc<crate::database::nested_variants::NestedProjectState>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
    pub parent_project: Option<Rc<crate::database::flat_variants::Project>>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub updated_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedProject {}
unsafe impl Sync for NestedProject {}
impl Tabular for NestedProject {
    const TABLE: Table = Table::Projects;
}
impl Filtrable for NestedProject {
    type Filter = ProjectFilter;
}
impl Describable for NestedProject {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedProject {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedProject {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Project,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            state: Rc::from(crate::database::nested_variants::NestedProjectState::get(flat_variant.state_id, connection).await?.unwrap()),
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            parent_project: if let Some(parent_project_id) = flat_variant.parent_project_id { crate::database::flat_variants::Project::get(parent_project_id, connection).await?.map(Rc::from) } else { None },
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            updated_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.updated_by, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Project::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&ProjectFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Project::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        filter: Option<&ProjectFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Project::all_by_updated_at(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.state.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        if let Some(parent_project) = self.parent_project {
            parent_project.as_ref().clone().update_or_insert(connection).await?;
        }
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.updated_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedProjectsTeamsRoleInvitation {
    pub inner: crate::database::flat_variants::ProjectsTeamsRoleInvitation,
    pub table: Rc<crate::database::nested_variants::NestedProject>,
    pub team: Rc<crate::database::nested_variants::NestedTeam>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedProjectsTeamsRoleInvitation {}
unsafe impl Sync for NestedProjectsTeamsRoleInvitation {}
impl Tabular for NestedProjectsTeamsRoleInvitation {
    const TABLE: Table = Table::ProjectsTeamsRoleInvitations;
}
impl Filtrable for NestedProjectsTeamsRoleInvitation {
    type Filter = ProjectsTeamsRoleInvitationFilter;
}
impl Describable for NestedProjectsTeamsRoleInvitation {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedProjectsTeamsRoleInvitation {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedProjectsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsTeamsRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedProject::get(flat_variant.table_id, connection).await?.unwrap()),
            team: Rc::from(crate::database::nested_variants::NestedTeam::get(flat_variant.team_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsTeamsRoleInvitation::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&ProjectsTeamsRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsTeamsRoleInvitation::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.team.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedProjectsTeamsRoleRequest {
    pub inner: crate::database::flat_variants::ProjectsTeamsRoleRequest,
    pub table: Rc<crate::database::nested_variants::NestedProject>,
    pub team: Rc<crate::database::nested_variants::NestedTeam>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedProjectsTeamsRoleRequest {}
unsafe impl Sync for NestedProjectsTeamsRoleRequest {}
impl Tabular for NestedProjectsTeamsRoleRequest {
    const TABLE: Table = Table::ProjectsTeamsRoleRequests;
}
impl Filtrable for NestedProjectsTeamsRoleRequest {
    type Filter = ProjectsTeamsRoleRequestFilter;
}
impl Describable for NestedProjectsTeamsRoleRequest {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedProjectsTeamsRoleRequest {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedProjectsTeamsRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsTeamsRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedProject::get(flat_variant.table_id, connection).await?.unwrap()),
            team: Rc::from(crate::database::nested_variants::NestedTeam::get(flat_variant.team_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsTeamsRoleRequest::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&ProjectsTeamsRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsTeamsRoleRequest::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.team.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedProjectsTeamsRole {
    pub inner: crate::database::flat_variants::ProjectsTeamsRole,
    pub table: Rc<crate::database::nested_variants::NestedProject>,
    pub team: Rc<crate::database::nested_variants::NestedTeam>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedProjectsTeamsRole {}
unsafe impl Sync for NestedProjectsTeamsRole {}
impl Tabular for NestedProjectsTeamsRole {
    const TABLE: Table = Table::ProjectsTeamsRoles;
}
impl Filtrable for NestedProjectsTeamsRole {
    type Filter = ProjectsTeamsRoleFilter;
}
impl Describable for NestedProjectsTeamsRole {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedProjectsTeamsRole {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedProjectsTeamsRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsTeamsRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedProject::get(flat_variant.table_id, connection).await?.unwrap()),
            team: Rc::from(crate::database::nested_variants::NestedTeam::get(flat_variant.team_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsTeamsRole::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&ProjectsTeamsRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsTeamsRole::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.team.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedProjectsUsersRoleInvitation {
    pub inner: crate::database::flat_variants::ProjectsUsersRoleInvitation,
    pub table: Rc<crate::database::nested_variants::NestedProject>,
    pub user: Rc<crate::database::nested_variants::NestedUser>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedProjectsUsersRoleInvitation {}
unsafe impl Sync for NestedProjectsUsersRoleInvitation {}
impl Tabular for NestedProjectsUsersRoleInvitation {
    const TABLE: Table = Table::ProjectsUsersRoleInvitations;
}
impl Filtrable for NestedProjectsUsersRoleInvitation {
    type Filter = ProjectsUsersRoleInvitationFilter;
}
impl Describable for NestedProjectsUsersRoleInvitation {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedProjectsUsersRoleInvitation {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedProjectsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsUsersRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedProject::get(flat_variant.table_id, connection).await?.unwrap()),
            user: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.user_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsUsersRoleInvitation::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&ProjectsUsersRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsUsersRoleInvitation::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.user.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedProjectsUsersRoleRequest {
    pub inner: crate::database::flat_variants::ProjectsUsersRoleRequest,
    pub table: Rc<crate::database::nested_variants::NestedProject>,
    pub user: Rc<crate::database::nested_variants::NestedUser>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedProjectsUsersRoleRequest {}
unsafe impl Sync for NestedProjectsUsersRoleRequest {}
impl Tabular for NestedProjectsUsersRoleRequest {
    const TABLE: Table = Table::ProjectsUsersRoleRequests;
}
impl Filtrable for NestedProjectsUsersRoleRequest {
    type Filter = ProjectsUsersRoleRequestFilter;
}
impl Describable for NestedProjectsUsersRoleRequest {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedProjectsUsersRoleRequest {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedProjectsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsUsersRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedProject::get(flat_variant.table_id, connection).await?.unwrap()),
            user: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.user_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsUsersRoleRequest::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&ProjectsUsersRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsUsersRoleRequest::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.user.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedProjectsUsersRole {
    pub inner: crate::database::flat_variants::ProjectsUsersRole,
    pub table: Rc<crate::database::nested_variants::NestedProject>,
    pub user: Rc<crate::database::nested_variants::NestedUser>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedProjectsUsersRole {}
unsafe impl Sync for NestedProjectsUsersRole {}
impl Tabular for NestedProjectsUsersRole {
    const TABLE: Table = Table::ProjectsUsersRoles;
}
impl Filtrable for NestedProjectsUsersRole {
    type Filter = ProjectsUsersRoleFilter;
}
impl Describable for NestedProjectsUsersRole {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedProjectsUsersRole {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedProjectsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: ProjectsUsersRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedProject::get(flat_variant.table_id, connection).await?.unwrap()),
            user: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.user_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = ProjectsUsersRole::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&ProjectsUsersRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = ProjectsUsersRole::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.user.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedRole {
    pub inner: Rc<crate::database::flat_variants::Role>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedRole {}
unsafe impl Sync for NestedRole {}
impl Tabular for NestedRole {
    const TABLE: Table = Table::Roles;
}
impl Filtrable for NestedRole {
    type Filter = RoleFilter;
}
impl Describable for NestedRole {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedRole {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Role,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Role::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&RoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Role::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedSampleBioOttTaxonItem {
    pub inner: crate::database::flat_variants::SampleBioOttTaxonItem,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub sample: Rc<crate::database::nested_variants::NestedSample>,
    pub taxon: Rc<crate::database::nested_variants::NestedBioOttTaxonItem>,
}

unsafe impl Send for NestedSampleBioOttTaxonItem {}
unsafe impl Sync for NestedSampleBioOttTaxonItem {}
impl Tabular for NestedSampleBioOttTaxonItem {
    const TABLE: Table = Table::SampleBioOttTaxonItems;
}
impl Filtrable for NestedSampleBioOttTaxonItem {
    type Filter = SampleBioOttTaxonItemFilter;
}
impl Describable for NestedSampleBioOttTaxonItem {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedSampleBioOttTaxonItem {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedSampleBioOttTaxonItem {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampleBioOttTaxonItem,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            sample: Rc::from(crate::database::nested_variants::NestedSample::get(flat_variant.sample_id, connection).await?.unwrap()),
            taxon: Rc::from(crate::database::nested_variants::NestedBioOttTaxonItem::get(flat_variant.taxon_id, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( sample_id, taxon_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( sample_id, taxon_id ): ( uuid::Uuid, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampleBioOttTaxonItem::get(( sample_id, taxon_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&SampleBioOttTaxonItemFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampleBioOttTaxonItem::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.sample.as_ref().clone().update_or_insert(connection).await?;
        self.taxon.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedSampleContainerCategory {
    pub inner: Rc<crate::database::flat_variants::SampleContainerCategory>,
    pub material: Rc<crate::database::nested_variants::NestedMaterial>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedSampleContainerCategory {}
unsafe impl Sync for NestedSampleContainerCategory {}
impl Tabular for NestedSampleContainerCategory {
    const TABLE: Table = Table::SampleContainerCategories;
}
impl Filtrable for NestedSampleContainerCategory {
    type Filter = SampleContainerCategoryFilter;
}
impl Describable for NestedSampleContainerCategory {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedSampleContainerCategory {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedSampleContainerCategory {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampleContainerCategory,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            material: Rc::from(crate::database::nested_variants::NestedMaterial::get(flat_variant.material_id, connection).await?.unwrap()),
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampleContainerCategory::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&SampleContainerCategoryFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampleContainerCategory::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.material.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedSampleContainer {
    pub inner: Rc<crate::database::flat_variants::SampleContainer>,
    pub project: Rc<crate::database::nested_variants::NestedProject>,
    pub category: Rc<crate::database::nested_variants::NestedSampleContainerCategory>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub updated_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedSampleContainer {}
unsafe impl Sync for NestedSampleContainer {}
impl Tabular for NestedSampleContainer {
    const TABLE: Table = Table::SampleContainers;
}
impl Filtrable for NestedSampleContainer {
    type Filter = SampleContainerFilter;
}
impl Describable for NestedSampleContainer {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedSampleContainer {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedSampleContainer {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampleContainer,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            project: Rc::from(crate::database::nested_variants::NestedProject::get(flat_variant.project_id, connection).await?.unwrap()),
            category: Rc::from(crate::database::nested_variants::NestedSampleContainerCategory::get(flat_variant.category_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            updated_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.updated_by, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampleContainer::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&SampleContainerFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampleContainer::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        filter: Option<&SampleContainerFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampleContainer::all_by_updated_at(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.project.as_ref().clone().update_or_insert(connection).await?;
        self.category.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.updated_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedSampleState {
    pub inner: Rc<crate::database::flat_variants::SampleState>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedSampleState {}
unsafe impl Sync for NestedSampleState {}
impl Tabular for NestedSampleState {
    const TABLE: Table = Table::SampleStates;
}
impl Filtrable for NestedSampleState {
    type Filter = SampleStateFilter;
}
impl Describable for NestedSampleState {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedSampleState {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedSampleState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SampleState,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SampleState::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&SampleStateFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SampleState::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedSample {
    pub inner: Rc<crate::database::flat_variants::Sample>,
    pub container: Rc<crate::database::nested_variants::NestedSampleContainer>,
    pub project: Rc<crate::database::nested_variants::NestedProject>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub sampled_by: Rc<crate::database::nested_variants::NestedUser>,
    pub updated_by: Rc<crate::database::nested_variants::NestedUser>,
    pub state: Rc<crate::database::nested_variants::NestedSampleState>,
}

unsafe impl Send for NestedSample {}
unsafe impl Sync for NestedSample {}
impl Tabular for NestedSample {
    const TABLE: Table = Table::Samples;
}
impl Filtrable for NestedSample {
    type Filter = SampleFilter;
}
impl Describable for NestedSample {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedSample {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedSample {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Sample,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            container: Rc::from(crate::database::nested_variants::NestedSampleContainer::get(flat_variant.container_id, connection).await?.unwrap()),
            project: Rc::from(crate::database::nested_variants::NestedProject::get(flat_variant.project_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            sampled_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.sampled_by, connection).await?.unwrap()),
            updated_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.updated_by, connection).await?.unwrap()),
            state: Rc::from(crate::database::nested_variants::NestedSampleState::get(flat_variant.state_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Sample::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&SampleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Sample::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        filter: Option<&SampleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Sample::all_by_updated_at(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.container.as_ref().clone().update_or_insert(connection).await?;
        self.project.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.sampled_by.as_ref().clone().update_or_insert(connection).await?;
        self.updated_by.as_ref().clone().update_or_insert(connection).await?;
        self.state.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedSpectra {
    pub inner: crate::database::flat_variants::Spectra,
    pub spectra_collection: Rc<crate::database::nested_variants::NestedSpectraCollection>,
}

unsafe impl Send for NestedSpectra {}
unsafe impl Sync for NestedSpectra {}
impl Tabular for NestedSpectra {
    const TABLE: Table = Table::Spectra;
}
impl Filtrable for NestedSpectra {
    type Filter = SpectraFilter;
}
impl Describable for NestedSpectra {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedSpectra {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedSpectra {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Spectra,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            spectra_collection: Rc::from(crate::database::nested_variants::NestedSpectraCollection::get(flat_variant.spectra_collection_id, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Spectra::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&SpectraFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Spectra::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.spectra_collection.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedSpectraCollection {
    pub inner: Rc<crate::database::flat_variants::SpectraCollection>,
    pub sample: Rc<crate::database::nested_variants::NestedSample>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub updated_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedSpectraCollection {}
unsafe impl Sync for NestedSpectraCollection {}
impl Tabular for NestedSpectraCollection {
    const TABLE: Table = Table::SpectraCollections;
}
impl Filtrable for NestedSpectraCollection {
    type Filter = SpectraCollectionFilter;
}
impl Describable for NestedSpectraCollection {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedSpectraCollection {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedSpectraCollection {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: SpectraCollection,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            sample: Rc::from(crate::database::nested_variants::NestedSample::get(flat_variant.sample_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            updated_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.updated_by, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = SpectraCollection::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&SpectraCollectionFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SpectraCollection::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        filter: Option<&SpectraCollectionFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = SpectraCollection::all_by_updated_at(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.sample.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.updated_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedTeamState {
    pub inner: Rc<crate::database::flat_variants::TeamState>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedTeamState {}
unsafe impl Sync for NestedTeamState {}
impl Tabular for NestedTeamState {
    const TABLE: Table = Table::TeamStates;
}
impl Filtrable for NestedTeamState {
    type Filter = TeamStateFilter;
}
impl Describable for NestedTeamState {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedTeamState {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedTeamState {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: TeamState,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = TeamState::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&TeamStateFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = TeamState::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedTeam {
    pub inner: Rc<crate::database::flat_variants::Team>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
    pub state: Rc<crate::database::nested_variants::NestedTeamState>,
    pub parent_team: Option<Rc<crate::database::flat_variants::Team>>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub updated_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedTeam {}
unsafe impl Sync for NestedTeam {}
impl Tabular for NestedTeam {
    const TABLE: Table = Table::Teams;
}
impl Filtrable for NestedTeam {
    type Filter = TeamFilter;
}
impl Describable for NestedTeam {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedTeam {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedTeam {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Team,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            state: Rc::from(crate::database::nested_variants::NestedTeamState::get(flat_variant.state_id, connection).await?.unwrap()),
            parent_team: if let Some(parent_team_id) = flat_variant.parent_team_id { crate::database::flat_variants::Team::get(parent_team_id, connection).await?.map(Rc::from) } else { None },
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            updated_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.updated_by, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Team::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&TeamFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Team::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        filter: Option<&TeamFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Team::all_by_updated_at(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        self.state.as_ref().clone().update_or_insert(connection).await?;
        if let Some(parent_team) = self.parent_team {
            parent_team.as_ref().clone().update_or_insert(connection).await?;
        }
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.updated_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedTeamsTeamsRoleInvitation {
    pub inner: crate::database::flat_variants::TeamsTeamsRoleInvitation,
    pub table: Rc<crate::database::nested_variants::NestedTeam>,
    pub team: Rc<crate::database::nested_variants::NestedTeam>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedTeamsTeamsRoleInvitation {}
unsafe impl Sync for NestedTeamsTeamsRoleInvitation {}
impl Tabular for NestedTeamsTeamsRoleInvitation {
    const TABLE: Table = Table::TeamsTeamsRoleInvitations;
}
impl Filtrable for NestedTeamsTeamsRoleInvitation {
    type Filter = TeamsTeamsRoleInvitationFilter;
}
impl Describable for NestedTeamsTeamsRoleInvitation {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedTeamsTeamsRoleInvitation {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedTeamsTeamsRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: TeamsTeamsRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedTeam::get(flat_variant.table_id, connection).await?.unwrap()),
            team: Rc::from(crate::database::nested_variants::NestedTeam::get(flat_variant.team_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, team_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, team_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = TeamsTeamsRoleInvitation::get(( table_id, team_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&TeamsTeamsRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = TeamsTeamsRoleInvitation::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.team.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedTeamsUsersRoleInvitation {
    pub inner: crate::database::flat_variants::TeamsUsersRoleInvitation,
    pub table: Rc<crate::database::nested_variants::NestedTeam>,
    pub user: Rc<crate::database::nested_variants::NestedUser>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedTeamsUsersRoleInvitation {}
unsafe impl Sync for NestedTeamsUsersRoleInvitation {}
impl Tabular for NestedTeamsUsersRoleInvitation {
    const TABLE: Table = Table::TeamsUsersRoleInvitations;
}
impl Filtrable for NestedTeamsUsersRoleInvitation {
    type Filter = TeamsUsersRoleInvitationFilter;
}
impl Describable for NestedTeamsUsersRoleInvitation {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedTeamsUsersRoleInvitation {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedTeamsUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: TeamsUsersRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedTeam::get(flat_variant.table_id, connection).await?.unwrap()),
            user: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.user_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = TeamsUsersRoleInvitation::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&TeamsUsersRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = TeamsUsersRoleInvitation::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.user.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedTeamsUsersRoleRequest {
    pub inner: crate::database::flat_variants::TeamsUsersRoleRequest,
    pub table: Rc<crate::database::nested_variants::NestedTeam>,
    pub user: Rc<crate::database::nested_variants::NestedUser>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedTeamsUsersRoleRequest {}
unsafe impl Sync for NestedTeamsUsersRoleRequest {}
impl Tabular for NestedTeamsUsersRoleRequest {
    const TABLE: Table = Table::TeamsUsersRoleRequests;
}
impl Filtrable for NestedTeamsUsersRoleRequest {
    type Filter = TeamsUsersRoleRequestFilter;
}
impl Describable for NestedTeamsUsersRoleRequest {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedTeamsUsersRoleRequest {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedTeamsUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: TeamsUsersRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedTeam::get(flat_variant.table_id, connection).await?.unwrap()),
            user: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.user_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = TeamsUsersRoleRequest::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&TeamsUsersRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = TeamsUsersRoleRequest::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.user.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedTeamsUsersRole {
    pub inner: crate::database::flat_variants::TeamsUsersRole,
    pub table: Rc<crate::database::nested_variants::NestedTeam>,
    pub user: Rc<crate::database::nested_variants::NestedUser>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedTeamsUsersRole {}
unsafe impl Sync for NestedTeamsUsersRole {}
impl Tabular for NestedTeamsUsersRole {
    const TABLE: Table = Table::TeamsUsersRoles;
}
impl Filtrable for NestedTeamsUsersRole {
    type Filter = TeamsUsersRoleFilter;
}
impl Describable for NestedTeamsUsersRole {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedTeamsUsersRole {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedTeamsUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: TeamsUsersRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedTeam::get(flat_variant.table_id, connection).await?.unwrap()),
            user: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.user_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = TeamsUsersRole::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&TeamsUsersRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = TeamsUsersRole::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.user.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedUnit {
    pub inner: Rc<crate::database::flat_variants::Unit>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedUnit {}
unsafe impl Sync for NestedUnit {}
impl Tabular for NestedUnit {
    const TABLE: Table = Table::Units;
}
impl Filtrable for NestedUnit {
    type Filter = UnitFilter;
}
impl Describable for NestedUnit {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedUnit {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl NestedUnit {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: Unit,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            icon: Rc::from(crate::database::flat_variants::FontAwesomeIcon::get(flat_variant.icon_id, connection).await?.unwrap()),
            color: Rc::from(crate::database::flat_variants::Color::get(flat_variant.color_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = Unit::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&UnitFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = Unit::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.icon.as_ref().clone().update_or_insert(connection).await?;
        self.color.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedUserEmail {
    pub inner: Rc<crate::database::flat_variants::UserEmail>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
    pub login_provider: Rc<crate::database::nested_variants::NestedLoginProvider>,
}

unsafe impl Send for NestedUserEmail {}
unsafe impl Sync for NestedUserEmail {}
impl Tabular for NestedUserEmail {
    const TABLE: Table = Table::UserEmails;
}
impl Filtrable for NestedUserEmail {
    type Filter = UserEmailFilter;
}
impl Describable for NestedUserEmail {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedUserEmail {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedUserEmail {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: UserEmail,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            login_provider: Rc::from(crate::database::nested_variants::NestedLoginProvider::get(flat_variant.login_provider_id, connection).await?.unwrap()),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = UserEmail::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&UserEmailFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = UserEmail::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        self.login_provider.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedUser {
    pub inner: Rc<crate::database::flat_variants::User>,
    pub organization: Option<Rc<crate::database::nested_variants::NestedOrganization>>,
}

unsafe impl Send for NestedUser {}
unsafe impl Sync for NestedUser {}
impl Tabular for NestedUser {
    const TABLE: Table = Table::Users;
}
impl Filtrable for NestedUser {
    type Filter = UserFilter;
}
impl Describable for NestedUser {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedUser {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedUser {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: User,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            organization: if let Some(organization_id) = flat_variant.organization_id { crate::database::nested_variants::NestedOrganization::get(organization_id, connection).await?.map(Rc::from) } else { None },
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `id` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = User::get(id, connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&UserFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = User::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Get all the nested structs from the database ordered by the `updated_at` column.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all_by_updated_at<C>(
        filter: Option<&UserFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = User::all_by_updated_at(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.as_ref().clone().update_or_insert(connection).await?;
        if let Some(organization) = self.organization {
            organization.as_ref().clone().update_or_insert(connection).await?;
        }
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedUsersUsersRoleInvitation {
    pub inner: crate::database::flat_variants::UsersUsersRoleInvitation,
    pub table: Rc<crate::database::nested_variants::NestedUser>,
    pub user: Rc<crate::database::nested_variants::NestedUser>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedUsersUsersRoleInvitation {}
unsafe impl Sync for NestedUsersUsersRoleInvitation {}
impl Tabular for NestedUsersUsersRoleInvitation {
    const TABLE: Table = Table::UsersUsersRoleInvitations;
}
impl Filtrable for NestedUsersUsersRoleInvitation {
    type Filter = UsersUsersRoleInvitationFilter;
}
impl Describable for NestedUsersUsersRoleInvitation {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedUsersUsersRoleInvitation {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedUsersUsersRoleInvitation {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: UsersUsersRoleInvitation,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.table_id, connection).await?.unwrap()),
            user: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.user_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = UsersUsersRoleInvitation::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&UsersUsersRoleInvitationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = UsersUsersRoleInvitation::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.user.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedUsersUsersRoleRequest {
    pub inner: crate::database::flat_variants::UsersUsersRoleRequest,
    pub table: Rc<crate::database::nested_variants::NestedUser>,
    pub user: Rc<crate::database::nested_variants::NestedUser>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedUsersUsersRoleRequest {}
unsafe impl Sync for NestedUsersUsersRoleRequest {}
impl Tabular for NestedUsersUsersRoleRequest {
    const TABLE: Table = Table::UsersUsersRoleRequests;
}
impl Filtrable for NestedUsersUsersRoleRequest {
    type Filter = UsersUsersRoleRequestFilter;
}
impl Describable for NestedUsersUsersRoleRequest {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedUsersUsersRoleRequest {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedUsersUsersRoleRequest {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: UsersUsersRoleRequest,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.table_id, connection).await?.unwrap()),
            user: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.user_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = UsersUsersRoleRequest::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&UsersUsersRoleRequestFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = UsersUsersRoleRequest::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.user.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedUsersUsersRole {
    pub inner: crate::database::flat_variants::UsersUsersRole,
    pub table: Rc<crate::database::nested_variants::NestedUser>,
    pub user: Rc<crate::database::nested_variants::NestedUser>,
    pub role: Rc<crate::database::nested_variants::NestedRole>,
    pub created_by: Rc<crate::database::nested_variants::NestedUser>,
}

unsafe impl Send for NestedUsersUsersRole {}
unsafe impl Sync for NestedUsersUsersRole {}
impl Tabular for NestedUsersUsersRole {
    const TABLE: Table = Table::UsersUsersRoles;
}
impl Filtrable for NestedUsersUsersRole {
    type Filter = UsersUsersRoleFilter;
}
impl Describable for NestedUsersUsersRole {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl Colorable for NestedUsersUsersRole {
    fn color(&self) -> Option<&str> {
        None
    }
}
#[cfg(feature = "frontend")]
impl NestedUsersUsersRole {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub async fn from_flat(
        flat_variant: UsersUsersRole,
        connection: &mut gluesql::prelude::Glue<impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut>,
    ) -> Result<Self, gluesql::prelude::Error> {
        Ok(Self {
            table: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.table_id, connection).await?.unwrap()),
            user: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.user_id, connection).await?.unwrap()),
            role: Rc::from(crate::database::nested_variants::NestedRole::get(flat_variant.role_id, connection).await?.unwrap()),
            created_by: Rc::from(crate::database::nested_variants::NestedUser::get(flat_variant.created_by, connection).await?.unwrap()),
            inner: flat_variant,
        })
    }
    /// Get the nested struct from the provided primary key.
    ///
    /// # Arguments
    /// * `( table_id, user_id )` - The primary key(s) of the row.
    /// * `connection` - The database connection.
    pub async fn get<C>(
        ( table_id, user_id ): ( i32, i32 ),
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
       let flat_variant = UsersUsersRole::get(( table_id, user_id ), connection).await?;        match flat_variant {
            Some(flat_variant) => Ok(Some(Self::from_flat(flat_variant, connection).await?)),
            None => Ok(None),
        }
    }
    /// Get all the nested structs from the database.
    ///
    /// # Arguments
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of rows to return.
    /// * `offset` - The number of rows to skip.
    /// * `connection` - The database connection.
    pub async fn all<C>(
        filter: Option<&UsersUsersRoleFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        let flat_variants = UsersUsersRole::all(filter, limit, offset, connection).await?;
         let mut nested_structs = Vec::with_capacity(flat_variants.len());
         for flat_variant in flat_variants {
             nested_structs.push(Self::from_flat(flat_variant, connection).await?);
         }
         Ok(nested_structs)
    }
    /// Update or insert the nested struct into the database.
    ///
    /// # Arguments
    /// * `connection` - The database connection.
    pub async fn update_or_insert<C>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<(), gluesql::prelude::Error> where
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    {
        self.inner.update_or_insert(connection).await?;
        self.table.as_ref().clone().update_or_insert(connection).await?;
        self.user.as_ref().clone().update_or_insert(connection).await?;
        self.role.as_ref().clone().update_or_insert(connection).await?;
        self.created_by.as_ref().clone().update_or_insert(connection).await?;
        Ok(())
    }
}
