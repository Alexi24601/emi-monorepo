//! This file is automatically generated, do not modify it directly.
use super::*;
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct BioOttTaxonItem {
    pub id: i32,
    pub name: String,
    pub ott_id: i32,
    pub ott_rank_id: i32,
    pub wikidata_id: Option<i32>,
    pub ncbi_id: Option<i32>,
    pub gbif_id: Option<i32>,
    pub irmng_id: Option<i32>,
    pub worms_id: Option<i32>,
    pub domain_id: Option<i32>,
    pub kingdom_id: Option<i32>,
    pub phylum_id: Option<i32>,
    pub class_id: Option<i32>,
    pub order_id: Option<i32>,
    pub family_id: Option<i32>,
    pub genus_id: Option<i32>,
    pub parent_id: i32,
    pub icon_id: i32,
    pub color_id: i32,
}

unsafe impl Send for BioOttTaxonItem {}
unsafe impl Sync for BioOttTaxonItem {}
impl Tabular for BioOttTaxonItem {
    const TABLE: crate::database::Table = crate::database::Table::BioOttTaxonItems;
}
impl Describable for BioOttTaxonItem {
    fn description(&self) -> Option<&str> {
        None
    }
}
impl Colorable for BioOttTaxonItem {
    fn color(&self) -> Option<&str> {
        None
    }
}

impl Filtrable for crate::database::flat_variants::BioOttTaxonItem {
    type Filter = crate::database::filter_variants::BioOttTaxonItemFilter;
}
#[cfg(feature = "frontend")]
impl AllRecords for BioOttTaxonItem {
    fn all_records<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        filter: Option<&<Self as Filtrable>::Filter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> impl std::future::Future<Output = Result<Vec<Self>, crate::api::ApiError>> {
        Self::all(filter, limit, offset, connection)
    }
}
#[cfg(feature = "frontend")]
impl BioOttTaxonItem {
    /// Get the id attribute.
    pub fn get_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.id.as_ref()
    }

    /// Get the name attribute.
    pub fn get_name<E>(&self) -> &E
    where
        String: AsRef<E>,
    {
        self.name.as_ref()
    }

    /// Get the ott_id attribute.
    pub fn get_ott_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.ott_id.as_ref()
    }

    /// Get the ott_rank_id attribute.
    pub fn get_ott_rank_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.ott_rank_id.as_ref()
    }

    /// Get the wikidata_id attribute.
    pub fn get_wikidata_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.wikidata_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the ncbi_id attribute.
    pub fn get_ncbi_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.ncbi_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the gbif_id attribute.
    pub fn get_gbif_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.gbif_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the irmng_id attribute.
    pub fn get_irmng_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.irmng_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the worms_id attribute.
    pub fn get_worms_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.worms_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the domain_id attribute.
    pub fn get_domain_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.domain_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the kingdom_id attribute.
    pub fn get_kingdom_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.kingdom_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the phylum_id attribute.
    pub fn get_phylum_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.phylum_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the class_id attribute.
    pub fn get_class_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.class_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the order_id attribute.
    pub fn get_order_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.order_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the family_id attribute.
    pub fn get_family_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.family_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the genus_id attribute.
    pub fn get_genus_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.genus_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the parent_id attribute.
    pub fn get_parent_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.parent_id.as_ref()
    }

    /// Get the icon_id attribute.
    pub fn get_icon_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.icon_id.as_ref()
    }

    /// Get the color_id attribute.
    pub fn get_color_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.color_id.as_ref()
    }

    pub fn into_row(self) -> Vec<gluesql::core::ast_builder::ExprNode<'static>> {
        vec![
            gluesql::core::ast_builder::num(self.id),
            gluesql::core::ast_builder::text(self.name),
            gluesql::core::ast_builder::num(self.ott_id),
            gluesql::core::ast_builder::num(self.ott_rank_id),
            match self.wikidata_id {
                Some(wikidata_id) => gluesql::core::ast_builder::num(wikidata_id),
                None => gluesql::core::ast_builder::null(),
            },
            match self.ncbi_id {
                Some(ncbi_id) => gluesql::core::ast_builder::num(ncbi_id),
                None => gluesql::core::ast_builder::null(),
            },
            match self.gbif_id {
                Some(gbif_id) => gluesql::core::ast_builder::num(gbif_id),
                None => gluesql::core::ast_builder::null(),
            },
            match self.irmng_id {
                Some(irmng_id) => gluesql::core::ast_builder::num(irmng_id),
                None => gluesql::core::ast_builder::null(),
            },
            match self.worms_id {
                Some(worms_id) => gluesql::core::ast_builder::num(worms_id),
                None => gluesql::core::ast_builder::null(),
            },
            match self.domain_id {
                Some(domain_id) => gluesql::core::ast_builder::num(domain_id),
                None => gluesql::core::ast_builder::null(),
            },
            match self.kingdom_id {
                Some(kingdom_id) => gluesql::core::ast_builder::num(kingdom_id),
                None => gluesql::core::ast_builder::null(),
            },
            match self.phylum_id {
                Some(phylum_id) => gluesql::core::ast_builder::num(phylum_id),
                None => gluesql::core::ast_builder::null(),
            },
            match self.class_id {
                Some(class_id) => gluesql::core::ast_builder::num(class_id),
                None => gluesql::core::ast_builder::null(),
            },
            match self.order_id {
                Some(order_id) => gluesql::core::ast_builder::num(order_id),
                None => gluesql::core::ast_builder::null(),
            },
            match self.family_id {
                Some(family_id) => gluesql::core::ast_builder::num(family_id),
                None => gluesql::core::ast_builder::null(),
            },
            match self.genus_id {
                Some(genus_id) => gluesql::core::ast_builder::num(genus_id),
                None => gluesql::core::ast_builder::null(),
            },
            gluesql::core::ast_builder::num(self.parent_id),
            gluesql::core::ast_builder::num(self.icon_id),
            gluesql::core::ast_builder::num(self.color_id),
        ]
    }

    /// Insert the BioOttTaxonItem into the database.
    ///
    /// * `connection` - The connection to the database.
    async fn insert<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        use gluesql::core::ast_builder::*;
        Ok(table("bio_ott_taxon_items")
            .insert()
            .columns("id, name, ott_id, ott_rank_id, wikidata_id, ncbi_id, gbif_id, irmng_id, worms_id, domain_id, kingdom_id, phylum_id, class_id, order_id, family_id, genus_id, parent_id, icon_id, color_id")
            .values(vec![self.into_row()])
            .execute(connection)
            .await
             .map(|payload| match payload {
                 gluesql::prelude::Payload::Insert ( number_of_inserted_rows ) => number_of_inserted_rows,
                 _ => unreachable!("Payload must be an Insert"),
             })?)
    }

    /// Get the BioOttTaxonItem from the database by its ID.
    ///
    /// * `id` - The primary key(s) of the struct to check.
    /// * `connection` - The connection to the database.
    pub async fn get<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, crate::api::ApiError> {
        use gluesql::core::ast_builder::*;
        let select_row = table("bio_ott_taxon_items")
            .select()
            .filter(col("id").eq(id.to_string()))
            .project("id, name, ott_id, ott_rank_id, wikidata_id, ncbi_id, gbif_id, irmng_id, worms_id, domain_id, kingdom_id, phylum_id, class_id, order_id, family_id, genus_id, parent_id, icon_id, color_id")
            .limit(1)
            .execute(connection)
            .await?;
        Ok(select_row
            .select()
            .unwrap()
            .map(Self::from_row)
            .collect::<Vec<_>>()
            .pop())
    }

    /// Delete the BioOttTaxonItem from the database.
    ///
    /// * `connection` - The connection to the database.
    pub async fn delete<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        Self::delete_from_id(self.id, connection).await
    }

    /// Delete the BioOttTaxonItem from the database by its ID.
    ///
    /// * `id` - The primary key(s) of the struct to delete.
    /// * `connection` - The connection to the database.
    pub async fn delete_from_id<
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    >(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        use gluesql::core::ast_builder::*;
        Ok(table("bio_ott_taxon_items")
            .delete()
            .filter(col("id").eq(id.to_string()))
            .execute(connection)
            .await
            .map(|payload| match payload {
                gluesql::prelude::Payload::Delete(number_of_deleted_rows) => number_of_deleted_rows,
                _ => unreachable!("Payload must be a Delete"),
            })?)
    }

    /// Update the struct in the database.
    ///
    /// * `connection` - The connection to the database.
    async fn update<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        use gluesql::core::ast_builder::*;
        let mut update_row = table("bio_ott_taxon_items")
            .update()
            .set("id", gluesql::core::ast_builder::num(self.id))
            .set("name", gluesql::core::ast_builder::text(self.name))
            .set("ott_id", gluesql::core::ast_builder::num(self.ott_id))
            .set(
                "ott_rank_id",
                gluesql::core::ast_builder::num(self.ott_rank_id),
            )
            .set("parent_id", gluesql::core::ast_builder::num(self.parent_id))
            .set("icon_id", gluesql::core::ast_builder::num(self.icon_id))
            .set("color_id", gluesql::core::ast_builder::num(self.color_id));
        if let Some(wikidata_id) = self.wikidata_id {
            update_row =
                update_row.set("wikidata_id", gluesql::core::ast_builder::num(wikidata_id));
        }
        if let Some(ncbi_id) = self.ncbi_id {
            update_row = update_row.set("ncbi_id", gluesql::core::ast_builder::num(ncbi_id));
        }
        if let Some(gbif_id) = self.gbif_id {
            update_row = update_row.set("gbif_id", gluesql::core::ast_builder::num(gbif_id));
        }
        if let Some(irmng_id) = self.irmng_id {
            update_row = update_row.set("irmng_id", gluesql::core::ast_builder::num(irmng_id));
        }
        if let Some(worms_id) = self.worms_id {
            update_row = update_row.set("worms_id", gluesql::core::ast_builder::num(worms_id));
        }
        if let Some(domain_id) = self.domain_id {
            update_row = update_row.set("domain_id", gluesql::core::ast_builder::num(domain_id));
        }
        if let Some(kingdom_id) = self.kingdom_id {
            update_row = update_row.set("kingdom_id", gluesql::core::ast_builder::num(kingdom_id));
        }
        if let Some(phylum_id) = self.phylum_id {
            update_row = update_row.set("phylum_id", gluesql::core::ast_builder::num(phylum_id));
        }
        if let Some(class_id) = self.class_id {
            update_row = update_row.set("class_id", gluesql::core::ast_builder::num(class_id));
        }
        if let Some(order_id) = self.order_id {
            update_row = update_row.set("order_id", gluesql::core::ast_builder::num(order_id));
        }
        if let Some(family_id) = self.family_id {
            update_row = update_row.set("family_id", gluesql::core::ast_builder::num(family_id));
        }
        if let Some(genus_id) = self.genus_id {
            update_row = update_row.set("genus_id", gluesql::core::ast_builder::num(genus_id));
        }
        update_row
            .execute(connection)
            .await
            .map(|payload| match payload {
                gluesql::prelude::Payload::Update(number_of_updated_rows) => number_of_updated_rows,
                _ => unreachable!("Expected Payload::Update"),
            })
            .map_err(crate::api::ApiError::from)
    }

    /// Update the struct in the database if it exists, otherwise insert it.
    ///
    /// * `connection` - The connection to the database.
    pub async fn update_or_insert<
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    >(
        &self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        let number_of_rows = self.clone().update(connection).await?;
        if number_of_rows == 0 {
            self.clone().insert(connection).await
        } else {
            Ok(number_of_rows)
        }
    }
    /// Get all BioOttTaxonItem from the database.
    ///
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of results, by default `10`.
    /// * `offset` - The offset of the results, by default `0`.
    /// * `connection` - The connection to the database.
    pub async fn all<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        filter: Option<&crate::database::filter_variants::BioOttTaxonItemFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, crate::api::ApiError> {
        use gluesql::core::ast_builder::*;
        let select_row = table("bio_ott_taxon_items")
            .select()
            .filter(filter.map_or_else(|| gluesql::core::ast::Expr::Literal(gluesql::core::ast::AstLiteral::Boolean(true)).into(), |filter| filter.as_filter_expression()))
           .project("id, name, ott_id, ott_rank_id, wikidata_id, ncbi_id, gbif_id, irmng_id, worms_id, domain_id, kingdom_id, phylum_id, class_id, order_id, family_id, genus_id, parent_id, icon_id, color_id")
            .order_by("color_id DESC")
            .offset(offset.unwrap_or(0))
            .limit(limit.unwrap_or(10))
            .execute(connection)
            .await?;
        Ok(select_row
            .select()
            .unwrap()
            .map(Self::from_row)
            .collect::<Vec<_>>())
    }
    fn from_row(row: std::collections::HashMap<&str, &gluesql::prelude::Value>) -> Self {
        Self {
            id: match row.get("id").unwrap() {
                gluesql::prelude::Value::I32(id) => id.clone(),
                _ => unreachable!("Expected I32"),
            },
            name: match row.get("name").unwrap() {
                gluesql::prelude::Value::Str(name) => name.clone(),
                _ => unreachable!("Expected Str"),
            },
            ott_id: match row.get("ott_id").unwrap() {
                gluesql::prelude::Value::I32(ott_id) => ott_id.clone(),
                _ => unreachable!("Expected I32"),
            },
            ott_rank_id: match row.get("ott_rank_id").unwrap() {
                gluesql::prelude::Value::I32(ott_rank_id) => ott_rank_id.clone(),
                _ => unreachable!("Expected I32"),
            },
            wikidata_id: match row.get("wikidata_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(wikidata_id) => Some(wikidata_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            ncbi_id: match row.get("ncbi_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(ncbi_id) => Some(ncbi_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            gbif_id: match row.get("gbif_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(gbif_id) => Some(gbif_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            irmng_id: match row.get("irmng_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(irmng_id) => Some(irmng_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            worms_id: match row.get("worms_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(worms_id) => Some(worms_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            domain_id: match row.get("domain_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(domain_id) => Some(domain_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            kingdom_id: match row.get("kingdom_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(kingdom_id) => Some(kingdom_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            phylum_id: match row.get("phylum_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(phylum_id) => Some(phylum_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            class_id: match row.get("class_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(class_id) => Some(class_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            order_id: match row.get("order_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(order_id) => Some(order_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            family_id: match row.get("family_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(family_id) => Some(family_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            genus_id: match row.get("genus_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::I32(genus_id) => Some(genus_id.clone()),
                _ => unreachable!("Expected I32"),
            },
            parent_id: match row.get("parent_id").unwrap() {
                gluesql::prelude::Value::I32(parent_id) => parent_id.clone(),
                _ => unreachable!("Expected I32"),
            },
            icon_id: match row.get("icon_id").unwrap() {
                gluesql::prelude::Value::I32(icon_id) => icon_id.clone(),
                _ => unreachable!("Expected I32"),
            },
            color_id: match row.get("color_id").unwrap() {
                gluesql::prelude::Value::I32(color_id) => color_id.clone(),
                _ => unreachable!("Expected I32"),
            },
        }
    }
}
