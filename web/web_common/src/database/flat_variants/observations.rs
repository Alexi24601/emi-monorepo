//! This file is automatically generated, do not modify it directly.
use super::*;
use crate::traits::GuessImageFormat;
#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct Observation {
    pub id: uuid::Uuid,
    pub parent_observation_id: Option<uuid::Uuid>,
    pub created_by: i32,
    pub created_at: Option<chrono::NaiveDateTime>,
    pub updated_by: i32,
    pub updated_at: Option<chrono::NaiveDateTime>,
    pub project_id: i32,
    pub organism_id: Option<uuid::Uuid>,
    pub sample_id: Option<uuid::Uuid>,
    pub subject_id: i32,
    pub notes: Option<String>,
    pub picture: crate::types::JPEG,
}

unsafe impl Send for Observation {}
unsafe impl Sync for Observation {}
impl Tabular for Observation {
    const TABLE: crate::database::Table = crate::database::Table::Observations;
}
impl Describable for Observation {
    fn description(&self) -> Option<&str> {
        self.notes.as_deref()
    }
}
impl Colorable for Observation {
    fn color(&self) -> Option<&str> {
        None
    }
}

impl Filtrable for crate::database::flat_variants::Observation {
    type Filter = crate::database::filter_variants::ObservationFilter;
}
#[cfg(feature = "frontend")]
impl AllRecords for Observation {
    fn all_records<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        filter: Option<&<Self as Filtrable>::Filter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> impl std::future::Future<Output = Result<Vec<Self>, crate::api::ApiError>> {
        Self::all(filter, limit, offset, connection)
    }
}
#[cfg(feature = "frontend")]
impl Observation {
    /// Get the id attribute.
    pub fn get_id<E>(&self) -> &E
    where
        uuid::Uuid: AsRef<E>,
    {
        self.id.as_ref()
    }

    /// Get the parent_observation_id attribute.
    pub fn get_parent_observation_id<E>(&self) -> Option<&E>
    where
        uuid::Uuid: AsRef<E>,
    {
        self.parent_observation_id
            .as_ref()
            .map(|value| value.as_ref())
    }

    /// Get the created_by attribute.
    pub fn get_created_by<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.created_by.as_ref()
    }

    /// Get the created_at attribute.
    pub fn get_created_at<E>(&self) -> Option<&E>
    where
        chrono::NaiveDateTime: AsRef<E>,
    {
        self.created_at.as_ref().map(|value| value.as_ref())
    }

    /// Get the updated_by attribute.
    pub fn get_updated_by<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.updated_by.as_ref()
    }

    /// Get the updated_at attribute.
    pub fn get_updated_at<E>(&self) -> Option<&E>
    where
        chrono::NaiveDateTime: AsRef<E>,
    {
        self.updated_at.as_ref().map(|value| value.as_ref())
    }

    /// Get the project_id attribute.
    pub fn get_project_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.project_id.as_ref()
    }

    /// Get the organism_id attribute.
    pub fn get_organism_id<E>(&self) -> Option<&E>
    where
        uuid::Uuid: AsRef<E>,
    {
        self.organism_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the sample_id attribute.
    pub fn get_sample_id<E>(&self) -> Option<&E>
    where
        uuid::Uuid: AsRef<E>,
    {
        self.sample_id.as_ref().map(|value| value.as_ref())
    }

    /// Get the subject_id attribute.
    pub fn get_subject_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.subject_id.as_ref()
    }

    /// Get the notes attribute.
    pub fn get_notes<E>(&self) -> Option<&E>
    where
        String: AsRef<E>,
    {
        self.notes.as_ref().map(|value| value.as_ref())
    }

    /// Get the URL of the picture image.
    pub fn get_picture_as_url(&self) -> String {
        self.picture.guess_image_url().unwrap()
    }

    /// Get the picture attribute.
    pub fn get_picture<E>(&self) -> &E
    where
        crate::types::JPEG: AsRef<E>,
    {
        self.picture.as_ref()
    }

    pub fn into_row(self) -> Vec<gluesql::core::ast_builder::ExprNode<'static>> {
        vec![
            gluesql::core::ast_builder::uuid(self.id.to_string()),
            match self.parent_observation_id {
                Some(parent_observation_id) => {
                    gluesql::core::ast_builder::uuid(parent_observation_id.to_string())
                }
                None => gluesql::core::ast_builder::null(),
            },
            gluesql::core::ast_builder::num(self.created_by),
            match self.created_at {
                Some(created_at) => gluesql::core::ast_builder::timestamp(created_at.to_string()),
                None => gluesql::core::ast_builder::null(),
            },
            gluesql::core::ast_builder::num(self.updated_by),
            match self.updated_at {
                Some(updated_at) => gluesql::core::ast_builder::timestamp(updated_at.to_string()),
                None => gluesql::core::ast_builder::null(),
            },
            gluesql::core::ast_builder::num(self.project_id),
            match self.organism_id {
                Some(organism_id) => gluesql::core::ast_builder::uuid(organism_id.to_string()),
                None => gluesql::core::ast_builder::null(),
            },
            match self.sample_id {
                Some(sample_id) => gluesql::core::ast_builder::uuid(sample_id.to_string()),
                None => gluesql::core::ast_builder::null(),
            },
            gluesql::core::ast_builder::num(self.subject_id),
            match self.notes {
                Some(notes) => gluesql::core::ast_builder::text(notes),
                None => gluesql::core::ast_builder::null(),
            },
            gluesql::core::ast_builder::bytea(self.picture),
        ]
    }

    /// Insert the Observation into the database.
    ///
    /// * `connection` - The connection to the database.
    async fn insert<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        use gluesql::core::ast_builder::*;
        Ok(table("observations")
            .insert()
            .columns("id, parent_observation_id, created_by, created_at, updated_by, updated_at, project_id, organism_id, sample_id, subject_id, notes, picture")
            .values(vec![self.into_row()])
            .execute(connection)
            .await
             .map(|payload| match payload {
                 gluesql::prelude::Payload::Insert ( number_of_inserted_rows ) => number_of_inserted_rows,
                 _ => unreachable!("Payload must be an Insert"),
             })?)
    }

    /// Get the Observation from the database by its ID.
    ///
    /// * `id` - The primary key(s) of the struct to check.
    /// * `connection` - The connection to the database.
    pub async fn get<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, crate::api::ApiError> {
        use gluesql::core::ast_builder::*;
        let select_row = table("observations")
            .select()
            .filter(col("id").eq(id.to_string()))
            .project("id, parent_observation_id, created_by, created_at, updated_by, updated_at, project_id, organism_id, sample_id, subject_id, notes, picture")
            .limit(1)
            .execute(connection)
            .await?;
        Ok(select_row
            .select()
            .unwrap()
            .map(Self::from_row)
            .collect::<Vec<_>>()
            .pop())
    }

    /// Delete the Observation from the database.
    ///
    /// * `connection` - The connection to the database.
    pub async fn delete<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        Self::delete_from_id(self.id, connection).await
    }

    /// Delete the Observation from the database by its ID.
    ///
    /// * `id` - The primary key(s) of the struct to delete.
    /// * `connection` - The connection to the database.
    pub async fn delete_from_id<
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    >(
        id: uuid::Uuid,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        use gluesql::core::ast_builder::*;
        Ok(table("observations")
            .delete()
            .filter(col("id").eq(id.to_string()))
            .execute(connection)
            .await
            .map(|payload| match payload {
                gluesql::prelude::Payload::Delete(number_of_deleted_rows) => number_of_deleted_rows,
                _ => unreachable!("Payload must be a Delete"),
            })?)
    }

    /// Update the struct in the database.
    ///
    /// * `connection` - The connection to the database.
    async fn update<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        use gluesql::core::ast_builder::*;
        let mut update_row = table("observations")
            .update()
            .set("id", gluesql::core::ast_builder::uuid(self.id.to_string()))
            .set(
                "created_by",
                gluesql::core::ast_builder::num(self.created_by),
            )
            .set(
                "updated_by",
                gluesql::core::ast_builder::num(self.updated_by),
            )
            .set(
                "project_id",
                gluesql::core::ast_builder::num(self.project_id),
            )
            .set(
                "subject_id",
                gluesql::core::ast_builder::num(self.subject_id),
            )
            .set("picture", gluesql::core::ast_builder::bytea(self.picture));
        if let Some(parent_observation_id) = self.parent_observation_id {
            update_row = update_row.set(
                "parent_observation_id",
                gluesql::core::ast_builder::uuid(parent_observation_id.to_string()),
            );
        }
        if let Some(created_at) = self.created_at {
            update_row = update_row.set(
                "created_at",
                gluesql::core::ast_builder::timestamp(created_at.to_string()),
            );
        }
        if let Some(updated_at) = self.updated_at {
            update_row = update_row.set(
                "updated_at",
                gluesql::core::ast_builder::timestamp(updated_at.to_string()),
            );
        }
        if let Some(organism_id) = self.organism_id {
            update_row = update_row.set(
                "organism_id",
                gluesql::core::ast_builder::uuid(organism_id.to_string()),
            );
        }
        if let Some(sample_id) = self.sample_id {
            update_row = update_row.set(
                "sample_id",
                gluesql::core::ast_builder::uuid(sample_id.to_string()),
            );
        }
        if let Some(notes) = self.notes {
            update_row = update_row.set("notes", gluesql::core::ast_builder::text(notes));
        }
        update_row
            .execute(connection)
            .await
            .map(|payload| match payload {
                gluesql::prelude::Payload::Update(number_of_updated_rows) => number_of_updated_rows,
                _ => unreachable!("Expected Payload::Update"),
            })
            .map_err(crate::api::ApiError::from)
    }

    /// Update the struct in the database if it exists, otherwise insert it.
    ///
    /// * `connection` - The connection to the database.
    pub async fn update_or_insert<
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    >(
        &self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        let number_of_rows = self.clone().update(connection).await?;
        if number_of_rows == 0 {
            self.clone().insert(connection).await
        } else {
            Ok(number_of_rows)
        }
    }
    /// Get all Observation from the database.
    ///
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of results, by default `10`.
    /// * `offset` - The offset of the results, by default `0`.
    /// * `connection` - The connection to the database.
    pub async fn all<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        filter: Option<&crate::database::filter_variants::ObservationFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, crate::api::ApiError> {
        use gluesql::core::ast_builder::*;
        let select_row = table("observations")
            .select()
            .filter(filter.map_or_else(|| gluesql::core::ast::Expr::Literal(gluesql::core::ast::AstLiteral::Boolean(true)).into(), |filter| filter.as_filter_expression()))
           .project("id, parent_observation_id, created_by, created_at, updated_by, updated_at, project_id, organism_id, sample_id, subject_id, notes, picture")
            .order_by("picture DESC")
            .offset(offset.unwrap_or(0))
            .limit(limit.unwrap_or(10))
            .execute(connection)
            .await?;
        Ok(select_row
            .select()
            .unwrap()
            .map(Self::from_row)
            .collect::<Vec<_>>())
    }
    fn from_row(row: std::collections::HashMap<&str, &gluesql::prelude::Value>) -> Self {
        Self {
            id: match row.get("id").unwrap() {
                gluesql::prelude::Value::Uuid(id) => uuid::Uuid::from_u128(*id),
                _ => unreachable!("Expected Uuid"),
            },
            parent_observation_id: match row.get("parent_observation_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::Uuid(parent_observation_id) => {
                    Some(uuid::Uuid::from_u128(*parent_observation_id))
                }
                _ => unreachable!("Expected Uuid"),
            },
            created_by: match row.get("created_by").unwrap() {
                gluesql::prelude::Value::I32(created_by) => created_by.clone(),
                _ => unreachable!("Expected I32"),
            },
            created_at: match row.get("created_at").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::Timestamp(created_at) => Some(created_at.clone()),
                _ => unreachable!("Expected Timestamp"),
            },
            updated_by: match row.get("updated_by").unwrap() {
                gluesql::prelude::Value::I32(updated_by) => updated_by.clone(),
                _ => unreachable!("Expected I32"),
            },
            updated_at: match row.get("updated_at").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::Timestamp(updated_at) => Some(updated_at.clone()),
                _ => unreachable!("Expected Timestamp"),
            },
            project_id: match row.get("project_id").unwrap() {
                gluesql::prelude::Value::I32(project_id) => project_id.clone(),
                _ => unreachable!("Expected I32"),
            },
            organism_id: match row.get("organism_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::Uuid(organism_id) => {
                    Some(uuid::Uuid::from_u128(*organism_id))
                }
                _ => unreachable!("Expected Uuid"),
            },
            sample_id: match row.get("sample_id").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::Uuid(sample_id) => Some(uuid::Uuid::from_u128(*sample_id)),
                _ => unreachable!("Expected Uuid"),
            },
            subject_id: match row.get("subject_id").unwrap() {
                gluesql::prelude::Value::I32(subject_id) => subject_id.clone(),
                _ => unreachable!("Expected I32"),
            },
            notes: match row.get("notes").unwrap() {
                gluesql::prelude::Value::Null => None,
                gluesql::prelude::Value::Str(notes) => Some(notes.clone()),
                _ => unreachable!("Expected Str"),
            },
            picture: match row.get("picture").unwrap() {
                gluesql::prelude::Value::Bytea(picture) => picture.clone().into(),
                _ => unreachable!("Expected Bytea"),
            },
        }
    }
}
