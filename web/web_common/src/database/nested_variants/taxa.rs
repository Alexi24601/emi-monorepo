//! This module contains the nested structs for the database tables.
//!
//! This file is automatically generated. Do not write anything here.

use std::rc::Rc;

#[derive(PartialEq, Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct NestedTaxon {
    pub inner: Rc<crate::database::flat_variants::Taxon>,
    pub ott_rank: Rc<crate::database::nested_variants::NestedRank>,
    pub domain: Option<Rc<crate::database::flat_variants::Taxon>>,
    pub kingdom: Option<Rc<crate::database::flat_variants::Taxon>>,
    pub phylum: Option<Rc<crate::database::flat_variants::Taxon>>,
    pub class: Option<Rc<crate::database::flat_variants::Taxon>>,
    pub order: Option<Rc<crate::database::flat_variants::Taxon>>,
    pub family: Option<Rc<crate::database::flat_variants::Taxon>>,
    pub genus: Option<Rc<crate::database::flat_variants::Taxon>>,
    pub parent: Rc<crate::database::flat_variants::Taxon>,
    pub icon: Rc<crate::database::flat_variants::FontAwesomeIcon>,
    pub color: Rc<crate::database::flat_variants::Color>,
}

unsafe impl Send for NestedTaxon {}
unsafe impl Sync for NestedTaxon {}
impl crate::database::Tabular for NestedTaxon {
    const TABLE: crate::database::Table = crate::database::Table::Taxa;
}
impl crate::database::Filtrable for NestedTaxon {
    type Filter = crate::database::filter_variants::TaxonFilter;
}
impl crate::database::Describable for NestedTaxon {
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
}
impl crate::database::Colorable for NestedTaxon {
    fn color(&self) -> Option<&str> {
        Some(self.color.name.as_str())
    }
}
#[cfg(feature = "frontend")]
impl crate::database::AllRecords for NestedTaxon {
    fn all_records<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        filter: Option<&<Self as crate::database::Filtrable>::Filter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> impl std::future::Future<Output = Result<Vec<Self>, crate::api::ApiError>> {
        Self::all(filter, limit, offset, connection)
    }
}
#[cfg(feature = "frontend")]
impl NestedTaxon {
    /// Convert the flat struct to the nested struct.
    ///
    /// # Arguments
    /// * `flat_variant` - The flat struct.
    /// * `connection` - The database connection.
    pub(crate) async fn from_flat(
        flat_variant: crate::database::flat_variants::Taxon,
        connection: &mut gluesql::prelude::Glue<
            impl gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
        >,
    ) -> Result<Self, crate::api::ApiError> {
        Ok(Self {
            ott_rank: Rc::from(
                crate::database::nested_variants::NestedRank::get(
                    flat_variant.ott_rank_id,
                    connection,
                )
                .await?
                .unwrap(),
            ),
            domain: if let Some(domain_id) = flat_variant.domain_id {
                crate::database::flat_variants::Taxon::get(domain_id, connection)
                    .await?
                    .map(Rc::from)
            } else {
                None
            },
            kingdom: if let Some(kingdom_id) = flat_variant.kingdom_id {
                crate::database::flat_variants::Taxon::get(kingdom_id, connection)
                    .await?
                    .map(Rc::from)
            } else {
                None
            },
            phylum: if let Some(phylum_id) = flat_variant.phylum_id {
                crate::database::flat_variants::Taxon::get(phylum_id, connection)
                    .await?
                    .map(Rc::from)
            } else {
                None
            },
            class: if let Some(class_id) = flat_variant.class_id {
                crate::database::flat_variants::Taxon::get(class_id, connection)
                    .await?
                    .map(Rc::from)
            } else {
                None
            },
            order: if let Some(order_id) = flat_variant.order_id {
                crate::database::flat_variants::Taxon::get(order_id, connection)
                    .await?
                    .map(Rc::from)
            } else {
                None
            },
            family: if let Some(family_id) = flat_variant.family_id {
                crate::database::flat_variants::Taxon::get(family_id, connection)
                    .await?
                    .map(Rc::from)
            } else {
                None
            },
            genus: if let Some(genus_id) = flat_variant.genus_id {
                crate::database::flat_variants::Taxon::get(genus_id, connection)
                    .await?
                    .map(Rc::from)
            } else {
                None
            },
            parent: Rc::from(
                crate::database::flat_variants::Taxon::get(flat_variant.parent_id, connection)
                    .await?
                    .unwrap(),
            ),
            icon: Rc::from(
                crate::database::flat_variants::FontAwesomeIcon::get(
                    flat_variant.icon_id,
                    connection,
                )
                .await?
                .unwrap(),
            ),
            color: Rc::from(
                crate::database::flat_variants::Color::get(flat_variant.color_id, connection)
                    .await?
                    .unwrap(),
            ),
            inner: Rc::from(flat_variant),
        })
    }
    /// Get the id attribute.
    pub fn get_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.inner.get_id()
    }
    /// Get the name attribute.
    pub fn get_name<E>(&self) -> &E
    where
        String: AsRef<E>,
    {
        self.inner.get_name()
    }
    /// Get the ott_id attribute.
    pub fn get_ott_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.inner.get_ott_id()
    }
    /// Get the ott_rank_id attribute.
    pub fn get_ott_rank_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.inner.get_ott_rank_id()
    }
    /// Get the wikidata_id attribute.
    pub fn get_wikidata_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_wikidata_id()
    }
    /// Get the ncbi_id attribute.
    pub fn get_ncbi_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_ncbi_id()
    }
    /// Get the gbif_id attribute.
    pub fn get_gbif_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_gbif_id()
    }
    /// Get the irmng_id attribute.
    pub fn get_irmng_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_irmng_id()
    }
    /// Get the worms_id attribute.
    pub fn get_worms_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_worms_id()
    }
    /// Get the domain_id attribute.
    pub fn get_domain_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_domain_id()
    }
    /// Get the kingdom_id attribute.
    pub fn get_kingdom_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_kingdom_id()
    }
    /// Get the phylum_id attribute.
    pub fn get_phylum_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_phylum_id()
    }
    /// Get the class_id attribute.
    pub fn get_class_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_class_id()
    }
    /// Get the order_id attribute.
    pub fn get_order_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_order_id()
    }
    /// Get the family_id attribute.
    pub fn get_family_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_family_id()
    }
    /// Get the genus_id attribute.
    pub fn get_genus_id<E>(&self) -> Option<&E>
    where
        i32: AsRef<E>,
    {
        self.inner.get_genus_id()
    }
    /// Get the parent_id attribute.
    pub fn get_parent_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.inner.get_parent_id()
    }
    /// Get the icon_id attribute.
    pub fn get_icon_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.inner.get_icon_id()
    }
    /// Get the color_id attribute.
    pub fn get_color_id<E>(&self) -> &E
    where
        i32: AsRef<E>,
    {
        self.inner.get_color_id()
    }
    /// Get the Taxon from the database by its ID.
    ///
    /// * `id` - The primary key(s) of the struct to check.
    /// * `connection` - The connection to the database.
    pub async fn get<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Option<Self>, crate::api::ApiError> {
        if let Some(flat_variant) =
            crate::database::flat_variants::Taxon::get(id, connection).await?
        {
            Ok(Some(Self::from_flat(flat_variant, connection).await?))
        } else {
            Ok(None)
        }
    }
    /// Delete the Taxon from the database.
    ///
    /// * `connection` - The connection to the database.
    pub async fn delete<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        self.inner.as_ref().clone().delete(connection).await
    }
    /// Delete the Taxon from the database by its ID.
    ///
    /// * `id` - The primary key(s) of the struct to delete.
    /// * `connection` - The connection to the database.
    pub async fn delete_from_id<
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    >(
        id: i32,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        crate::database::flat_variants::Taxon::delete_from_id(id, connection).await
    }
    /// Get all Taxon from the database.
    ///
    /// * `filter` - The filter to apply to the results.
    /// * `limit` - The maximum number of results, by default `10`.
    /// * `offset` - The offset of the results, by default `0`.
    /// * `connection` - The connection to the database.
    pub async fn all<C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut>(
        filter: Option<&crate::database::filter_variants::TaxonFilter>,
        limit: Option<i64>,
        offset: Option<i64>,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<Vec<Self>, crate::api::ApiError> {
        let mut taxa = Vec::new();
        for flat_variant in
            crate::database::flat_variants::Taxon::all(filter, limit, offset, connection)
                .await?
                .into_iter()
        {
            taxa.push(Self::from_flat(flat_variant, connection).await?);
        }
        Ok(taxa)
    }
    /// Update or insert the record in the database.
    ///
    /// * `connection` - The connection to the database.
    pub async fn update_or_insert<
        C: gluesql::core::store::GStore + gluesql::core::store::GStoreMut,
    >(
        &self,
        connection: &mut gluesql::prelude::Glue<C>,
    ) -> Result<usize, crate::api::ApiError> {
        crate::database::nested_variants::NestedRank::update_or_insert(
            self.ott_rank.as_ref(),
            connection,
        )
        .await?;
        if let Some(domain) = self.domain.as_ref() {
            crate::database::flat_variants::Taxon::update_or_insert(domain, connection).await?;
        }
        if let Some(kingdom) = self.kingdom.as_ref() {
            crate::database::flat_variants::Taxon::update_or_insert(kingdom, connection).await?;
        }
        if let Some(phylum) = self.phylum.as_ref() {
            crate::database::flat_variants::Taxon::update_or_insert(phylum, connection).await?;
        }
        if let Some(class) = self.class.as_ref() {
            crate::database::flat_variants::Taxon::update_or_insert(class, connection).await?;
        }
        if let Some(order) = self.order.as_ref() {
            crate::database::flat_variants::Taxon::update_or_insert(order, connection).await?;
        }
        if let Some(family) = self.family.as_ref() {
            crate::database::flat_variants::Taxon::update_or_insert(family, connection).await?;
        }
        if let Some(genus) = self.genus.as_ref() {
            crate::database::flat_variants::Taxon::update_or_insert(genus, connection).await?;
        }
        crate::database::flat_variants::Taxon::update_or_insert(self.parent.as_ref(), connection)
            .await?;
        crate::database::flat_variants::FontAwesomeIcon::update_or_insert(
            self.icon.as_ref(),
            connection,
        )
        .await?;
        crate::database::flat_variants::Color::update_or_insert(self.color.as_ref(), connection)
            .await?;
        crate::database::flat_variants::Taxon::update_or_insert(self.inner.as_ref(), connection)
            .await
    }
}
